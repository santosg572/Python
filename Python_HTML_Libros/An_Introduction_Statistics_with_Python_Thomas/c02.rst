Chapter 2 Python
================

Python is free, consistently and completely object oriented, and has a large num-
ber of (free) scientific toolboxes (e.g., http://www.scipy.org/). It is used by Google,
NASA, and many others. Information on Python can be found under http://www.
python.org/. If you want to use Python for scientific applications, currently the best
way to get started is with a Python distribution, either WinPython, or Anaconda
from Continuum Analytics. These distributions contain the complete scientific and
engineering development software for numerical computations, data analysis, and
data visualization based on Python. They also come with Qt graphical user inter-
faces, and the interactive scientific/development environment Spyder. If you already
have experience with Matlab, the article NumPy for Matlab Users (https://numpy.
org/devdocs/user/numpy-for-matlab-users.html) provides an overview of the simi-
larities and differences between the two languages.

Python is a very-high-level dynamic object-oriented programming language
(Fig. 2.1). It is designed to be easy to program and easy to read. It was started
in 1980, and has since gained immense popularity in a broad range of fields from
web development, system administration, and in science and engineering. Python is
open source, and has become one of the most successful programming languages.
There are three reasons why I have switched from other programming languages to
Python:

* 1. It is the most elegant programming language that I know.
* 2. It is free.
* 3. It is powerful.

2.1 Getting Started
-------------------

2.1.1 Distributions and Packages

The Python core distribution contains only the essential features of a general programming language. Python itself is an interpretative programming language, with
no optimization for working with vectors or matrices, or for producing plots. Packages which extend the abilities of Python must be loaded explicitly. The most important packages for scientific applications are numpy, which makes working with vectors and matrices fast and efficient, and matplotlib, which is the most common
package used for producing graphical output. SciPy contains important scientific
algorithms. And pandas has become widely adopted for statistical data analysis. It
provides DataFrames which are labeled, 2D data structures, making work with data
more flexible and intuitive. Python can be used with different front-ends (Fig. 2.2):
from the command line or terminal; interactively, using Jupyter and IPython; and
from “Integrated Development Environments” (IDEs).

IPython provides the tools for interactive data analysis, and Jupyter provides the
different frontends for IPython. IPython lets you quickly display graphs and change
directories, explore the workspace, provides a command history, etc.

Figure 2.3 shows the modular structure of the most important Python packages
that are used in this book.

To facilitate the use of Python, so-called Python distributions collect matching
versions of the most important packages, and I strongly(!) recommend using one
of these distributions when getting started. Otherwise, one can easily become over-
whelmed by the huge number of Python packages available. My favorite Python
distributions are

• WinPython recommended for Windows users. At the time of writing, the latest
version was 3.10.5 https://winpython.github.io/
• Anaconda by Continuum, for Windows, Mac, and Linux. The latest Anaconda
version at the time of writing was 2020.11, with Python 3.9.
https://www.anaconda.com/products/individual

I am presently using WinPython, which is free and customizable. Anaconda also
runs under Mac OS and Linux, and is free for educational purposes.

The Python code samples in this book expect a Python version ≥ 3.6.

The programs included in this book have been tested under Windows and Linux.
Under Windows, the following package versions have been used:

• python 3.8.9 ... basic Python installation.
• numpy 1.20.2+mkl ... for working with vectors and arrays.
• scipy 1.6.2 ... all the essential scientific algorithms.
• matplotlib 3.4.1 ... the de facto standard module for plotting and visualization.
• pandas 1.2.4 ... adds DataFrames (imagine powerful spreadsheets) to Python.
• seaborn 0.11.1 ... statistical visualization package and visualization.
• pingouin 0.4.0 ... easy-to-use statistics functions to perform the most widely used statistical tests.
• statsmodels 0.12.2 ... for advanced statistical modeling.
• ipython 7.22.0 ... for interactive work.
• jupyter 1.0.0 ... for interactive work environments, e.g., the JupyterLab, Jupyter Notebook, or the Qt console.

All of these packages come with the WinPython and Anaconda distributions.
Additional packages, which may be required by individual applications, can easily
be installed using pip or conda.

a) PyPI—The Python Package Index

The Python Package Index (PyPI) (https://pypi.org/) is a repository of software for
the Python programming language and contains more than 390’000 projects!

Packages from PyPI can be installed easily from the Windows command shell
(cmd) or the Linux terminal with

pip install <package>

To update a package, use

pip install <package> -U

To get a list of all the Python packages installed on your computer, type

pip list

And to show information about a particular package type

pip show <package>

Anaconda uses conda, a more powerful installation manager. But pip also works
with Anaconda.

2.1.2 Installation of Python

While Python and the required packages can be installed manually, it is typically
much easier to start out with a complete Python distribution.

a) Under Windows

Neither WinPython nor Anaconda require administrator rights for installation.

WinPython In the following, I assume that <WinPythonDir> is the installation
directory for WinPython.

Tip: Do NOT install WinPython into the Windows program directory (typically
C:\Program Files or C:\Program Files (x86)), because this can lead
to permission problems during the execution of WinPython.

• Download WinPython from https://winpython.github.io/.
• Run the downloaded .exe-file, and install WinPython into the
<WinPythonDir> of your choice. (On my own system, I place all programs
that do not modify the Windows Registry, such as WinPython, vim, and ffmpeg,
into a folder C:\Programs.)

• After the installation, make a change to your Windows Environment, by typing
Win -> env -> Edit environment variables for your
account (Note that this is different from the system environment!):

– Add the directories

<WinPythonDir>\python-3.8.9.amd64;
<WinPythonDir>\python-3.8.9.amd64\Scripts\;
(or whatever your Python version number is) to your PATH. (This makes
Python and IPython accessible from the standard Windows command line,
which can be reached quickly by typing Win+cmd.)

– Remove the default

%USERPROFILE%\AppData\Local\Microsoft\WindowsApps from
the PATH (since it contains a misleading python.exe-link).

– If you do have administrator rights, you should activate

<WinPythonDir>\WinPython Control Panel.exe ->
Advanced -> Register Distribution.
(This associates .py-files with this Python distribution.)

**Anaconda**

• Download Anaconda from

https://www.anaconda.com/distribution/.

• Follow the installation instructions from the web page. During the installation,
allow Anaconda to make the suggested modifications to your environment PATH.

• After the installation: in the Anaconda Launcher, click update (besides the apps),
in order to ensure that you are running the latest version.

Installing additional packages. When I have had difficulties installing additional
packages, I have been saved more than once by the pre-compiled packages Christoph
Gohlke, available under http://www.lfd.uci.edu/~gohlke/pythonlibs/: from there you
can download the <program>.whl file for your current version of Python, and
then install it simply with pip install <program>.whl.

a) Under Linux

The following procedure works on Linux Mint 20.1:

• Download the most recent version of Anaconda.
• Open terminal, and navigate to the location where you downloaded the file to.
• Install Anaconda with bash Anaconda<xx>-y.y.y-Linux-x86.sh
• Update your Linux installation with sudo apt-get update.

**Notes to Anaconda**

• You do not need root privileges to install Anaconda if you select a user writable
install location, such as ~/Anaconda.

• After the self-extraction is finished, you should add the Anaconda binary directory
to your PATH environment variable.

• As all of Anaconda is contained in a single directory, uninstalling Anaconda is
easy: you simply remove the entire install location directory.

• If any problems remain, Mac and Unix users should look up Johansson’s instal-
lations tips:

https://github.com/jrjohansson/scientific-python-lectures

b) Under Mac OS X

• Go to https://www.anaconda.com/distribution/.

• Choose the Mac installer (make sure you select the Mac OS X Python 3.x Graph-
ical Installer), and follow the instructions listed beside this button.

• After the installation: in the Anaconda Launcher, click update (besides the Apps),
in order to ensure that you are running the latest version.

After the installation, the Anaconda icon should appear on the desktop. No admin
password is required. This downloaded version of Anaconda includes the Jupyter
Notebook, Jupyter Qt console, and the IDE Spyder.

To see which packages (e.g., numpy, scipy, matplotlib, and pandas) are featured
in your installation, look up the Anaconda Package List for your Python version. For
example, the Python-installer may not include seaborn. To add an additional pack-
age, e.g., seaborn, open the terminal, and enter pip install seaborn.

2.1.3 Installation of R and rpy2

If you have not used R previously, you can safely skip this section. However, if you
are already an avid R user, the following adjustments will allow you to also harness
the power of R from within Python, using the package rpy2.

a) Under Windows

Also, R does not require administrator rights for installation. You can download
the latest version (at the time of writing R 4.1.0) from http://cran.r-project.org/, and
install it into the <RDir> installation directory of your choice.

• After the installation of R, add the following two variables to your Windows Envi-
ronment, by typing

Win -> env -> Edit environment variables for your account:

– R_HOME=<RDir> R-4.1.0

– R_USER=<YourLoginName>

The first entry is required for rpy2. The last entry is not really necessary, just
better style.

with Anaconda. While WinPython comes with rpy2 installed, Anaconda comes
without rpy2. So after the installation of Anaconda and R, you should install rpy2
with

• conda install -c conda-forge rpy2.

b) Under Linux

• After the installation of Anaconda, install R and rpy2 with
conda install -c conda-forge rpy2.

2.1.4 Python Resources

My favorite introductory book for scientific applications of Python is Scopatz and
Huff (2015). However, that book does not provide any information on statistics. If
you have some programming experience, the book you are currently reading may be
all you need to get the statistical analysis of your data going. If required, very good
additional information can be found on the web, where tutorials as well as good free
books are available online. The following links are all recommendable sources of
information for starting with Python:

• Python Scientific Lecture Notes If you don’t read anything else, read this!
http://scipy-lectures.org/

• NumPy for Matlab Users Start here if you have Matlab experience
https://numpy.org/doc/stable/user/numpy-for-matlab-users.html
also check
http://mathesaurus.sourceforge.net/matlab-numpy.html

• Lectures on scientific computing with Python Great IPython notebooks, from JR
Johansson.
https://github.com/jrjohansson/scientific-python-lectures

• The Python tutorial The official introduction
http://docs.python.org/3/tutorial

• 7 Steps to Python My own efforts to smoothen the first steps into Python
https://work.thaslwanter.at/py_intro/

When running into a problem while developing a new piece of code, most of
the time I just google; thereby, I stick primarily to the official Python documenta-
tion pages and to http://stackoverflow.com. Also, I have found Python user groups
surprisingly active and helpful!

2.1.5 A Simple Python Program

a) Hello World

Python Shell. The simplest way to start Python is to type python on the command
line. (When I say command line, I refer in Windows to the command shell started
with cmd, and in Linux or Mac OS X to the terminal.) Then you can already
start to execute Python commands, e.g., the command to print “Hello World” to the
screen: print('Hello World'). On my Windows computer, this results in

.. code:: Python

   Python 3.8.9 (tags/v3.8.9:0a7dcbd, May 3 2021, 17:27:52)...
   Type "help", "copyright", "credits" or "license" for more...
   >>> print('Hello World')
   Hello World
   >>>

However, most of the time it is more recommendable to start with the IPython/
Jupyter Qt console described in more detail in Sect. 2.3. For example, the Jupyter Qt
console is an interactive programming environment which offers a number of advan-
tages. When you type print( in the Qt console, you immediately see information
about the possible input arguments for the command print.

**Python Modules** are files with the extension .py, and are used to store Python
commands in a file for later use. Let us create a new file with the name
helloWorld.py, which contains the single line

print('Hello World')

This file can now be executed by typing python helloWorld.py on the
command line.

On Windows, you can actually run the file by double-clicking it, or by simply
typing helloWorld.py, if the extension .py is associated with the local Python
installation. On Linux and Mac OS X, the procedure is slightly more involved. There,
the file needs to contain an additional first line specifying the path to the Python
installation.

.. code:: Python

   #! \usr\bin\python
   print('Hello World')

On these two systems, you also have to make the file executable, by typing

.. code:: Python

   chmod +x helloWorld.py

before you can run it with helloWorld.py.

b) square_me

To increase the level of complexity, let us write a Python module that includes a
function definition and prints out the square of the numbers from zero to five. (More
on functions in Sect. 2.2.5.) We call the file L2_1_square_me.py, and it con-
tains the following lines:

Listing 2.1: square_me.py

.. code:: Python

   1 # This file shows the square of the numbers 0-5.
   2
   3 def squared(x=10):
   4 return x**2
   5
   6 for ii in range(6):
   7 print(ii, squared(ii))
   8
   9 print(squared())

Let me explain what happens in this file, line-by-line:

* 1 The first line starts with “#”, indicating a comment-line.

* 3–4 These two lines define the function squared, which takes the variable x as
input, and returns the square (x**2) of this variable. If the function is called
with no input, x is by default set to 10. This notation makes it very simple to
define default values for function inputs.

Note: The range of the function is defined by the indentation! This is a fea-
ture loved by many Python programmers, but often found a bit confusing by
newcomers. Here, the last indented line is line 4, which ends the function
definition.

* 6–7 Here, the program loops over the first 6 numbers. Also, the range of the for-
loop is defined by the indentation of the code.
In line 7, each number and its corresponding square are printed to the output.

* 9 This command is not indented, and therefore is executed after the for-loop
has ended. It tests if the function call with “()”, which uses the default param-
eter for x, also works, and prints the result.

**Notes:**

• Since Python starts at 0, the loop in line 6 includes the six numbers from 0 to 5.

• In contrast to some other languages, Python distinguishes the syntax for function
calls from the syntax for addressing elements of an array, etc.: function calls, as
in line 7, are indicated with round brackets (...); and individual elements of
arrays or vectors are addressed by square brackets [...].

2.2 Elements of Scientific Python Programming
---------------------------------------------

Compared to the simple example above, real-world applications involve not only
individual numbers but also vectors and matrices. These, together with the most
important Python data- and file-structures, will be described in this section.

2.2.1 Python Datatypes

Python offers a number of powerful data structures, and it pays off to make yourself
familiar with them. The most common ones are

• Lists to group objects of the same types.

• Numpy Arrays to work with numerical data. (numpy also offers the data type
np.matrix. However, in my experience np.array is the way to go, since
many numerical and scientific functions will not accept input data in matrix
format.)

• Tuples to group objects of different types.

• Dictionaries for named, structured data sets.

• pandas DataFrames for simple import and export of data, and for statistical data
analysis.

For simple programs, you will mainly work with lists and arrays. Dictionaries are
used to group related information together. And tuples are used primarily to return
multiple parameters from functions.

In the following, we will use for Python code the input/output formatting of
IPython which will be presented in Sect. 2.3.

**List []** Lists are typically used to collect items of the same type (numbers,
strings, ...). They are “mutable”, i.e., their elements can be modified.

Note that “+” concatenates lists.

.. code:: Python

   In [1]: myList = ['abc', 'def', 'ghij']
   In [2]: myList.append('klm')
   In [3]: myList
   Out[3]: ['abc', 'def', 'ghij', 'klm']
   In [4]: myList2 = [1,2,3]
   In [5]: myList3 = [4,5,6]
   In [6]: myList2 + myList3
   Out[6]: [1, 2, 3, 4, 5, 6]

**Array []** vectors and matrices, for numerical data manipulation. They are defined
in numpy. Note that vectors and 1D arrays are different: vectors CANNOT be
transposed! With arrays, “+” adds the corresponding elements; and the array-
method .dot performs a scalar multiplication. (Since Python 3.5, scalar multiplications can also be performed with the operator “@”.)

.. code:: Python

   In [7]: import numpy as np
   ...: myArray2 = np.array(myList2)
   ...: myArray3 = np.array(myList3)
   In [8]: myArray2 + myArray3
   Out[8]: array([5, 7, 9])
   In [9]: myArray2.dot(myArray3)
   Out[9]: 32
   In [10]: myArray2 @ myArray3
   Out[10]: 32

**Tuple ( )** A collection of different things. Once created, tuples cannot be modified. (This really irritated me when I started to work with Python. But since I use
tuples almost exclusively to return parameters from functions, this has not turned
out to be any real limitation.)

.. code:: Python

   In [11]: import numpy as np
   In [12]: myTuple = ('abc', np.arange(0,3,0.2), 2.5)
   In [13]: myTuple[2]
   Out[13]: 2.5

**Dictionary { }** Dictionaries are unordered (key/value) collections of content, where
the content is addressed as dict['key']. Dictionaries can be created with the
command dict, or by using curly brackets {...}:

.. code:: Python

   In [14]: myDict = dict(one=1, two=2, info='some information')
   In [15]: myDict2 = {'ten':1, 'twenty':20, info':'more information'}
   In [16]: myDict['info']
   Out[16]: 'some information'
   In [17]: myDict.keys()
   Out[17]: dict_keys(['one', 'info', 'two'])

**DataFrame** Data structure optimized for working with named, statistical data. It
is defined in pandas. (See Sect. 2.2.4.)

2.2.2 Indexing and Slicing

The rules for addressing individual elements in Python lists, tuples, or numpy arrays
have been nicely summarized by Greg Hewgill on stackoverflow1:

.. code:: Python

   a[start:end] # items start through end-1
   a[start:] # items start through the rest of the array
   a[:end] # items from the beginning through end-1
   a[:] # a copy of the whole array

There is also the step value, which can be used with any of the above:

.. code:: Python

   a[start:end:step] # start up to end, by step

The key points to remember are that indexing starts at 0, not at 1; and the :end
value represents the first value that is not in the selected slice. So, the difference
end - start is the number of elements selected (if step is 1, the default).

start or end may be a negative number. In that case the count goes from the end
of the array instead of the beginning. So

.. code:: Python

   a[-1] # last item in the array
   a[-2:] # last two items in the array 
   a[:-2] # everything except the last two items

As a result, a[:5] gives you the first five elements
the last five elements (World).

2.2.3 Numpy Vectors and Arrays

numpy is the Python module that makes working with numbers efficient. It is com-
monly imported with

.. code:: Python

   import numpy as np

By default, it produces vectors. The commands most frequently used to generate
numbers are as follows:

**np.zeros** generates numpy arrays containing zeros. Note that it takes only one(!)
input. If you want to generate a matrix of zeroes, this input has to be a tuple or a
list, containing the number of rows/columns!

.. code:: Python

   In [1]: import numpy as np
   In [2]: np.zeros(3)
   # by default numpy-functions generate 1D-vectors
   Out[2]: array([ 0., 0., 0.])
   In [3]: np.zeros( [2,3] )
   Out[3]: array([[ 0., 0., 0.],
   [ 0., 0., 0.]])
   
**np.ones** generates numpy arrays containing ones.

**np.random.randn** generates normally distributed numbers, with a mean of 0 and
a standard deviation of 1. To produce reproducible random numbers, you have to
specify the starting point for the random number generation, for example, with
np.random.seed(...), using an integer number of your choice.

**np.arange** generates a range of numbers. Parameters can be
start, end, steppingInterval. Note that the end value is excluded! While
this can sometimes be a bit awkward, it has the advantage that consecutive
sequences can be easily generated, without any overlap, and without missing
any data points:

.. code:: Python

   In [4]: np.arange(3)
   Out[4]: array([0, 1, 2])
   In [5]: xLow = np.arange(0, 3, 0.5)
   In [6]: xHigh = np.arange(3, 5, 0.5)
   In [7]: xLow
   Out[7]: array([ 0., 0.5, 1., 1.5, 2., 2.5])
   In [8]: xHigh
   Out[8]: array([ 3., 3.5, 4., 4.5])

**np.linspace** generates linearly spaced numbers

.. code:: Python

   In [9]: np.linspace(0, 10, 6)
   Out[9]: array([ 0., 2., 4., 6., 8., 10.])

**np.array** generates a numpy array from given numerical data, and is a convenient
notation to enter small matrices

.. code:: Python

   In [10]: np.array([[1,2], [3,4]])
   Out[10]: array([ [1, 2],
   [3, 4] ])

There are a few points that are peculiar to Python, and that are worth noting:

**matrices** are simply “lists of lists”. Therefore, the first element of a matrix gives
you the first row, the second element the second row, etc.:

.. code:: Python

   In [11]: Amat = np.array([ [1, 2],
   [3, 4] ])

   In [12]: Amat[0]
   Out[12]: array([1, 2])

**Warning:** A vector is not the same as a 1D matrix! This is one of the few features
of Python that is not intuitive (at least to me), and can lead to mistakes that are
hard to find. For example, vectors cannot be transposed, but matrices can.

.. code:: Python

   In [13]: x = np.arange(3)
   In [14]: Amat = np.array([ [1,2], [3,4] ])
   In [15]: x.T == x
   Out[15]: array([ True, True, True])
   # This indicates that a vector stays a vector, and that
   # the transposition with ''.T'' has no effect on
   # its shape
   In [16]: Amat.T == Amat
   Out[16]: array([[ True, False],
   [False, True]])

**np.r_** Useful command to quickly construct small row vectors. But I only use
it to try things out quickly. In my programs, I prefer the clearer but equivalent
np.array([...])

.. code:: Python

   In [17]: np.r_[1,2,3]
   Out[17]: array([1, 2, 3], dtype=int32)

**np.c_** Useful command to quickly build up small column vectors. Note that
column-vectors can also be generated with the command np.newaxis:

.. code:: Python

   In [18]: np.c_[[1.5,2,3]] # note the double brackets!
   Out[18]: array([[1.5],
   [2. ],
   [3. ]])
   In [19]: x[:, np.newaxis]
   Out [19]: array([[0],
   [1],
   [2]])

**np.atleast_2d** Converts a vector (which cannot be transposed; see above) to the
corresponding 2D array (which can be transposed):

.. code:: Python

   In [20]: x = np.arange(5)
   In [21]: x
   Out[21]: array([0, 1, 2, 3, 4])
   In [22]: x.T
   Out[22]: array([0, 1, 2, 3, 4]) # no effect on 1D-vectors
   In [23]: x_2d = np.atleast_2d(x)
   In [24]: x_2d.T
   Out[24]: array([[0],
   [1],
   [2],
   [3],
   [4]])

**np.column_stack** An elegant command to generate column matrices:

.. code:: Python

   In [25]: x = np.arange(3)
   In [26]: y = np.arange(3,6)
   In [27]: np.column_stack( (x,y) )
   Out[27]: array([[0, 3],
   [1, 4],
   [2, 5]])

2.2.4 pandas DataFrames

pandas (http://pandas.pydata.org/) is a widely used Python package, and provides
data structures suitable for statistical analysis and data manipulation. It also adds
functions that facilitate data input, data organization, and data manipulation. pandas
is commonly imported with

.. code:: Python

   import pandas as pd

The official pandas documentation contains a very good “Getting started” section:
https://pandas.pydata.org/docs/getting_started/.

a) Basic Syntax of DataFrames

Especially in statistical data analysis (read “data science”), panelled data structures
(→ “pandas”) have turned out to be immensely useful. To handle such labeled data
in Python, pandas introduces so-called “DataFrame” objects. A DataFrame is a 2D
labeled data structure with columns of potentially different types. You can think of
it as a spreadsheet or SQL table (see Fig. 2.5). DataFrames are the most commonly
used pandas objects.

For statistical analysis, pandas becomes really powerful when combined with the
package statsmodels (https://www.statsmodels.org/).
pandas DataFrames can have some distinct advantages over numpy arrays:

• A numpy array requires homogeneous data. In contrast, with a pandas
DataFrame you can have a different data type (float, int, string, datetime, etc.)
in each column (Fig. 2.6).

• pandas has built-in functionality for a lot of common data-processing applica-
tions: for example, easy grouping by syntax, easy joins (which are also really
efficient in pandas), and rolling windows.

• DataFrames, where the data can be addressed with column names, can help a lot
in keeping track of your data.

In addition, pandas has excellent tools for data input and output.
Let me start with a specific example, by creating a DataFrame with three columns
called “Time”, “x”, and “y”:

.. code:: Python

   import numpy as np
   import pandas as pd
   t = np.arange(0, 10, 0.1)
   x = np.sin(t)
   y = np.cos(t)
   df = pd.DataFrame({'Time':t, 'x':x, 'y':y})

In pandas, rows are addressed through indices, and columns through their name.
To address the first column only, you have two options:

.. code:: Python

   df.Time
   df['Time']

To extract two columns at the same time, put the variable names in a list. With the
following command, a new DataFrame data is generated, containing the columns
Time and y:

.. code::Python

   data = df[['Time', 'y']]

After reading in the data, it is good practice to check if the data have been read
in correctly. The first or last few rows can be displayed with

.. code:: Python

   data.head()
   data.tail()

For example, the following statement shows the 5th − 10th row (note that these
are 6 rows):

.. code:: Python

   data[4:10]

as 10 − 4 = 6. (I know, the array indexing takes some time to get used to. It helps
me to think of the indices as pointers to the elements, and that they start at 0. see
Fig. 2.4)

The handling of DataFrames is somewhat different from the handling of numpy
arrays. For example, (numbered) rows and (labeled) columns can be addressed
simultaneously as follows:

.. code:: Python

   df[['Time', 'y']][4:10]

The standard row/column notation can be used by applying the method iloc:

.. code:: Python

   df.iloc[4:10, [0,2]]

Finally, sometimes one wants direct access to the data, not to the DataFrame.
This can be achieved with

.. code:: Python

   data.values

which returns a numpy array if all data have the same data type.

b) Note: Data Selection

While pandas’ DataFrames are similar to numpy arrays, their philosophy is different. The numpy syntax comes from the mathematical description of n-dimensional
matrices. In contrast, pandas has its origin in the data analysis of column-oriented
database information. Some of the differences between the two that you should
watch out for are

• numpy handles “rows” first. For example, data[0] is the first row of an array.

• pandas starts with the columns. For example, df['values'][0] is the first element of the column 'values'.

• If a DataFrame has labeled rows, one can extract, for example, the row “row_label”
with df.loc['row_label']. If one wants to address a row by its number, e.g.,
row number “15”, one can use df.iloc[15]. And iloc can be used to address
“rows/columns”, e.g., df.iloc[2:4,3].

• Slicing of rows also works, e.g., df[0:5] for the first 5 rows. A sometimes confusing convention is that if you want to slice out a single row, e.g., row “5”, you
have to use df[5:6]. df[5] raises an error!

2.2.5 Functions, Modules, and Packages

Python has three different levels of modularization:

Functions are defined by the keyword def, and can be defined anywhere in
Python. They return the object in the return statement, typically at the end of
the function.

Modules are files with the extension .py. Modules can contain function- and
variable- definitions, as well as valid Python statements.

Packages are folders containing multiple Python modules, and must contain a
file named __init__.py. For example, numpy is a Python package. Since
packages are mainly important for grouping a larger number of modules, they
won’t be discussed in this book.

a) Functions

A function is a set of statements that take inputs, do some specific computation, and
produce output. The idea is to group commonly or repeatedly done tasks and make
a function, so that instead of writing the same code again and again for different
inputs we can call the function. In Python, functions can be declared at any point in
a program with the command def.

A short application example is given in Listing 2.2. Note that in the function
definition so-called “type hints” are used (line 11) to indicate input and return type.
They are optional, but make the code easier to read and understand.

A detailed description of what happens in this piece of code is given below.
The example in Listing 2.2 shows how functions can be defined and used.

• 1: Module header, commonly written as a multiline comment
("""< xxx > """).

• 3/4: Author and date information (should be separate from the module header).3

• 7: The required Python packages have to be imported explicitly. Here, numpy will
be required, and it is customary to import numpy as np.

• 8: The command Tuple from the package typing will be used in the “type hints”
for the upcoming function. Type hints give hints on the type of the object(s) the
function is using and for its return. They are optional, but improve the readability
of code.

• 9/10: Keep 2 empty lines before function definitions.

• 11: Function signature.

• 12–23: Multiline comment describing the function. It should also include infor-
mation about the parameters the function takes, and about the return elements.

• 11–28: Function definition. Note that in Python the function block is defined by
the indentation, not by any brackets or end statements! This is a feature that irritates many Python novices, but really helps to keep code clear and nicely for-
matted. Important: Python makes a difference between a tab and the equivalent
amount of spaces. This can lead to errors which are really hard to detect, so use a
good IDE that automatically converts tabs to spaces!

• 25:

– The sum command is taken from numpy, so it has to be preceded by np.

– In Python, function arguments are indicated by round brackets (...), whereas
elements of lists, tuples, vectors, and arrays are indicated by square brackets
[...].

– In numpy, you can select elements of an array either with an index (see line
35), or with a Boolean array (lines 25–26).

• 28: Python also uses round brackets to form groups of elements, so-called
“tuples”. And the return statement does the obvious things: it returns elements
from a function.

• 31: Here, quite a few new aspects of Python are introduced:

– Just like function definitions, if-loops or for-loops use indentation to define
their context.

– A convention followed by most Python coders is to prefix variables or methods
that are supposed to be treated as a non-public part of the Python code with an
underscore, for example, _geek or __name__.

– Here, we check the variable with the name __name__, which is automatically
generated by the Python interpreter and indicates the context of a module evaluation. If the module is run as a Python script, __name__ is automatically set
to __main__. But if a module is imported (see, e.g., Listing 2.3), it is set to the
name of the importing module. This way it is possible to add code to a function
that is only used when the module is executed, but not when the functions in
this module are imported by other modules (see below). This is a nice way to
test functions defined in the same module.

• 32: Definition of a numpy array.

• 41: The two elements returned as a tuple from the function
income_and_expenses can be simultaneously assigned to two different Python
variables, here to (my_income, my_expenses).

• 42: While there are different ways to produce formatted strings, the “f-strings”
that were introduced with Python 3.6 are probably the most elegant: curly brackets
{} indicate values that will be inserted. The optional expression after the colon
contains formatting statements: here :5.2f indicates “express this number as a
float, with 5 digits, 2 of which are after the comma”.4 The corresponding values
are then passed into the f-string for formatted output. And the '\' at the end of
the line indicates a line continuation.

b) Modules

To execute the module L2_2_python_module.py from the command line, type
python L2_2_python_module.py. In Windows, if the extension “.py” is
associated with the Python program, it suffices to double-click the module, or to
type python_module.py on the command line. In WinPython, the association
of the extension “.py” with the Python function can be set by the WinPython Control
Panel.exe, by the command Register Distribution ... in the menu Advanced.

To run a module in IPython, use the magic function %run:

.. code:: Python

   In [1]: %run L2_2_python_module
   Your first transaction was a loss and is dropped.
   You have earned 23.00 EUR, and spent 10.00 EUR.

Note that you either have to be in the directory where the function is defined, or
you have to give the full path name.

If you want to use a function or variable that is defined in a different module,
you have to import that module. This can be done in three different ways. For the
following example, assume that the other module is called new_module.py, and
the function that we want from there new_function.

• import new_module: The function can then be accessed with
new_module.new_function().

• from new_module import new_function: In this case, the function can be
called directly new_function().

• from new_module import *: This imports all variables and functions from
new_module into the current workspace; again, the function can be called directly
with new_function(). However, use of this syntax is discouraged! It clutters up
the current workspace, and one risks overwriting existing variables with the same
name as an imported variable.

If you import a module multiple times, Python recognizes that the module is
already known and skips later imports.

The next example shows you how to import functions from one module into
another module:

Listing 2.3: python_import.py

.. code:: Python

   1 """ Demonstration of importing a Python module """
   2
   3 # Import standard packages
   4 import numpy as np
   5
   6 # additional packages: this imports the function from above
   7 import L2_2_python_module as py_func
   8
   9 # Generate test-data
   10 testData = np.arange(-5, 10)
   11
   12 # Use a function from the imported module
   13 out = py_func.income_and_expenses(testData)
   14
   15 # Show some results
   16 print(f'You have earned {out[0]:5.2f} EUR, '+\
   17 f' and spent {-out[1]:5.2f} EUR.')

• 7: The module L2_2_python_module (that we have just discussed above) is
imported, as py_func.

• 13: To access the function income_and_expenses from the module
py_func, module- and function-name have to be given:

py_func.income_and_expenses(...). Note that out here contains both return-
variables.

2.3 Interactive Programming—IPython/Jupyter
--------------------------------------------

2.3.1 Workflow

The best way to start a program is to take a paper and pencil and explicitly write
down the algorithms to be implemented! This helps to clarify the required programming steps, which parameters have to be provided explicitly, and which have to be
calculated during the execution of the program. In most cases, this is also the most
efficient way to start the development of a new program.

The next step is to work out the command syntax. In Python, this is best done
with IPython/Jupyter. IPython (http://ipython.org/) provides a programming environment that is optimized for interactive computing with Python, similar to the
command line in Matlab. It comes with a command history, interactive data visualization, command completion, and a lot of features that make it quick and easy to
try out code.

Once the individual steps are working, one can use the IPython command
%history to get the commands used. One can use either copy/paste that history, or
save it directly to a file with

,, code:: Python

   %history -f [fname]

Then one can switch to an integrated development environment (IDE), in my
case Wing, to generate the final, working program.

The example in Fig. 2.7 shows the first steps for a program that generates a
sine wave. Underlining the required parameters helps me to see which parameters
need to be defined at the beginning of the program. And spelling out each step
explicitly, e.g., the generation of a time-vector in line 4 in Fig. 2.7, clarifies which
additional parameters arise in the program implementation. This approach speeds up
the implementation of a program and is an important first step in avoiding mistakes.

2.3.2 Jupyter Interfaces

While IPython can also be run in a terminal-environment, its full power becomes
available with Jupyter. In 2013 the IPython Notebook, a browser-based frontend for
Python, became a very popular way to share research and results in the Python community. In 2015, the development of the frontend became its own project, called

Project Jupyter (https://jupyter.org/). Today, Jupyter can be used not only with
Python, but also with Julia, R, and more than 100 other programming languages.

The most important interfaces provided by Jupyter are

• Qt console.
• Jupyter Notebook.
• JupyterLab.

They can be started from a terminal with the command

jupyter <viewer>

where viewer is qtconsole, notebook, or lab.

a) Qt Console

The Qt console (see Fig. 2.8) is my preferred way to start coding, especially to figure
out the correct command syntax. It provides immediate feedback on the command
syntax, and good text completion for commands, file names, and variable names.

b) Jupyter Notebook

The Jupyter Notebook is a browser-based interface, which is especially well suited
for teaching, documentation, and collaborations. It allows you to combine a structured layout, equations in the popular LaTeX format, and images, and can include
resulting graphs and videos, as well as the output from Python commands (see
Fig. 2.9). Packages such as plotly (https://plot.ly/) or bokeh (https://bokeh.org/) build
on such browser-based advantages, and allow easy construction of interactive inter-
faces inside Jupyter Notebooks.

Code samples accompanying this book are also available as Jupyter Notebooks,
and can be downloaded from
https://github.com/thomas-haslwanter/statsintro-python-2e.

c) JupyterLab

JupyterLab is the successor to the Jupyter Notebook. As Fig. 2.10 shows, it extends
the Notebook with very useful capabilities such as a file browser, easy access to
commands and shortcuts, and flexible image viewers. The file format stays the same
as the Notebook, and both are saved as .ipynb-files.

2.3.3 Personalizing IPython/Jupyter

When working on a new problem, I always start out with the Qt console (see
Fig. 2.8).

In the following, <mydir> has to be replaced with your home directory (i.e., the
directory that opens up when you run cmd in Windows, or terminal in Linux).
And <myname> should be replaced by your name or your userID.

To start up IPython in a folder of your choice, and with personalized startup
scripts, proceed as follows:

a) In Windows

• Type Win+R, and start a command shell with cmd.
• In the newly created command shell, type

.. code:: Python

   ipython profile create.

(This creates the directory <mydir>\.ipython.)

• Add the Variable IPYTHONDIR to your environment (see Sect. 2.1.2), and set
it to <mydir>\.ipython. This directory contains the startup commands for
your IPython-sessions.

• Into the startup folder
<mydir>\.ipython\profile\_default\startup,
place a file for example with the name <myname>.py, containing the startup
commands that you want to execute every time that you launch IPython. My per-
sonal startup file contains the following lines, which will import frequently used
packages:

.. code:: Python

   import numpy as np
   import matplotlib.pyplot as plt
   import pandas as pd
   from scipy import stats

• Generate a file “ipy.bat” in <mydir>, containing

.. code:: Python

   jupyter qtconsole

• To customize the jupyter qtconsole type
jupyter notebook -generate-config.
This creates the file jupyter_qtconsole_config.py in your Jupyter
folder. The Jupyter folder is in the subfolder ~/.jupyter in your home directory. In this file you find multiple options to configure your Qt Console, e.g., the
distance between commands, the editor used, and the header displayed at the program start.

(The same procedure can be used to customize the jupyter notebook and
jupyter lab.)

To see all Jupyter Notebooks that come with this book, for example, do the following:

• Type Win+R, and start a command shell with cmd.

• Run the commands

.. code:: Python

   cd <ipynb-dir>
   jupyter lab

where <ipynb-dir> is the directory where all the Jupyter Notebooks are
stored.

• Again, if you want, you can put this command-sequence into a batch-file.

b) In Linux

• Start a Linux terminal with the command terminal.
• In the newly created command shell, execute the following command:

.. code:: Python

   ipython

(This generates a folder .i python.)

• Into the subfolder .ipython/profile_default/startup, place a file
with, e.g., the name 00<myname>.py, containing the lines

.. code:: Python

   import numpy as np
   import matplotlib.pyplot as plt
   from scipy import stats
   import pandas as pd

• In your .bashrc file (which contains the startup commands for your shell-
scripts), enter the lines

.. code:: Python

   alias ipy='jupyter qtconsole'
   IPYTHONDIR='~/.ipython'

• To see all Jupyter Notebooks, do the following:

– Go to <mydir>.

– Create the file ipynb.sh, containing the lines

.. code:: Python

   #!/bin/bash
   cd <ipynb-dir> 
   jupyter lab

– Make the file executable, with chmod 755 ipynb.sh.

You can now start “your” IPython by just typing ipy, and JupyterLab by typing
ipynb.sh.

c) In Mac OS X

• Start the Terminal either by manually opening Spotlight or the shortcut
CMD + SPACE and entering Terminal and search for “Terminal”.

• In Terminal, execute ipython, which will generate a folder under
<mydir>/.ipython.

• Enter the command pwd into the Terminal. This lists <mydir>; copy this for
later use.

• Now open Anaconda and launch an editor, e.g., spyder-app or TextEdit. Create
a file containing the command lines you regularly use when writing code (you
can always open this file and edit it). For starters, you can create a file with the
following command lines:

.. code:: Python

   import pandas as pd
   import os
   os.chdir('<mydir>/.ipython/profile_<myname>')

• The next steps are somewhat tricky. Mac OS X by default hides the folders
that start with “.” (They can be shown with cmd-shift-.). So to access
.ipython, open File -> Save as..... Now open a Finder window,
click the Go menu, select Go to Folder, and enter
<mydir>/.ipython/profile_default/startup. This will open a
Finder window with a header named “startup”. On the left of this text, there
should be a blue folder icon. Drag and drop the folder into the Save as... win-
dow open in the editor. IPython has a README file explaining the naming
conventions. In our case, the file should begin with 00-, so we could name it
00-<myname>. .

• Open your .bash_profile (which contains the startup commands for your
shell scripts), and enter the line

.. code:: Python

   alias ipy='jupyter qtconsole'.

• To see all IPython Notebooks, do the following:

– Go to <mydir>.

– Create the file ipynb.sh, containing the lines

.. code:: Python

   #!/bin/bash
   cd <ipynb_dir>
   jupyter lab

– Make the file executable, with chmod 755 ipynb.sh.

2.3.4 Sample Interactive Session

An important aspect of data analysis is interactive, visual inspection of the data.
My personal preference for this, and for working out the syntax of the commands
needed, is to start data analysis in the Jupyter Qt console.

In this example, I start my IPython sessions from the command line, with the
command jupyter qtconsole. (Under WinPython: if you have problems starting Jupyter from the cmd console, use the WinPython Command Prompt instead—it
is nothing else but a command terminal with the environment variables set such that
Python is readily found.)

To get started with Python and IPython, let me go step-by-step through the
IPython session in Fig. 2.11:

• IPython starts out listing the versions of IPython and Python that are used.

• In [1]: It is customary to import numpy as np, and matplotlib.pyplot, the matplotlib module containing all the plotting commands, as plt. Note that by hitting
CTRL+Enter, one can execute multiline commands. (The command sequence
gets executed after the next empty line.)

• In [2]: The command t = np.arange(0,10,0.1) generates a vector from 0 to
10, with a step size of 0.1. arange is a command in the numpy package.

• In [3]: Calculates omega. Note that the value of pi is only defined in numpy,
and does not exist in Python!

• In [4]: Since t is a vector, and sin is a function from numpy, the sine value is
calculated automatically for each value of t.

• In [5]: The “IPython magic function” pwd stands for “print working directory”,
and does just that. Tasks common with interactive computing, such as directory
changes (%cd), bookmarks for directories (%bookmark), and inspection of the
workspace (%who and %whos), are implemented as “IPython magic functions”.
If no Python variable with the same name exists, the “%” sign can be left away,
as here.

• In [7]: All the plotting commands are in the package plt. IPython generates plots
by default in the Jupyter Qt console, as shown in Fig. 2.11. Generating graphics
files is also very simple: here, I generate the PNG-file “Sinewave.png”, with a
resolution of 200 dots-per-inch.

I have mentioned above that matplotlib handles the graphics output. In Jupyter,
you can switch between inline graphs and output into an external Graphics window with %matplotlib inline and %matplotlib qt5 (see Fig. 2.12).
(Depending on your version of Python, you may have to replace %matplotlib
qt5 with %matplotlib or with %matplotlib tk.) An external graphics window allows zooming and panning, gets the cursor position (which can help to find
outliers), and gets interactive input with the command plt.ginput. matplotlib’s
plotting commands closely follow Matlab conventions.

2.3.5 Converting Interactive Commands into a Python Program

IPython is very helpful in working out the command syntax and sequence. The next
step is to turn these commands into a Python program with comments that can be
run from the command line. This section introduces a number of Python conventions
and syntax features.

For me, an efficient way to turn IPython commands into a script is to

• first obtain the command history with the command %hist or %history. (With
the option -f, you can save the history directly with the desired filename.)

• copy the history into a good integrated development environment (IDE): my pre-
ferred IDE is Wing (http://www.wingware.com/), because it provides a very comfortable and powerful working environment, with integrated code versioning, test-
ing tool, help-window, etc., and with a powerful debugger (Fig. 2.13). The latest
version of spyder, a free, science-oriented IDE that comes installed with ana-
conda and with WinPython, is also really impressive (spyder4,
https://www.spyder-ide.org/). Other popular and powerful IDEs are
pycharm (https://www.jetbrains.com/pycharm/) and Visual Studio Code
(https://code.visualstudio.com/).

• turn it into a working Python program by adding the relevant package information, substitute IPython magic commands, such as %cd, with their Python equiv-
alent, and add more documentation.

Converting the commands from the interactive session in Fig. 2.11 into a program, we get

.. code:: Python

   1 """ Short demonstration of a Python script.
   2 After a short one-line description of the content,
   3 the header can contain further details.
   4 """
   5
   6 # author: Thomas Haslwanter
   7 # date: June-2022
   8
   9 # Import standard packages
   10 import numpy as np
   11 import matplotlib.pyplot as plt
   12
   13 # Generate the time-values
   14 t = np.arange(0, 10, 0.1)
   15
   16 # Set the frequency, and calculate the sine-value
   17 freq = 0.5
   18 omega = 2 * np.pi * freq
   19 x = np.sin(omega * t)
   20
   21 # Plot the data
   22 plt.plot(t,x)
   23
   24 # Format the plot
   25 plt.xlabel('Time[sec]')
   26 plt.ylabel('Values')
   27
   28 # Generate a figure, one directory up, and let the user know
   about it
   29 out_file = '../Sinewave.jpg'
   30 plt.savefig(out_file, dpi=200)
   31 print(f'Image has been saved to {out_file}')
   32
   33 # Put it on the screen
   34 plt.show()

The following modifications were made from the IPython history:

• The commands were put into a file with the extension .py, a so-called Python
module.

• 1–4: It is common style to precede a Python module with a “multiline” header
block, even if the header has only a single line. Multiline comments are given
between triple quotes """ <xxx> """. Below the first comment block describing the module, there should be the information about the author and date. (An
excellent style-guide for Python can be found at https://pep8.org/.)

• 6: Single-line comments use # .

• 29: Care has to be taken with slashes in path names: both "/" and "\" are perfectly valid path separators in Python. However, "\\" is also used as the escape
character in strings. To take "\" in a string literally, the string has to be preceded
by “r” (for “raw string”), e.g., r'C:\Users\Peter', or it can be written as 'C:\\
Users\\Peter'.

• 31: f-strings were introduced in Python 3.6. With earlier versions, the corresponding syntax would be

.. code:: Python

   print('Image has been saved to 0'.format(out_file)).

• 34: While IPython automatically shows graphical output, Python programs don’t
show the output until this is explicitly requested by plt.show(). The idea behind
this is to optimize the program speed, only showing the graphical output when
required. The output looks the same as in Fig. 2.12.

2.4 Statistics Packages for Python
---------------------------------

2.4.1 Seaborn—Data Visualization

Seaborn (https://seaborn.pydata.org/) is a Python visualization library based on matplotlib. Its primary goal is to provide a concise, high-level interface for drawing
statistical graphics that are both informative and attractive.

For example, the following code already produces a nice regression plot (Fig. 2.14),
with line fit and confidence intervals:

.. code:: Python

   import numpy as np
   import matplotlib.pyplot as plt
   import pandas as pd
   import seaborn as sns
   x = np.linspace(1, 7, 50)
   y=3+2*x + 1.5*np.random.randn(len(x))
   df = pd.DataFrame({'xData':x, 'yData':y})
   sns.regplot('xData', 'yData', data=df)
   plt.show()

A more thorough overview of the plotting capabilities of seaborn is provided in
the Jupyter Notebook on seaborn plotting in the github-archive of this book.5

2.4.2 Pingouin

While the sub-package stats from scipy provides low-level statistical functions,
the recent package pingouin (https://pingouin-stats.org/) tries to offer simple yet
exhaustive statistics functions. As an example, compare the linear regression fit to a
noisy line:

.. code:: Python

   In [1]: import numpy as np
   ...: import pingouin as pg
   ...: from scipy import stats
   In [2]: np.random.seed(123)
   ...: x = np.arange(100)
   ...: y = 1.5*x + 50 + 10*np.random.randn(len(x))
   In [3]: stats.linregress(x,y) # linefit with scipy
   Out[3]: LinregressResult(slope=1.5028351171729766,
   intercept=50.130752434841256,
   rvalue=0.9678058655187531,
   pvalue=1.6044598942663455e-60,
   stderr=0.039481127739603966,
   intercept_stderr=2.2623409659387783)

   In [4]: lm = pg.linear_regression(x,y) # linefit with pg
   ...: np.round(lm, 2)
   Out[4]:
   names coef se T pval r2 adj_r2 CI[2.5%] CI[97.5%]
   0 Intercept 50.13 2.26 22.16 0.0 0.94 0.94 45.64 54.62
   1 x1 1.50 0.04 38.06 0.0 0.94 0.94 1.42 1.58

The output of pingouin presents the information in a much clearer and more
useful way.

2.4.3 Statsmodels—Tools for Statistical Modeling

statsmodels is a Python package contributed to the community by the statsmodels
development team (https://www.statsmodels.org/). It has a very active user community, and has in the last 12 years massively improved the suitability of Python for
statistical data analysis. statsmodels provides classes and functions for the estimation of many different statistical models, as well as for conducting statistical tests
and statistical data exploration. An extensive list of result statistics is available for
each estimator.

statsmodels also allows the formulation of models with the popular formula language based on the notation introduced (Wilkinson and Rogers 1973), and also used
by S and R. For example, the following example would fit a model that assumes a
linear relationship between x and y to a given data set:

.. code:: Python

   import numpy as np
   import pandas as pd
   import statsmodels.formula.api as sm
   # Generate noisy line, and save data in a pd-DataFrame
   x = np.arange(100)
   y = 0.5*x - 20 + np.random.randn(len(x))
   df = pd.DataFrame({'x':x, 'y':y})
   # Fit a linear model, using the "formula" language
   # added by the package "patsy"
   model = sm.ols('y~x', data=df).fit()
   print( model.summary() )

leads to the output (which will be discussed in detail in Chap. 12 on “Statistical
Models”):

Another example would be a model that assumes that “success” is determined
by “intelligence” and “diligence”, as well as the interaction of the two. With patsy’s
formula language, such a model could be described by
’success ∼ intelligence * diligence’.

An extensive list of result-statistics is available for each estimator. The results of
all statsmodels commands have been tested against existing statistical packages to
ensure that they are correct. Features include

• Linear Regression.
• Generalized Linear Models.
• Generalized Estimating Equations.
• Robust Linear Models.
• Linear Mixed Effects Models.
• Regression with Discrete Dependent Variables.
• ANOVA.
• Time Series analysis.
• Models for Survival and Duration Analysis.
• Statistics (e.g., Multiple Tests and Sample Size Calculations).
• Nonparametric Methods.
• Generalized Method of Moments.
• Empirical Likelihood.
• Graphics functions.
• A Data Sets Package.

2.5 Programming Tips
--------------------

2.5.1 General Programming Tips

• Before you start programming, spell out the steps you have to do, and write them
down as comments. A list of steps could look as follows:

# Set the parameters.
# Select the input file.
# Read in the data.
# Analyze the data.
# Show the results.
# Save the results to an outfile.
# Show the user the location of the outfile.

Not only does this help you to organize your code, but it also provides the first
rudimentary documentation of the program.

• Data analysis is an interactive task. Make use of the powerful interactive programming environment offered by IPython/Jupyter, and first develop your analysis step
by step in a Qt console or in JupyterLab.

• Once you have your data analysis—for the one block—going, grab the history
with the command history, and turn it into a function. Think about what you
want/need for the input, and what the output should be.

• And although I am repeating myself, before you implement a mathematical algo-
rithm, write it down on paper! This makes the implementation much quicker,
because you have to spell out explicitly what you want to do.

• Use the help provided by the package documentations (numpy, matplotlib, and
scipy) and by https://stackoverflow.com/. (In the first step, restrict your search to
these resources only: there are so many references and examples for Python on
the web that it is very easy to get lost in them!)

• If possible, use some simple dummy data to test your program.

• Use clear variable names: it makes code much more readable, and easier to maintain in the long run.

• Know your editor well—you are going to use it a lot. Especially, know the keyboard shortcuts!

• Learn to use the debugger. Debuggers are immensely useful to track down execution errors in programs (see Sect. A.1). Personally, I always use the debugger
from the IDE, and rarely resort to the Python built-in debugger pdb.

• Don’t repeat code. If you have to use a piece of code more than two times, write a
function instead. The ideas of Python are nicely formulated in The Zen of Python,
which you can see, for example, if you type in a Python console import this .

2.5.2 Python Tips

1. You should ALWAYS document the code that you write—even if you only hack
a small program! I have been surprised how often I have had to go back and
modify code that I thought I would “never need again”. And how often I then had
a hard time understanding my own code if there were no comments included. A
complete overview of the recommended best-practices in Python can be found
under https://pep8.org/.

2. Stick to the standard conventions:

• Every function should have a documentation string (in triple quotes """) on
the line below the function definition.

• Packages should be imported with their commonly used names:

.. code:: Python

   import numpy as np
   import matplotlib.pyplot as plt
   import scipy as sp
   import pandas as pd
   import pingouin as pg
   import seaborn as sns

3. To get the current directory, use os.path.abspath(os.curdir) or os.path.
abspath('.'). And in Python modules, a change of directories can NOT be
executed with cd (as in IPython), but instead requires the command os.chdir
(...).

4. Everything in Python is an object: to find out about “obj”, use type(obj) (to
find out the data type) and dir(obj) (to find out the methods and properties of
the object).

5. Use functions to avoid the duplication of code, and understand the
if __name__=='__main__': construct (see p. 27).

6. If you have many of your personal functions in a directory mydir that is dif-
ferent from the current working directory, you can add that directory to your
PYTHONPATH with the command

.. code:: Python

   import sys
   sys.path.append('mydir')

7. Make sure you know the basic Python syntax, especially the data structures. Try
to use matrix multiplications instead of loops wherever possible: this makes the
code nicer, and the programs much faster.

8. And along the same lines: note that many commands use an axis parameter,
and can act on rows, columns, or all data:

.. code:: Python

   In [1]: mat = [[1, 2],
   [3, 4]]
   In [2]: np.max(mat)
   Out[2]: 4

   In [3]: np.max(mat, axis=0)
   Out[3]: array([3, 4])
   In [4]: np.max(mat, axis=1)
   Out[4]: array([2, 4])

2.5.3 IPython/Jupyter Tips

1. Use IPython in the Jupyter Qt console or JupyterLab, and customize your startup
as described in Sect. 2.3.3: it will save you time in the long run!
2. For help on, e.g., plot, use help(plot) or plot?. With one question mark the
help gets displayed, with two question marks (e.g., plot??) also the source code
is shown. Also, check out the help tips shown with the command %quickref.
In JupyterLab, you can
• get help on the current command with Shift+Tab.
• get contextual help with Ctrl+I (you can move the new tab to a separate console
by simply click-dragging the tab-header with the mouse).
• Ctrl+Shift+C gives a list of all commands, and the corresponding keyboard
shortcuts.
3. Use TAB-completion, for file- and directory-names, variable names, and Python
commands. This speeds up the coding, and helps to reduce typing mistakes.
4. To switch between inline and external graphs, use
%matplotlib inline and %matplotlib or %matplotlib qt5.
5. You can use edit <fileName> to edit files in the local directory, and
%run <fileName> to execute Python scripts in your current workspace.

6. The command %bookmark lets you quickly navigate to frequently used direc-
tories.

2.6 Exercises
1. Translating Points
Write a Python script that
• specifies two points, P0 = (0/0) and P1 = (2/1). Each point should be
expressed as a Python list ([a,b]),
• combines these two points to an np.array,
• shifts those data, by adding 3 to the first coordinate, and 1 to the second,
• plots a line from the original P0 to the original P1, and on the same plot also
plot a line between the shifted values.

The result is shown in Fig. 2.15.
More information on data display is presented in Chap. 4.
2. Rotating a Vector
Write a Python script that specifies two points, P0 = (0/0) and P1 = (2/1). Then
write a Python function that
• takes a vector and an angle as input parameters,
• rotates the vector by 25 degrees by multiplying it with the rotation matrix R,
• and returns the rotated vector.
Tip A 2D rotation matrix is defined by
R = np.array([[np.cos(alpha), -np.sin(alpha)],
[np.sin(alpha), np.cos(alpha)]])
If you want to experiment a bit with plots, you can try to
• plot a green line from P0 to P1,
• superpose this plot with a coordinate system, from −2 to +2,
• superpose the rotated line in red, with increased line-thickness. (You can
modify the width of a line with the plot parameter “linewidth=”).

3. Taylor Series
• Write a function that calculates the approximation to a sine and a cosine, to
second order.

• Write a script which plots the exact values, and superposes them with approx-
imate values, in a range from −50 deg to +50 deg. (Command plt.xlim)

• Save the resulting image to a PNG-file.
Tip The second order approximations to sine and cosine are given by

sin(α) ≈ α
cos(α) ≈ 1 − α2
2 .

4. First Steps with pandas
• Generate a pandas DataFrame, with the x-column time stamps from 0 to 10
sec, at a rate of 10 Hz, the y-column data values with a sine with 1.5 Hz,
and the z-column with the corresponding cosine values. Label the x-column
time, the y-column yvals, and the z-column zvals.
• Show the head of this DataFrame.
• Extract the data in rows 10–15 from yvals and zvals, and write them to
the file out.txt.
• Let the user know where the data have been written to.
Tip A good, concise introduction into pandas is
https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html


