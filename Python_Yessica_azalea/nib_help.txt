Successfully loaded: c6_cnb/sub-27an_thresh_zstat6.nii.gz
&&&&&&&&&&&&&&&&&&&&&&&&& AnalyzeHeader &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class AnalyzeHeader in module nibabel.analyze:

class AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
 |  AnalyzeHeader(binaryblock=None, endianness=None, check=True)
 |  
 |  Class for basic analyze header
 |  
 |  Implements zoom-only setting of affine transform, and no image
 |  scaling
 |  
 |  Method resolution order:
 |      AnalyzeHeader
 |      nibabel.wrapstruct.LabeledWrapStruct
 |      nibabel.wrapstruct.WrapStruct
 |      nibabel.spatialimages.SpatialHeader
 |      nibabel.filebasedimages.FileBasedHeader
 |      nibabel.spatialimages.SpatialProtocol
 |      typing.Protocol
 |      typing.Generic
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, binaryblock=None, endianness=None, check=True)
 |      Initialize header from binary data block
 |      
 |      Parameters
 |      ----------
 |      binaryblock : {None, string} optional
 |          binary block to set into header.  By default, None, in
 |          which case we insert the default empty header block
 |      endianness : {None, '<','>', other endian code} string, optional
 |          endianness of the binaryblock.  If None, guess endianness
 |          from the data.
 |      check : bool, optional
 |          Whether to check content of header in initialization.
 |          Default is True.
 |      
 |      Examples
 |      --------
 |      >>> hdr1 = AnalyzeHeader() # an empty header
 |      >>> hdr1.endianness == native_code
 |      True
 |      >>> hdr1.get_data_shape()
 |      (0,)
 |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
 |      >>> hdr1.get_data_shape()
 |      (1, 2, 3)
 |      
 |      We can set the binary block directly via this initialization.
 |      Here we get it from the header we have just made
 |      
 |      >>> binblock2 = hdr1.binaryblock
 |      >>> hdr2 = AnalyzeHeader(binblock2)
 |      >>> hdr2.get_data_shape()
 |      (1, 2, 3)
 |      
 |      Empty headers are native endian by default
 |      
 |      >>> hdr2.endianness == native_code
 |      True
 |      
 |      You can pass valid opposite endian headers with the
 |      ``endianness`` parameter. Even empty headers can have
 |      endianness
 |      
 |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
 |      >>> hdr3.endianness == swapped_code
 |      True
 |      
 |      If you do not pass an endianness, and you pass some data, we
 |      will try to guess from the passed data.
 |      
 |      >>> binblock3 = hdr3.binaryblock
 |      >>> hdr4 = AnalyzeHeader(binblock3)
 |      >>> hdr4.endianness == swapped_code
 |      True
 |  
 |  __subclasshook__ = _proto_hook(other)
 |      # Set (or override) the protocol subclass hook.
 |  
 |  as_analyze_map(self)
 |      Return header as mapping for conversion to Analyze types
 |      
 |      Collect data from custom header type to fill in fields for Analyze and
 |      derived header types (such as Nifti1 and Nifti2).
 |      
 |      When Analyze types convert another header type to their own type, they
 |      call this this method to check if there are other Analyze / Nifti
 |      fields that the source header would like to set.
 |      
 |      Returns
 |      -------
 |      analyze_map : mapping
 |          Object that can be used as a mapping thus::
 |      
 |              for key in analyze_map:
 |                  value = analyze_map[key]
 |      
 |          where ``key`` is the name of a field that can be set in an Analyze
 |          header type, such as Nifti1, and ``value`` is a value for the
 |          field.  For example, `analyze_map` might be a something like
 |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
 |          field present in both Analyze and Nifti1, and ``slice_duration`` is
 |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
 |          header type does not recognize the field name, it will throw away
 |          the value without error.  See :meth:`Analyze.from_header`.
 |      
 |      Notes
 |      -----
 |      You can also return a Nifti header with the relevant fields set.
 |      
 |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
 |      and ``get_zooms``, for the conversion, and these get called *after*
 |      using the analyze map, so the methods will override values set in the
 |      map.
 |  
 |  data_from_fileobj(self, fileobj)
 |      Read scaled data array from `fileobj`
 |      
 |      Use this routine to get the scaled image data from an image file
 |      `fileobj`, given a header `self`.  "Scaled" means, with any header
 |      scaling factors applied to the raw data in the file.  Use
 |      `raw_data_from_fileobj` to get the raw data.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         scaled data array
 |      
 |      Notes
 |      -----
 |      We use the header to get any scale or intercept values to apply to the
 |      data.  Raw Analyze files don't have scale factors or intercepts, but
 |      this routine also works with formats based on Analyze, that do have
 |      scaling, such as SPM analyze formats and NIfTI.
 |  
 |  data_to_fileobj(self, data, fileobj, rescale=True)
 |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
 |      
 |      In writing the data, we match the header to the written data, by
 |      setting the header scaling factors, iff `rescale` is True.  Thus we
 |      modify `self` in the process of writing the data.
 |      
 |      Parameters
 |      ----------
 |      data : array-like
 |         data to write; should match header defined shape
 |      fileobj : file-like object
 |         Object with file interface, implementing ``write`` and
 |         ``seek``
 |      rescale : {True, False}, optional
 |          Whether to try and rescale data to match output dtype specified by
 |          header. If True and scaling needed and header cannot scale, then
 |          raise ``HeaderTypeError``.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.analyze import AnalyzeHeader
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((1, 2, 3))
 |      >>> hdr.set_data_dtype(np.float64)
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> data = np.arange(6).reshape(1,2,3)
 |      >>> hdr.data_to_fileobj(data, str_io)
 |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
 |      True
 |  
 |  get_base_affine(self)
 |      Get affine from basic (shared) header fields
 |      
 |      Note that we get the translations from the center of the
 |      image.
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3, 2, 1))
 |      >>> hdr.default_x_flip
 |      True
 |      >>> hdr.get_base_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  get_best_affine = get_base_affine(self)
 |  
 |  get_data_dtype(self)
 |      Get numpy dtype for data
 |      
 |      For examples see ``set_data_dtype``
 |  
 |  get_data_offset(self)
 |      Return offset into data file to read data
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_data_offset()
 |      0
 |      >>> hdr['vox_offset'] = 12
 |      >>> hdr.get_data_offset()
 |      12
 |  
 |  get_data_shape(self)
 |      Get shape of data
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_data_shape()
 |      (0,)
 |      >>> hdr.set_data_shape((1,2,3))
 |      >>> hdr.get_data_shape()
 |      (1, 2, 3)
 |      
 |      Expanding number of dimensions gets default zooms
 |      
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0, 1.0)
 |  
 |  get_slope_inter(self)
 |      Get scalefactor and intercept
 |      
 |      These are not implemented for basic Analyze
 |  
 |  get_zooms(self)
 |      Get zooms from header
 |      
 |      Returns
 |      -------
 |      z : tuple
 |         tuple of header zoom values
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_zooms()
 |      (1.0,)
 |      >>> hdr.set_data_shape((1,2))
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0)
 |      >>> hdr.set_zooms((3, 4))
 |      >>> hdr.get_zooms()
 |      (3.0, 4.0)
 |  
 |  raw_data_from_fileobj(self, fileobj)
 |      Read unscaled data array from `fileobj`
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         unscaled data array
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code or dtype or type
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_dtype(np.uint8)
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "implausible" not recognized
 |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "none" known but not supported
 |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
 |  
 |  set_data_offset(self, offset)
 |      Set offset into data file to read data
 |  
 |  set_data_shape(self, shape)
 |      Set shape of data
 |      
 |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
 |      ``ndims`` to 1.0
 |      
 |      Parameters
 |      ----------
 |      shape : sequence
 |         sequence of integers specifying data array shape
 |  
 |  set_slope_inter(self, slope, inter=None)
 |      Set slope and / or intercept into header
 |      
 |      Set slope and intercept for image data, such that, if the image
 |      data is ``arr``, then the scaled image data will be ``(arr *
 |      slope) + inter``
 |      
 |      In this case, for Analyze images, we can't store the slope or the
 |      intercept, so this method only checks that `slope` is None or NaN or
 |      1.0, and that `inter` is None or NaN or 0.
 |      
 |      Parameters
 |      ----------
 |      slope : None or float
 |          If float, value must be NaN or 1.0 or we raise a ``HeaderTypeError``
 |      inter : None or float, optional
 |          If float, value must be 0.0 or we raise a ``HeaderTypeError``
 |  
 |  set_zooms(self, zooms)
 |      Set zooms into header fields
 |      
 |      See docstring for ``get_zooms`` for examples
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  default_structarr(endianness=None) from typing._ProtocolMeta
 |      Return header data for empty header with given endianness
 |  
 |  from_header(header=None, check=True) from typing._ProtocolMeta
 |      Class method to create header from another header
 |      
 |      Parameters
 |      ----------
 |      header : ``Header`` instance or mapping
 |         a header of this class, or another class of header for
 |         conversion to this type
 |      check : {True, False}
 |         whether to check header for integrity
 |      
 |      Returns
 |      -------
 |      hdr : header instance
 |         fresh header instance of our own class
 |  
 |  guessed_endian(hdr) from typing._ProtocolMeta
 |      Guess intended endianness from mapping-like ``hdr``
 |      
 |      Parameters
 |      ----------
 |      hdr : mapping-like
 |         hdr for which to guess endianness
 |      
 |      Returns
 |      -------
 |      endianness : {'<', '>'}
 |         Guessed endianness of header
 |      
 |      Examples
 |      --------
 |      Zeros header, no information, guess native
 |      
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr_data = np.zeros((), dtype=header_dtype)
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      A valid native header is guessed native
 |      
 |      >>> hdr_data = hdr.structarr.copy()
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      And, when swapped, is guessed as swapped
 |      
 |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
 |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
 |      True
 |      
 |      The algorithm is as follows:
 |      
 |      First, look at the first value in the ``dim`` field; this
 |      should be between 0 and 7.  If it is between 1 and 7, then
 |      this must be a native endian header.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = 6
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      
 |      If the first ``dim`` value is zeros, we need a tie breaker.
 |      In that case we check the ``sizeof_hdr`` field.  This should
 |      be 348.  If it looks like the byteswapped value of 348,
 |      assumed swapped.  Otherwise assume native.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      This is overridden by the ``dim[0]`` value though:
 |      
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |  
 |  may_contain_header(binaryblock) from typing._ProtocolMeta
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __abstractmethods__ = frozenset()
 |  
 |  __parameters__ = ()
 |  
 |  default_x_flip = True
 |  
 |  has_data_intercept = False
 |  
 |  has_data_slope = False
 |  
 |  sizeof_hdr = 348
 |  
 |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __str__(self)
 |      Return string representation for printing
 |  
 |  get_value_label(self, fieldname)
 |      Returns label for coded field
 |      
 |      A coded field is an int field containing codes that stand for
 |      discrete values that also have string labels.
 |      
 |      Parameters
 |      ----------
 |      fieldname : str
 |         name of header field to get label for
 |      
 |      Returns
 |      -------
 |      label : str
 |         label for code value in header field `fieldname`
 |      
 |      Raises
 |      ------
 |      ValueError
 |          if field is not coded.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.volumeutils import Recoder
 |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
 |      >>> class C(LabeledWrapStruct):
 |      ...     template_dtype = np.dtype([('datatype', 'i2')])
 |      ...     _field_recoders = dict(datatype = recoder)
 |      >>> hdr  = C()
 |      >>> hdr.get_value_label('datatype')
 |      '<unknown code 0>'
 |      >>> hdr['datatype'] = 2
 |      >>> hdr.get_value_label('datatype')
 |      'two'
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __eq__(self, other)
 |      equality between two structures defined by binaryblock
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr2 = WrapStruct()
 |      >>> wstr == wstr2
 |      True
 |      >>> wstr3 = WrapStruct(endianness=swapped_code)
 |      >>> wstr == wstr3
 |      True
 |  
 |  __getitem__(self, item)
 |      Return values from structure data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] == 0
 |      True
 |  
 |  __iter__(self)
 |  
 |  __ne__(self, other)
 |      Return self!=value.
 |  
 |  __setitem__(self, item, value)
 |      Set values in structured data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] = 3
 |      >>> wstr['integer']
 |      array(3, dtype=int16)
 |  
 |  as_byteswapped(self, endianness=None)
 |      return new byteswapped object with given ``endianness``
 |      
 |      Guaranteed to make a copy even if endianness is the same as
 |      the current endianness.
 |      
 |      Parameters
 |      ----------
 |      endianness : None or string, optional
 |         endian code to which to swap.  None means swap from current
 |         endianness, and is the default
 |      
 |      Returns
 |      -------
 |      wstr : ``WrapStruct``
 |         ``WrapStruct`` object with given endianness
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr.endianness == native_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped()
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr is wstr
 |      False
 |      >>> bs_wstr == wstr
 |      True
 |      
 |      If you write to the resulting byteswapped data, it does not
 |      change the original.
 |      
 |      >>> bs_wstr['integer'] = 3
 |      >>> bs_wstr == wstr
 |      False
 |      
 |      If you swap to the same endianness, it returns a copy
 |      
 |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
 |      >>> nbs_wstr.endianness == native_code
 |      True
 |      >>> nbs_wstr is wstr
 |      False
 |  
 |  check_fix(self, logger=None, error_level=None)
 |      Check structured data with checks
 |      
 |      Parameters
 |      ----------
 |      logger : None or logging.Logger
 |      error_level : None or int
 |          Level of error severity at which to raise error.  Any error of
 |          severity >= `error_level` will cause an exception.
 |  
 |  copy(self)
 |      Return copy of structure
 |      
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] = 3
 |      >>> wstr2 = wstr.copy()
 |      >>> wstr2 is wstr
 |      False
 |      >>> wstr2['integer']
 |      array(3, dtype=int16)
 |  
 |  get(self, k, d=None)
 |      Return value for the key k if present or d otherwise
 |  
 |  items(self)
 |      Return items from structured data
 |  
 |  keys(self)
 |      Return keys from structured data
 |  
 |  values(self)
 |      Return values from structured data
 |  
 |  write_to(self, fileobj)
 |      Write structure to fileobj
 |      
 |      Write starts at fileobj current file position.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Should implement ``write`` method
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> wstr.write_to(str_io)
 |      >>> wstr.binaryblock == str_io.getvalue()
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
 |      Run checks over binary data, return string
 |  
 |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
 |      Return read structure with given or guessed endiancode
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Needs to implement ``read`` method
 |      endianness : None or endian code, optional
 |         Code specifying endianness of read data
 |      
 |      Returns
 |      -------
 |      wstr : WrapStruct object
 |         WrapStruct object initialized from data in fileobj
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  binaryblock
 |      binary block of data as string
 |      
 |      Returns
 |      -------
 |      binaryblock : string
 |          string giving binary data block
 |      
 |      Examples
 |      --------
 |      >>> # Make default empty structure
 |      >>> wstr = WrapStruct()
 |      >>> len(wstr.binaryblock)
 |      2
 |  
 |  endianness
 |      endian code of binary data
 |      
 |      The endianness code gives the current byte order
 |      interpretation of the binary data.
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> code = wstr.endianness
 |      >>> code == native_code
 |      True
 |      
 |      Notes
 |      -----
 |      Endianness gives endian interpretation of binary data. It is
 |      read only because the only common use case is to set the
 |      endianness on initialization, or occasionally byteswapping the
 |      data - but this is done via the as_byteswapped method
 |  
 |  structarr
 |      Structured data, with data fields
 |      
 |      Examples
 |      --------
 |      >>> wstr1 = WrapStruct() # with default data
 |      >>> an_int = wstr1.structarr['integer']
 |      >>> wstr1.structarr = None
 |      Traceback (most recent call last):
 |         ...
 |      AttributeError: ...
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
 |  
 |  data_layout = 'F'
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Protocol:
 |  
 |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
 |      This method is called when a class is subclassed.
 |      
 |      The default implementation does nothing. It may be
 |      overridden to extend subclasses.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Generic:
 |  
 |  __class_getitem__(params) from typing._ProtocolMeta

None
&&&&&&&&&&&&&&&&&&&&&&&&& AnalyzeImage &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class AnalyzeImage in module nibabel.analyze:

class AnalyzeImage(nibabel.spatialimages.SpatialImage)
 |  AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |  
 |  Class for basic Analyze format image
 |  
 |  Method resolution order:
 |      AnalyzeImage
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |  
 |  get_data_dtype(self)
 |  
 |  set_data_dtype(self, dtype)
 |  
 |  to_file_map(self, file_map=None, dtype=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead
 |      dtype : dtype-like, optional
 |         The on-disk data type to coerce the data array.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : AnalyzeImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
 |      Class to act as proxy for the array that can be read from a file
 |      
 |      The array proxy allows us to freeze the passed fileobj and header such that
 |      it returns the expected data array.
 |      
 |      This implementation assumes a contiguous array in the file object, with one
 |      of the numpy dtypes, starting at a given file position ``offset`` with
 |      single ``slope`` and ``intercept`` scaling to produce output values.
 |      
 |      The class ``__init__`` requires a spec which defines how the data will be
 |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
 |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
 |      with methods:
 |      
 |      * get_data_shape
 |      * get_data_dtype
 |      * get_data_offset
 |      * get_slope_inter
 |      
 |      A header should also have a 'copy' method.  This requirement will go away
 |      when the deprecated 'header' property goes away.
 |      
 |      This implementation allows us to deal with Analyze and its variants,
 |      including Nifti1, and with the MGH format.
 |      
 |      Other image types might need more specific classes to implement the API.
 |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
 |      examples.
 |  
 |  
 |  __annotations__ = {'_compressed_suffixes': 'tuple[str, ...]', 'files_t...
 |  
 |  files_types = (('image', '.img'), ('header', '.hdr'))
 |  
 |  header_class = <class 'nibabel.analyze.AnalyzeHeader'>
 |      Class for basic analyze header
 |      
 |      Implements zoom-only setting of affine transform, and no image
 |      scaling
 |  
 |  
 |  makeable = True
 |  
 |  rw = True
 |  
 |  valid_exts = ('.img', '.hdr')
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |      
 |      Notes
 |      -----
 |      Subclasses should override this if they have additional requirements
 |      when re-orienting an image.
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  update_header(self) -> 'None'
 |      Harmonize header with image data and affine
 |      
 |      >>> data = np.zeros((2,3,4))
 |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
 |      >>> img = SpatialImage(data, affine)
 |      >>> img.shape == (2, 3, 4)
 |      True
 |      >>> img.update_header()
 |      >>> img.header.get_data_shape() == (2, 3, 4)
 |      True
 |      >>> img.header.get_zooms()
 |      (1.0, 2.0, 3.0)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& Cifti2Header &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Cifti2Header in module nibabel.cifti2.cifti2:

class Cifti2Header(nibabel.filebasedimages.FileBasedHeader, nibabel.xmlutils.XmlSerializable)
 |  Cifti2Header(matrix=None, version='2.0')
 |  
 |  Class for CIFTI-2 header extension
 |  
 |  Method resolution order:
 |      Cifti2Header
 |      nibabel.filebasedimages.FileBasedHeader
 |      nibabel.xmlutils.XmlSerializable
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, other)
 |      Return self==value.
 |  
 |  __init__(self, matrix=None, version='2.0')
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  get_axis(self, index)
 |      Generates the Cifti2 axis for a given dimension
 |      
 |      Parameters
 |      ----------
 |      index : int
 |          Dimension for which we want to obtain the mapping.
 |      
 |      Returns
 |      -------
 |      axis : :class:`.cifti2_axes.Axis`
 |  
 |  get_index_map(self, index)
 |      Cifti2 Mapping class for a given index
 |      
 |      Parameters
 |      ----------
 |      index : int
 |          Index for which we want to obtain the mapping.
 |          Must be in the mapped_indices sequence.
 |      
 |      Returns
 |      -------
 |      cifti2_map : Cifti2MatrixIndicesMap
 |          Returns the Cifti2MatrixIndicesMap corresponding to
 |          the given index.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  from_axes(axes) from builtins.type
 |      Creates a new Cifti2 header based on the Cifti2 axes
 |      
 |      Parameters
 |      ----------
 |      axes : tuple of :class`.cifti2_axes.Axis`
 |          sequence of Cifti2 axes describing each row/column of the matrix to be stored
 |      
 |      Returns
 |      -------
 |      header : Cifti2Header
 |          new header describing the rows/columns in a format consistent with Cifti2
 |  
 |  may_contain_header(binaryblock) from builtins.type
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties defined here:
 |  
 |  mapped_indices
 |      List of matrix indices that are mapped
 |  
 |  number_of_mapped_indices
 |      Number of mapped indices
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedHeader:
 |  
 |  __ne__(self, other: 'object') -> 'bool'
 |      Return self!=value.
 |  
 |  copy(self: 'HdrT') -> 'HdrT'
 |      Copy object to independent representation
 |      
 |      The copy should not be affected by any changes to the original
 |      object.
 |  
 |  write_to(self, fileobj: 'io.IOBase') -> 'None'
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedHeader:
 |  
 |  from_fileobj(fileobj: 'io.IOBase') -> 'HdrT' from builtins.type
 |  
 |  from_header(header: 'FileBasedHeader | ty.Mapping | None' = None) -> 'HdrT' from builtins.type
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedHeader:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.xmlutils.XmlSerializable:
 |  
 |  to_xml(self, enc='utf-8', **kwargs) -> bytes
 |      Generate an XML bytestring with a given encoding.
 |      
 |      Parameters
 |      ----------
 |      enc : :class:`string`
 |          Encoding to use for the generated bytestring. Default: 'utf-8'
 |      \*\*kwargs : :class:`dict`
 |          Additional keyword arguments to :func:`xml.etree.ElementTree.tostring`.

None
&&&&&&&&&&&&&&&&&&&&&&&&& Cifti2Image &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Cifti2Image in module nibabel.cifti2.cifti2:

class Cifti2Image(nibabel.dataobj_images.DataobjImage, nibabel.filebasedimages.SerializableImage)
 |  Cifti2Image(dataobj=None, header=None, nifti_header=None, extra=None, file_map=None, dtype=None)
 |  
 |  Class for single file CIFTI-2 format image
 |  
 |  Method resolution order:
 |      Cifti2Image
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.SerializableImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, dataobj=None, header=None, nifti_header=None, extra=None, file_map=None, dtype=None)
 |      Initialize image
 |      
 |      The image is a combination of (dataobj, header), with optional metadata
 |      in `nifti_header` (a NIfTI2 header).  There may be more metadata in the
 |      mapping `extra`. Filename / file-like objects can also go in the
 |      `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |          Object containing image data.  It should be some object that
 |          returns an array from ``np.asanyarray``.  It should have a
 |          ``shape`` attribute or property.
 |      header : Cifti2Header instance or sequence of :class:`cifti2_axes.Axis`
 |          Header with data for / from XML part of CIFTI-2 format.
 |          Alternatively a sequence of cifti2_axes.Axis objects can be provided
 |          describing each dimension of the array.
 |      nifti_header : None or mapping or NIfTI2 header instance, optional
 |          Metadata for NIfTI2 component of this format.
 |      extra : None or mapping
 |          Extra metadata not captured by `header` or `nifti_header`.
 |      file_map : mapping, optional
 |          Mapping giving file information for this image format.
 |  
 |  get_data_dtype(self)
 |  
 |  set_data_dtype(self, dtype)
 |  
 |  to_file_map(self, file_map=None, dtype=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead.
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  update_headers(self)
 |      Harmonize NIfTI headers with image data
 |      
 |      Ensures that the NIfTI-2 header records the data shape in the last three
 |      ``dim`` fields. Per the spec:
 |      
 |          Because the first four dimensions in NIfTI are reserved for space and time, the CIFTI
 |          dimensions are stored in the NIfTI header in dim[5] and up, where dim[5] is the length
 |          of the first CIFTI dimension (number of values in a row), dim[6] is the length of the
 |          second CIFTI dimension, and dim[7] is the length of the third CIFTI dimension, if
 |          applicable. The fields dim[1] through dim[4] will be 1; dim[0] will be 6 or 7,
 |          depending on whether a third matrix dimension exists.
 |      
 |      >>> import numpy as np
 |      >>> data = np.zeros((2,3,4))
 |      >>> img = Cifti2Image(data)  # doctest: +IGNORE_WARNINGS
 |      >>> img.shape == (2, 3, 4)
 |      True
 |      >>> img.update_headers()
 |      >>> img.nifti_header.get_data_shape() == (1, 1, 1, 1, 2, 3, 4)
 |      True
 |      >>> img.shape == (2, 3, 4)
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Load a CIFTI-2 image from a file_map
 |      
 |      Parameters
 |      ----------
 |      file_map : file_map
 |      
 |      Returns
 |      -------
 |      img : Cifti2Image
 |          Returns a Cifti2Image
 |  
 |  from_image(img) from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : instance
 |          In fact, an object with the API of :class:`DataobjImage`.
 |      
 |      Returns
 |      -------
 |      cimg : instance
 |          Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties defined here:
 |  
 |  nifti_header
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __annotations__ = {'header': <class 'nibabel.cifti2.cifti2.Cifti2Heade...
 |  
 |  files_types = (('image', '.nii'),)
 |  
 |  header_class = <class 'nibabel.cifti2.cifti2.Cifti2Header'>
 |      Class for CIFTI-2 header extension
 |  
 |  
 |  makeable = False
 |  
 |  rw = True
 |  
 |  valid_exts = ('.nii',)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  to_bytes(self, **kwargs) -> 'bytes'
 |      Return a ``bytes`` object with the contents of the file that would
 |      be written if the image were saved.
 |      
 |      Parameters
 |      ----------
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |      
 |      Returns
 |      -------
 |      bytes
 |          Serialized image
 |  
 |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
 |      Save image to writable IO stream
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Writable stream
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
 |      Construct image from a byte string
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      bytestring : bytes
 |          Byte string containing the on-disk representation of an image
 |  
 |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
 |      Load image from readable IO stream
 |      
 |      Convert to BytesIO to enable seeking, if input stream is not seekable
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Readable stream
 |  
 |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
 |      Retrieve and load an image from a URL
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      url : str or urllib.request.Request object
 |          URL of file to retrieve
 |      timeout : float, optional
 |          Time (in seconds) to wait for a response
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __getitem__(self, key) -> 'None'
 |      No slicing or dictionary interface for images
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& FileHolder &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class FileHolder in module nibabel.fileholders:

class FileHolder(builtins.object)
 |  FileHolder(filename: 'str | None' = None, fileobj: 'io.IOBase | None' = None, pos: 'int' = 0)
 |  
 |  class to contain filename, fileobj and file position
 |  
 |  Methods defined here:
 |  
 |  __init__(self, filename: 'str | None' = None, fileobj: 'io.IOBase | None' = None, pos: 'int' = 0)
 |      Initialize FileHolder instance
 |      
 |      Parameters
 |      ----------
 |      filename : str, optional
 |         filename.  Default is None
 |      fileobj : file-like object, optional
 |         Should implement at least 'seek' (for the purposes for this
 |         class).  Default is None
 |      pos : int, optional
 |         position in filename or fileobject at which to start reading
 |         or writing data; defaults to 0
 |  
 |  get_prepare_fileobj(self, *args, **kwargs) -> 'ImageOpener'
 |      Return fileobj if present, or return fileobj from filename
 |      
 |      Set position to that given in self.pos
 |      
 |      Parameters
 |      ----------
 |      *args : tuple
 |         positional arguments to file open.  Ignored if there is a
 |         defined ``self.fileobj``.  These might include the mode, such
 |         as 'rb'
 |      **kwargs : dict
 |         named arguments to file open.  Ignored if there is a
 |         defined ``self.fileobj``
 |      
 |      Returns
 |      -------
 |      fileobj : file-like object
 |         object has position set (via ``fileobj.seek()``) to
 |         ``self.pos``
 |  
 |  same_file_as(self, other: 'FileHolder') -> 'bool'
 |      Test if `self` refers to same files / fileobj as `other`
 |      
 |      Parameters
 |      ----------
 |      other : object
 |          object with `filename` and `fileobj` attributes
 |      
 |      Returns
 |      -------
 |      tf : bool
 |          True if `other` has the same filename (or both have None) and the
 |          same fileobj (or both have None
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties defined here:
 |  
 |  file_like
 |      Return ``self.fileobj`` if not None, otherwise ``self.filename``
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __slotnames__ = []

None
&&&&&&&&&&&&&&&&&&&&&&&&& FileHolderError &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class FileHolderError in module nibabel.fileholders:

class FileHolderError(builtins.Exception)
 |  Method resolution order:
 |      FileHolderError
 |      builtins.Exception
 |      builtins.BaseException
 |      builtins.object
 |  
 |  Data descriptors defined here:
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.Exception:
 |  
 |  __init__(self, /, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from builtins.Exception:
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.BaseException:
 |  
 |  __delattr__(self, name, /)
 |      Implement delattr(self, name).
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __reduce__(...)
 |      Helper for pickle.
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __setattr__(self, name, value, /)
 |      Implement setattr(self, name, value).
 |  
 |  __setstate__(...)
 |  
 |  __str__(self, /)
 |      Return str(self).
 |  
 |  with_traceback(...)
 |      Exception.with_traceback(tb) --
 |      set self.__traceback__ to tb and return self.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from builtins.BaseException:
 |  
 |  __cause__
 |      exception cause
 |  
 |  __context__
 |      exception context
 |  
 |  __dict__
 |  
 |  __suppress_context__
 |  
 |  __traceback__
 |  
 |  args

None
&&&&&&&&&&&&&&&&&&&&&&&&& GiftiImage &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class GiftiImage in module nibabel.gifti.gifti:

class GiftiImage(nibabel.xmlutils.XmlSerializable, nibabel.filebasedimages.SerializableImage)
 |  GiftiImage(header=None, extra=None, file_map=None, meta=None, labeltable=None, darrays=None, version='1.0')
 |  
 |  GIFTI image object
 |  
 |  The Gifti spec suggests using the following suffixes to your
 |  filename when saving each specific type of data:
 |  
 |  .gii
 |      Generic GIFTI File
 |  .coord.gii
 |      Coordinates
 |  .func.gii
 |      Functional
 |  .label.gii
 |      Labels
 |  .rgba.gii
 |      RGB or RGBA
 |  .shape.gii
 |      Shape
 |  .surf.gii
 |      Surface
 |  .tensor.gii
 |      Tensors
 |  .time.gii
 |      Time Series
 |  .topo.gii
 |      Topology
 |  
 |  The Gifti file is stored in endian convention of the current machine.
 |  
 |  Method resolution order:
 |      GiftiImage
 |      nibabel.xmlutils.XmlSerializable
 |      nibabel.filebasedimages.SerializableImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, header=None, extra=None, file_map=None, meta=None, labeltable=None, darrays=None, version='1.0')
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  add_gifti_data_array(self, dataarr)
 |      Adds a data array to the GiftiImage
 |      
 |      Parameters
 |      ----------
 |      dataarr : :class:`GiftiDataArray` instance
 |  
 |  agg_data(self, intent_code=None)
 |      Aggregate GIFTI data arrays into an ndarray or tuple of ndarray
 |      
 |      In the general case, the numpy data array is extracted from each ``GiftiDataArray``
 |      object and returned in a ``tuple``, in the order they are found in the GIFTI image.
 |      
 |      If all ``GiftiDataArray`` s have ``intent`` of 2001 (``NIFTI_INTENT_TIME_SERIES``),
 |      then the data arrays are concatenated as columns, producing a vertex-by-time array.
 |      If an ``intent_code`` is passed, data arrays are filtered by the selected intents,
 |      before being aggregated.
 |      This may be useful for images containing several intents, or ensuring an expected
 |      data type in an image of uncertain provenance.
 |      If ``intent_code`` is a ``tuple``, then a ``tuple`` will be returned with the result of
 |      ``agg_data`` for each element, in order.
 |      This may be useful for ensuring that expected data arrives in a consistent order.
 |      
 |      Parameters
 |      ----------
 |      intent_code : None, string, integer or tuple of strings or integers, optional
 |          code(s) specifying nifti intent
 |      
 |      Returns
 |      -------
 |      tuple of ndarrays or ndarray
 |          If the input is a tuple, the returned tuple will match the order.
 |      
 |      Examples
 |      --------
 |      
 |      Consider a surface GIFTI file:
 |      
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import get_test_data
 |      >>> surf_img = nib.load(get_test_data('gifti', 'ascii.gii'))
 |      
 |      The coordinate data, which is indicated by the ``NIFTI_INTENT_POINTSET``
 |      intent code, may be retrieved using any of the following equivalent
 |      calls:
 |      
 |      >>> coords = surf_img.agg_data('NIFTI_INTENT_POINTSET')
 |      >>> coords_2 = surf_img.agg_data('pointset')
 |      >>> coords_3 = surf_img.agg_data(1008)  # Numeric code for pointset
 |      >>> print(np.array2string(coords, precision=3))
 |      [[-16.072 -66.188  21.267]
 |       [-16.706 -66.054  21.233]
 |       [-17.614 -65.402  21.071]]
 |      >>> np.array_equal(coords, coords_2)
 |      True
 |      >>> np.array_equal(coords, coords_3)
 |      True
 |      
 |      Similarly, the triangle mesh can be retrieved using various intent
 |      specifiers:
 |      
 |      >>> triangles = surf_img.agg_data('NIFTI_INTENT_TRIANGLE')
 |      >>> triangles_2 = surf_img.agg_data('triangle')
 |      >>> triangles_3 = surf_img.agg_data(1009)  # Numeric code for pointset
 |      >>> print(np.array2string(triangles))
 |      [[0 1 2]]
 |      >>> np.array_equal(triangles, triangles_2)
 |      True
 |      >>> np.array_equal(triangles, triangles_3)
 |      True
 |      
 |      All arrays can be retrieved as a ``tuple`` by omitting the intent
 |      code:
 |      
 |      >>> coords_4, triangles_4 = surf_img.agg_data()
 |      >>> np.array_equal(coords, coords_4)
 |      True
 |      >>> np.array_equal(triangles, triangles_4)
 |      True
 |      
 |      Finally, a tuple of intent codes may be passed in order to select
 |      the arrays in a specific order:
 |      
 |      >>> triangles_5, coords_5 = surf_img.agg_data(('triangle', 'pointset'))
 |      >>> np.array_equal(triangles, triangles_5)
 |      True
 |      >>> np.array_equal(coords, coords_5)
 |      True
 |      
 |      The following image is a GIFTI file with ten (10) data arrays of the same
 |      size, and with intent code 2001 (``NIFTI_INTENT_TIME_SERIES``):
 |      
 |      >>> func_img = nib.load(get_test_data('gifti', 'task.func.gii'))
 |      
 |      When aggregating time series data, these arrays are concatenated into
 |      a single, vertex-by-timestep array:
 |      
 |      >>> series = func_img.agg_data()
 |      >>> series.shape
 |      (642, 10)
 |      
 |      In the case of a GIFTI file with unknown data arrays, it may be preferable
 |      to specify the intent code, so that a time series array is always returned:
 |      
 |      >>> series_2 = func_img.agg_data('NIFTI_INTENT_TIME_SERIES')
 |      >>> series_3 = func_img.agg_data('time series')
 |      >>> series_4 = func_img.agg_data(2001)
 |      >>> np.array_equal(series, series_2)
 |      True
 |      >>> np.array_equal(series, series_3)
 |      True
 |      >>> np.array_equal(series, series_4)
 |      True
 |      
 |      Requesting a data array from a GIFTI file with no matching intent codes
 |      will result in an empty tuple:
 |      
 |      >>> surf_img.agg_data('time series')
 |      ()
 |      >>> func_img.agg_data('triangle')
 |      ()
 |  
 |  get_arrays_from_intent(self, intent)
 |      Return list of GiftiDataArray elements matching given intent
 |  
 |  print_summary(self)
 |  
 |  remove_gifti_data_array(self, ith)
 |      Removes the ith data array element from the GiftiImage
 |  
 |  remove_gifti_data_array_by_intent(self, intent)
 |      Removes all the data arrays with the given intent type
 |  
 |  to_bytes(self, enc='utf-8', *, mode='strict')
 |      Return a ``bytes`` object with the contents of the file that would
 |      be written if the image were saved.
 |      
 |      Parameters
 |      ----------
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |      
 |      Returns
 |      -------
 |      bytes
 |          Serialized image
 |  
 |  to_file_map(self, file_map=None, enc='utf-8', *, mode='strict')
 |      Save the current image to the specified file_map
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Dictionary with single key ``image`` with associated value which is
 |          a :class:`FileHolder` instance pointing to the image file.
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  to_xml(self, enc='utf-8', *, mode='strict', **kwargs) -> 'bytes'
 |      Return XML corresponding to image content
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  from_file_map(file_map, buffer_size=35000000, mmap=True) from builtins.type
 |      Load a Gifti image from a file_map
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Dictionary with single key ``image`` with associated value which is
 |          a :class:`FileHolder` instance pointing to the image file.
 |      
 |      buffer_size: None or int, optional
 |          size of read buffer. None uses default buffer_size
 |          from xml.parsers.expat.
 |      
 |      mmap : {True, False, 'c', 'r', 'r+'}
 |          Controls the use of numpy memory mapping for reading data.  Only
 |          has an effect when loading GIFTI images with data stored in
 |          external files (``DataArray`` elements with an ``Encoding`` equal
 |          to ``ExternalFileBinary``).  If ``False``, do not try numpy
 |          ``memmap`` for data array.  If one of ``{'c', 'r', 'r+'}``, try
 |          numpy ``memmap`` with ``mode=mmap``.  A `mmap` value of ``True``
 |          gives the same behavior as ``mmap='c'``.  If the file cannot be
 |          memory-mapped, ignore `mmap` value and read array from file.
 |      
 |      Returns
 |      -------
 |      img : GiftiImage
 |  
 |  from_filename(filename, buffer_size=35000000, mmap=True) from builtins.type
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties defined here:
 |  
 |  numDA
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  labeltable
 |  
 |  meta
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __annotations__ = {'parser': 'Type[xml.XmlParser]'}
 |  
 |  files_types = (('image', '.gii'),)
 |  
 |  parser = <class 'nibabel.gifti.parse_gifti_fast.GiftiImageParser'>
 |  
 |  valid_exts = ('.gii',)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.xmlutils.XmlSerializable:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
 |      Save image to writable IO stream
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Writable stream
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
 |      Construct image from a byte string
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      bytestring : bytes
 |          Byte string containing the on-disk representation of an image
 |  
 |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
 |      Load image from readable IO stream
 |      
 |      Convert to BytesIO to enable seeking, if input stream is not seekable
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Readable stream
 |  
 |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
 |      Retrieve and load an image from a URL
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      url : str or urllib.request.Request object
 |          URL of file to retrieve
 |      timeout : float, optional
 |          Time (in seconds) to wait for a response
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __getitem__(self, key) -> 'None'
 |      No slicing or dictionary interface for images
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  from_image(img: 'FileBasedImage') -> 'ImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``FileBasedImage`` instance
 |         In fact, an object with the API of ``FileBasedImage``.
 |      
 |      Returns
 |      -------
 |      img : ``FileBasedImage`` instance
 |         Image, of our own class
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  load = from_filename(filename: 'FileSpec') -> 'ImgT' from builtins.type
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header_class = <class 'nibabel.filebasedimages.FileBasedHeader'>
 |      Template class to implement header protocol
 |  
 |  
 |  makeable = True
 |  
 |  rw = True

None
&&&&&&&&&&&&&&&&&&&&&&&&& MGHImage &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class MGHImage in module nibabel.freesurfer.mghformat:

class MGHImage(nibabel.spatialimages.SpatialImage, nibabel.filebasedimages.SerializableImage)
 |  MGHImage(dataobj, affine, header=None, extra=None, file_map=None)
 |  
 |  Class for MGH format image
 |  
 |  Method resolution order:
 |      MGHImage
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.SerializableImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |  
 |  to_file_map(self, file_map=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  filespec_to_file_map(filespec) from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : MGHImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
 |      Class to act as proxy for the array that can be read from a file
 |      
 |      The array proxy allows us to freeze the passed fileobj and header such that
 |      it returns the expected data array.
 |      
 |      This implementation assumes a contiguous array in the file object, with one
 |      of the numpy dtypes, starting at a given file position ``offset`` with
 |      single ``slope`` and ``intercept`` scaling to produce output values.
 |      
 |      The class ``__init__`` requires a spec which defines how the data will be
 |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
 |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
 |      with methods:
 |      
 |      * get_data_shape
 |      * get_data_dtype
 |      * get_data_offset
 |      * get_slope_inter
 |      
 |      A header should also have a 'copy' method.  This requirement will go away
 |      when the deprecated 'header' property goes away.
 |      
 |      This implementation allows us to deal with Analyze and its variants,
 |      including Nifti1, and with the MGH format.
 |      
 |      Other image types might need more specific classes to implement the API.
 |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
 |      examples.
 |  
 |  
 |  __annotations__ = {'header': <class 'nibabel.freesurfer.mghformat.MGHH...
 |  
 |  files_types = (('image', '.mgh'),)
 |  
 |  header_class = <class 'nibabel.freesurfer.mghformat.MGHHeader'>
 |      Class for MGH format header
 |      
 |      The header also consists of the footer data which MGH places after the data
 |      chunk.
 |  
 |  
 |  makeable = True
 |  
 |  rw = True
 |  
 |  valid_exts = ('.mgh', '.mgz')
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |      
 |      Notes
 |      -----
 |      Subclasses should override this if they have additional requirements
 |      when re-orienting an image.
 |  
 |  get_data_dtype(self) -> 'np.dtype'
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
 |  
 |  update_header(self) -> 'None'
 |      Harmonize header with image data and affine
 |      
 |      >>> data = np.zeros((2,3,4))
 |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
 |      >>> img = SpatialImage(data, affine)
 |      >>> img.shape == (2, 3, 4)
 |      True
 |      >>> img.update_header()
 |      >>> img.header.get_data_shape() == (2, 3, 4)
 |      True
 |      >>> img.header.get_zooms()
 |      (1.0, 2.0, 3.0)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  to_bytes(self, **kwargs) -> 'bytes'
 |      Return a ``bytes`` object with the contents of the file that would
 |      be written if the image were saved.
 |      
 |      Parameters
 |      ----------
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |      
 |      Returns
 |      -------
 |      bytes
 |          Serialized image
 |  
 |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
 |      Save image to writable IO stream
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Writable stream
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
 |      Construct image from a byte string
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      bytestring : bytes
 |          Byte string containing the on-disk representation of an image
 |  
 |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
 |      Load image from readable IO stream
 |      
 |      Convert to BytesIO to enable seeking, if input stream is not seekable
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Readable stream
 |  
 |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
 |      Retrieve and load an image from a URL
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      url : str or urllib.request.Request object
 |          URL of file to retrieve
 |      timeout : float, optional
 |          Time (in seconds) to wait for a response
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& Minc1Image &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Minc1Image in module nibabel.minc1:

class Minc1Image(nibabel.spatialimages.SpatialImage)
 |  Minc1Image(dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
 |  
 |  Class for MINC1 format images
 |  
 |  The MINC1 image class uses the default header type, rather than a specific
 |  MINC header type - and reads the relevant information from the MINC file on
 |  load.
 |  
 |  Method resolution order:
 |      Minc1Image
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Class methods defined here:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ImageArrayProxy = <class 'nibabel.minc1.MincImageArrayProxy'>
 |      MINC implementation of array proxy protocol
 |      
 |      The array proxy allows us to freeze the passed fileobj and
 |      header such that it returns the expected data array.
 |  
 |  
 |  __annotations__ = {'_compressed_suffixes': 'tuple[str, ...]', '_meta_s...
 |  
 |  files_types = (('image', '.mnc'),)
 |  
 |  header_class = <class 'nibabel.minc1.Minc1Header'>
 |  
 |  makeable = True
 |  
 |  rw = False
 |  
 |  valid_exts = ('.mnc',)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __init__(self, dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |      
 |      Notes
 |      -----
 |      Subclasses should override this if they have additional requirements
 |      when re-orienting an image.
 |  
 |  get_data_dtype(self) -> 'np.dtype'
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
 |  
 |  update_header(self) -> 'None'
 |      Harmonize header with image data and affine
 |      
 |      >>> data = np.zeros((2,3,4))
 |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
 |      >>> img = SpatialImage(data, affine)
 |      >>> img.shape == (2, 3, 4)
 |      True
 |      >>> img.update_header()
 |      >>> img.header.get_data_shape() == (2, 3, 4)
 |      True
 |      >>> img.header.get_zooms()
 |      (1.0, 2.0, 3.0)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& Minc2Image &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Minc2Image in module nibabel.minc2:

class Minc2Image(nibabel.minc1.Minc1Image)
 |  Minc2Image(dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
 |  
 |  Class for MINC2 images
 |  
 |  The MINC2 image class uses the default header type, rather than a
 |  specific MINC header type - and reads the relevant information from
 |  the MINC file on load.
 |  
 |  Method resolution order:
 |      Minc2Image
 |      nibabel.minc1.Minc1Image
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Class methods defined here:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __annotations__ = {'header': <class 'nibabel.minc2.Minc2Header'>}
 |  
 |  header_class = <class 'nibabel.minc2.Minc2Header'>
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.minc1.Minc1Image:
 |  
 |  ImageArrayProxy = <class 'nibabel.minc1.MincImageArrayProxy'>
 |      MINC implementation of array proxy protocol
 |      
 |      The array proxy allows us to freeze the passed fileobj and
 |      header such that it returns the expected data array.
 |  
 |  
 |  files_types = (('image', '.mnc'),)
 |  
 |  makeable = True
 |  
 |  rw = False
 |  
 |  valid_exts = ('.mnc',)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __init__(self, dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |      
 |      Notes
 |      -----
 |      Subclasses should override this if they have additional requirements
 |      when re-orienting an image.
 |  
 |  get_data_dtype(self) -> 'np.dtype'
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
 |  
 |  update_header(self) -> 'None'
 |      Harmonize header with image data and affine
 |      
 |      >>> data = np.zeros((2,3,4))
 |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
 |      >>> img = SpatialImage(data, affine)
 |      >>> img.shape == (2, 3, 4)
 |      True
 |      >>> img.update_header()
 |      >>> img.header.get_data_shape() == (2, 3, 4)
 |      True
 |      >>> img.header.get_zooms()
 |      (1.0, 2.0, 3.0)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& Nifti1Header &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Nifti1Header in module nibabel.nifti1:

class Nifti1Header(nibabel.spm99analyze.SpmAnalyzeHeader)
 |  Nifti1Header(binaryblock=None, endianness=None, check=True, extensions=())
 |  
 |  Class for NIfTI1 header
 |  
 |  The NIfTI1 header has many more coded fields than the simpler Analyze
 |  variants.  NIfTI1 headers also have extensions.
 |  
 |  Nifti allows the header to be a separate file, as part of a nifti image /
 |  header pair, or to precede the data in a single file.  The object needs to
 |  know which type it is, in order to manage the voxel offset pointing to the
 |  data, extension reading, and writing the correct magic string.
 |  
 |  This class handles the header-preceding-data case.
 |  
 |  Method resolution order:
 |      Nifti1Header
 |      nibabel.spm99analyze.SpmAnalyzeHeader
 |      nibabel.analyze.AnalyzeHeader
 |      nibabel.wrapstruct.LabeledWrapStruct
 |      nibabel.wrapstruct.WrapStruct
 |      nibabel.spatialimages.SpatialHeader
 |      nibabel.filebasedimages.FileBasedHeader
 |      nibabel.spatialimages.SpatialProtocol
 |      typing.Protocol
 |      typing.Generic
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, binaryblock=None, endianness=None, check=True, extensions=())
 |      Initialize header from binary data block and extensions
 |  
 |  __subclasshook__ = _proto_hook(other)
 |      # Set (or override) the protocol subclass hook.
 |  
 |  copy(self)
 |      Return copy of header
 |      
 |      Take reference to extensions as well as copy of header contents
 |  
 |  get_best_affine(self)
 |      Select best of available transforms
 |  
 |  get_data_shape(self)
 |      Get shape of data
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.get_data_shape()
 |      (0,)
 |      >>> hdr.set_data_shape((1,2,3))
 |      >>> hdr.get_data_shape()
 |      (1, 2, 3)
 |      
 |      Expanding number of dimensions gets default zooms
 |      
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0, 1.0)
 |      
 |      Notes
 |      -----
 |      Applies freesurfer hack for large vectors described in `issue 100`_ and
 |      `save_nifti.m <save77_>`_.
 |      
 |      Allows for freesurfer hack for 7th order icosahedron surface described
 |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
 |  
 |  get_dim_info(self)
 |      Gets NIfTI MRI slice etc dimension information
 |      
 |      Returns
 |      -------
 |      freq : {None,0,1,2}
 |         Which data array axis is frequency encode direction
 |      phase : {None,0,1,2}
 |         Which data array axis is phase encode direction
 |      slice : {None,0,1,2}
 |         Which data array axis is slice encode direction
 |      
 |      where ``data array`` is the array returned by ``get_data``
 |      
 |      Because NIfTI1 files are natively Fortran indexed:
 |        0 is fastest changing in file
 |        1 is medium changing in file
 |        2 is slowest changing in file
 |      
 |      ``None`` means the axis appears not to be specified.
 |      
 |      Examples
 |      --------
 |      See set_dim_info function
 |  
 |  get_intent(self, code_repr='label')
 |      Get intent code, parameters and name
 |      
 |      Parameters
 |      ----------
 |      code_repr : string
 |         string giving output form of intent code representation.
 |         Default is 'label'; use 'code' for integer representation.
 |      
 |      Returns
 |      -------
 |      code : string or integer
 |          intent code, or string describing code
 |      parameters : tuple
 |          parameters for the intent
 |      name : string
 |          intent name
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_intent('t test', (10,), name='some score')
 |      >>> hdr.get_intent()
 |      ('t test', (10.0,), 'some score')
 |      >>> hdr.get_intent('code')
 |      (3, (10.0,), 'some score')
 |  
 |  get_n_slices(self)
 |      Return the number of slices
 |  
 |  get_qform(self, coded=False)
 |      Return 4x4 affine matrix from qform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and qform code.  If False, just
 |          return affine.  {affine or None} means, return None if qform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine reconstructed from qform
 |          quaternion.  If `coded` is True, return None if qform code is 0,
 |          else return the affine.
 |      code : int
 |          Qform code. Only returned if `coded` is True.
 |  
 |  get_qform_quaternion(self)
 |      Compute quaternion from b, c, d of quaternion
 |      
 |      Fills a value by assuming this is a unit quaternion
 |  
 |  get_sform(self, coded=False)
 |      Return 4x4 affine matrix from sform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and sform code.  If False, just
 |          return affine.  {affine or None} means, return None if sform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine from sform fields. If
 |          `coded` is True, return None if sform code is 0, else return the
 |          affine.
 |      code : int
 |          Sform code. Only returned if `coded` is True.
 |  
 |  get_slice_duration(self)
 |      Get slice duration
 |      
 |      Returns
 |      -------
 |      slice_duration : float
 |          time to acquire one slice
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_dim_info(slice=2)
 |      >>> hdr.set_slice_duration(0.3)
 |      >>> print("%0.1f" % hdr.get_slice_duration())
 |      0.3
 |      
 |      Notes
 |      -----
 |      The NIfTI1 spec appears to require the slice dimension to be
 |      defined for slice_duration to have meaning.
 |  
 |  get_slice_times(self)
 |      Get slice times from slice timing information
 |      
 |      Returns
 |      -------
 |      slice_times : tuple
 |          Times of acquisition of slices, where 0 is the beginning of
 |          the acquisition, ordered by position in file.  nifti allows
 |          slices at the top and bottom of the volume to be excluded from
 |          the standard slice timing specification, and calls these
 |          "padding slices".  We give padding slices ``None`` as a time
 |          of acquisition
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_dim_info(slice=2)
 |      >>> hdr.set_data_shape((1, 1, 7))
 |      >>> hdr.set_slice_duration(0.1)
 |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
 |      >>> slice_times = hdr.get_slice_times()
 |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
 |      True
 |  
 |  get_slope_inter(self)
 |      Get data scaling (slope) and DC offset (intercept) from header data
 |      
 |      Returns
 |      -------
 |      slope : None or float
 |         scaling (slope).  None if there is no valid scaling from these
 |         fields
 |      inter : None or float
 |         offset (intercept). None if there is no valid scaling or if offset
 |         is not finite.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.get_slope_inter()
 |      (1.0, 0.0)
 |      >>> hdr['scl_slope'] = 0
 |      >>> hdr.get_slope_inter()
 |      (None, None)
 |      >>> hdr['scl_slope'] = np.nan
 |      >>> hdr.get_slope_inter()
 |      (None, None)
 |      >>> hdr['scl_slope'] = 1
 |      >>> hdr['scl_inter'] = 1
 |      >>> hdr.get_slope_inter()
 |      (1.0, 1.0)
 |      >>> hdr['scl_inter'] = np.inf
 |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |          ...
 |      HeaderDataError: Valid slope but invalid intercept inf
 |  
 |  get_xyzt_units(self)
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code or dtype or type
 |      
 |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
 |      will be interpreted as ``np.int64``, which is almost never desired.
 |      ``np.int64`` is permitted for those intent on making poor choices.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_data_dtype(np.uint8)
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype('implausible')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
 |      >>> hdr.set_data_dtype('none')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
 |      >>> hdr.set_data_dtype(np.void)
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
 |      but not supported
 |      >>> hdr.set_data_dtype('int')
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
 |      >>> hdr.set_data_dtype(int)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
 |      numpy.int16.
 |      >>> hdr.set_data_dtype('int64')
 |      >>> hdr.get_data_dtype() == np.dtype('int64')
 |      True
 |  
 |  set_data_shape(self, shape)
 |      Set shape of data  # noqa
 |      
 |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
 |      ``ndims`` to 1.0
 |      
 |      Nifti1 images can have up to seven dimensions. For FreeSurfer-variant
 |      Nifti surface files, the first dimension is assumed to correspond to
 |      vertices/nodes on a surface, and dimensions two and three are
 |      constrained to have depth of 1. Dimensions 4-7 are constrained only by
 |      type bounds.
 |      
 |      Parameters
 |      ----------
 |      shape : sequence
 |         sequence of integers specifying data array shape
 |      
 |      Notes
 |      -----
 |      Applies freesurfer hack for large vectors described in `issue 100`_ and
 |      `save_nifti.m <save77_>`_.
 |      
 |      Allows for freesurfer hack for 7th order icosahedron surface described
 |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
 |      
 |      The Nifti1 `standard header`_ allows for the following "point set"
 |      definition of a surface, not currently implemented in nibabel.
 |      
 |      ::
 |      
 |        To signify that the vector value at each voxel is really a
 |        spatial coordinate (e.g., the vertices or nodes of a surface mesh):
 |          - dataset must have a 5th dimension
 |          - intent_code must be NIFTI_INTENT_POINTSET
 |          - dim[0] = 5
 |          - dim[1] = number of points
 |          - dim[2] = dim[3] = dim[4] = 1
 |          - dim[5] must be the dimensionality of space (e.g., 3 => 3D space).
 |          - intent_name may describe the object these points come from
 |            (e.g., "pial", "gray/white" , "EEG", "MEG").
 |      
 |      .. _issue 100: https://github.com/nipy/nibabel/issues/100
 |      .. _issue 309: https://github.com/nipy/nibabel/issues/309
 |      .. _save77:
 |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82
 |      .. _save50:
 |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56
 |      .. _load_nifti.m:
 |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89
 |      .. _standard header: http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
 |  
 |  set_dim_info(self, freq=None, phase=None, slice=None)
 |      Sets nifti MRI slice etc dimension information
 |      
 |      Parameters
 |      ----------
 |      freq : {None, 0, 1, 2}
 |          axis of data array referring to frequency encoding
 |      phase : {None, 0, 1, 2}
 |          axis of data array referring to phase encoding
 |      slice : {None, 0, 1, 2}
 |          axis of data array referring to slice encoding
 |      
 |      ``None`` means the axis is not specified.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_dim_info(1, 2, 0)
 |      >>> hdr.get_dim_info()
 |      (1, 2, 0)
 |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
 |      >>> hdr.get_dim_info()
 |      (1, 2, 0)
 |      >>> hdr.set_dim_info()
 |      >>> hdr.get_dim_info()
 |      (None, None, None)
 |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
 |      >>> hdr.get_dim_info()
 |      (1, None, 0)
 |      
 |      Notes
 |      -----
 |      This is stored in one byte in the header
 |  
 |  set_intent(self, code, params=(), name='', allow_unknown=False)
 |      Set the intent code, parameters and name
 |      
 |      If parameters are not specified, assumed to be all zero. Each
 |      intent code has a set number of parameters associated. If you
 |      specify any parameters, then it will need to be the correct number
 |      (e.g the "f test" intent requires 2).  However, parameters can
 |      also be set in the file data, so we also allow not setting any
 |      parameters (empty parameter tuple).
 |      
 |      Parameters
 |      ----------
 |      code : integer or string
 |          code specifying nifti intent
 |      params : list, tuple of scalars
 |          parameters relating to intent (see intent_codes)
 |          defaults to ().  Unspecified parameters are set to 0.0
 |      name : string
 |          intent name (description). Defaults to ''
 |      allow_unknown : {False, True}, optional
 |          Allow unknown integer intent codes. If False (the default),
 |          a KeyError is raised on attempts to set the intent
 |          to an unknown code.
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_intent(0)  # no intent
 |      >>> hdr.set_intent('z score')
 |      >>> hdr.get_intent()
 |      ('z score', (), '')
 |      >>> hdr.get_intent('code')
 |      (5, (), '')
 |      >>> hdr.set_intent('t test', (10,), name='some score')
 |      >>> hdr.get_intent()
 |      ('t test', (10.0,), 'some score')
 |      >>> hdr.set_intent('f test', (2, 10), name='another score')
 |      >>> hdr.get_intent()
 |      ('f test', (2.0, 10.0), 'another score')
 |      >>> hdr.set_intent('f test')
 |      >>> hdr.get_intent()
 |      ('f test', (0.0, 0.0), '')
 |      >>> hdr.set_intent(9999, allow_unknown=True) # unknown code
 |      >>> hdr.get_intent()
 |      ('unknown code 9999', (), '')
 |  
 |  set_qform(self, affine, code=None, strip_shears=True)
 |      Set qform header values from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform. If None, only set code.
 |      code : None, string or integer, optional
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing qform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing qform code in header != 0,
 |            `code`-> existing qform code in header
 |      
 |      strip_shears : bool, optional
 |          Whether to strip shears in `affine`.  If True, shears will be
 |          silently stripped. If False, the presence of shears will raise a
 |          ``HeaderDataError``
 |      
 |      Notes
 |      -----
 |      The qform transform only encodes translations, rotations and
 |      zooms. If there are shear components to the `affine` transform, and
 |      `strip_shears` is True (the default), the written qform gives the
 |      closest approximation where the rotation matrix is orthogonal. This is
 |      to allow quaternion representation. The orthogonal representation
 |      enforces orthogonal axes.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> int(hdr['qform_code'])  # gives 0 - unknown
 |      0
 |      >>> affine = np.diag([1,2,3,1])
 |      >>> np.all(hdr.get_qform() == affine)
 |      False
 |      >>> hdr.set_qform(affine)
 |      >>> np.all(hdr.get_qform() == affine)
 |      True
 |      >>> int(hdr['qform_code'])  # gives 2 - aligned
 |      2
 |      >>> hdr.set_qform(affine, code='talairach')
 |      >>> int(hdr['qform_code'])
 |      3
 |      >>> hdr.set_qform(affine, code=None)
 |      >>> int(hdr['qform_code'])
 |      3
 |      >>> hdr.set_qform(affine, code='scanner')
 |      >>> int(hdr['qform_code'])
 |      1
 |      >>> hdr.set_qform(None)
 |      >>> int(hdr['qform_code'])
 |      0
 |  
 |  set_sform(self, affine, code=None)
 |      Set sform transform from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform.  If None, only set `code`
 |      code : None, string or integer, optional
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing sform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing sform code in header != 0,
 |            `code`-> existing sform code in header
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> int(hdr['sform_code'])  # gives 0 - unknown
 |      0
 |      >>> affine = np.diag([1,2,3,1])
 |      >>> np.all(hdr.get_sform() == affine)
 |      False
 |      >>> hdr.set_sform(affine)
 |      >>> np.all(hdr.get_sform() == affine)
 |      True
 |      >>> int(hdr['sform_code'])  # gives 2 - aligned
 |      2
 |      >>> hdr.set_sform(affine, code='talairach')
 |      >>> int(hdr['sform_code'])
 |      3
 |      >>> hdr.set_sform(affine, code=None)
 |      >>> int(hdr['sform_code'])
 |      3
 |      >>> hdr.set_sform(affine, code='scanner')
 |      >>> int(hdr['sform_code'])
 |      1
 |      >>> hdr.set_sform(None)
 |      >>> int(hdr['sform_code'])
 |      0
 |  
 |  set_slice_duration(self, duration)
 |      Set slice duration
 |      
 |      Parameters
 |      ----------
 |      duration : scalar
 |          time to acquire one slice
 |      
 |      Examples
 |      --------
 |      See ``get_slice_duration``
 |  
 |  set_slice_times(self, slice_times)
 |      Set slice times into *hdr*
 |      
 |      Parameters
 |      ----------
 |      slice_times : tuple
 |          tuple of slice times, one value per slice
 |          tuple can include None to indicate no slice time for that slice
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_dim_info(slice=2)
 |      >>> hdr.set_data_shape([1, 1, 7])
 |      >>> hdr.set_slice_duration(0.1)
 |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
 |      >>> hdr.set_slice_times(times)
 |      >>> hdr.get_value_label('slice_code')
 |      'alternating decreasing'
 |      >>> int(hdr['slice_start'])
 |      1
 |      >>> int(hdr['slice_end'])
 |      5
 |  
 |  set_slope_inter(self, slope, inter=None)
 |      Set slope and / or intercept into header
 |      
 |      Set slope and intercept for image data, such that, if the image
 |      data is ``arr``, then the scaled image data will be ``(arr *
 |      slope) + inter``
 |      
 |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
 |      set `slope`, `inter` automatically on write.
 |      
 |      Parameters
 |      ----------
 |      slope : None or float
 |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
 |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
 |         HeaderDataError
 |      inter : None or float, optional
 |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
 |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
 |         HeaderDataError
 |  
 |  set_xyzt_units(self, xyz=None, t=None)
 |  
 |  write_to(self, fileobj)
 |      Write structure to fileobj
 |      
 |      Write starts at fileobj current file position.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Should implement ``write`` method
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> wstr.write_to(str_io)
 |      >>> wstr.binaryblock == str_io.getvalue()
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  default_structarr(endianness=None) from typing._ProtocolMeta
 |      Create empty header binary block with given endianness
 |  
 |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
 |      Return read structure with given or guessed endiancode
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Needs to implement ``read`` method
 |      endianness : None or endian code, optional
 |         Code specifying endianness of read data
 |      
 |      Returns
 |      -------
 |      wstr : WrapStruct object
 |         WrapStruct object initialized from data in fileobj
 |  
 |  from_header(header=None, check=True) from typing._ProtocolMeta
 |      Class method to create header from another header
 |      
 |      Extend Analyze header copy by copying extensions from other Nifti
 |      types.
 |      
 |      Parameters
 |      ----------
 |      header : ``Header`` instance or mapping
 |         a header of this class, or another class of header for
 |         conversion to this type
 |      check : {True, False}
 |         whether to check header for integrity
 |      
 |      Returns
 |      -------
 |      hdr : header instance
 |         fresh header instance of our own class
 |  
 |  may_contain_header(binaryblock) from typing._ProtocolMeta
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __abstractmethods__ = frozenset()
 |  
 |  __parameters__ = ()
 |  
 |  exts_klass = <class 'nibabel.nifti1.Nifti1Extensions'>
 |      Simple extension collection, implemented as a list-subclass.
 |  
 |  
 |  has_data_intercept = True
 |  
 |  has_data_slope = True
 |  
 |  is_single = True
 |  
 |  pair_magic = b'ni1'
 |  
 |  pair_vox_offset = 0
 |  
 |  quaternion_threshold = 3.5762786865234375e-07
 |  
 |  single_magic = b'n+1'
 |  
 |  single_vox_offset = 352
 |  
 |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  as_analyze_map(self)
 |      Return header as mapping for conversion to Analyze types
 |      
 |      Collect data from custom header type to fill in fields for Analyze and
 |      derived header types (such as Nifti1 and Nifti2).
 |      
 |      When Analyze types convert another header type to their own type, they
 |      call this this method to check if there are other Analyze / Nifti
 |      fields that the source header would like to set.
 |      
 |      Returns
 |      -------
 |      analyze_map : mapping
 |          Object that can be used as a mapping thus::
 |      
 |              for key in analyze_map:
 |                  value = analyze_map[key]
 |      
 |          where ``key`` is the name of a field that can be set in an Analyze
 |          header type, such as Nifti1, and ``value`` is a value for the
 |          field.  For example, `analyze_map` might be a something like
 |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
 |          field present in both Analyze and Nifti1, and ``slice_duration`` is
 |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
 |          header type does not recognize the field name, it will throw away
 |          the value without error.  See :meth:`Analyze.from_header`.
 |      
 |      Notes
 |      -----
 |      You can also return a Nifti header with the relevant fields set.
 |      
 |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
 |      and ``get_zooms``, for the conversion, and these get called *after*
 |      using the analyze map, so the methods will override values set in the
 |      map.
 |  
 |  data_from_fileobj(self, fileobj)
 |      Read scaled data array from `fileobj`
 |      
 |      Use this routine to get the scaled image data from an image file
 |      `fileobj`, given a header `self`.  "Scaled" means, with any header
 |      scaling factors applied to the raw data in the file.  Use
 |      `raw_data_from_fileobj` to get the raw data.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         scaled data array
 |      
 |      Notes
 |      -----
 |      We use the header to get any scale or intercept values to apply to the
 |      data.  Raw Analyze files don't have scale factors or intercepts, but
 |      this routine also works with formats based on Analyze, that do have
 |      scaling, such as SPM analyze formats and NIfTI.
 |  
 |  data_to_fileobj(self, data, fileobj, rescale=True)
 |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
 |      
 |      In writing the data, we match the header to the written data, by
 |      setting the header scaling factors, iff `rescale` is True.  Thus we
 |      modify `self` in the process of writing the data.
 |      
 |      Parameters
 |      ----------
 |      data : array-like
 |         data to write; should match header defined shape
 |      fileobj : file-like object
 |         Object with file interface, implementing ``write`` and
 |         ``seek``
 |      rescale : {True, False}, optional
 |          Whether to try and rescale data to match output dtype specified by
 |          header. If True and scaling needed and header cannot scale, then
 |          raise ``HeaderTypeError``.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.analyze import AnalyzeHeader
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((1, 2, 3))
 |      >>> hdr.set_data_dtype(np.float64)
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> data = np.arange(6).reshape(1,2,3)
 |      >>> hdr.data_to_fileobj(data, str_io)
 |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
 |      True
 |  
 |  get_base_affine(self)
 |      Get affine from basic (shared) header fields
 |      
 |      Note that we get the translations from the center of the
 |      image.
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3, 2, 1))
 |      >>> hdr.default_x_flip
 |      True
 |      >>> hdr.get_base_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  get_data_dtype(self)
 |      Get numpy dtype for data
 |      
 |      For examples see ``set_data_dtype``
 |  
 |  get_data_offset(self)
 |      Return offset into data file to read data
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_data_offset()
 |      0
 |      >>> hdr['vox_offset'] = 12
 |      >>> hdr.get_data_offset()
 |      12
 |  
 |  get_zooms(self)
 |      Get zooms from header
 |      
 |      Returns
 |      -------
 |      z : tuple
 |         tuple of header zoom values
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_zooms()
 |      (1.0,)
 |      >>> hdr.set_data_shape((1,2))
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0)
 |      >>> hdr.set_zooms((3, 4))
 |      >>> hdr.get_zooms()
 |      (3.0, 4.0)
 |  
 |  raw_data_from_fileobj(self, fileobj)
 |      Read unscaled data array from `fileobj`
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         unscaled data array
 |  
 |  set_data_offset(self, offset)
 |      Set offset into data file to read data
 |  
 |  set_zooms(self, zooms)
 |      Set zooms into header fields
 |      
 |      See docstring for ``get_zooms`` for examples
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  guessed_endian(hdr) from typing._ProtocolMeta
 |      Guess intended endianness from mapping-like ``hdr``
 |      
 |      Parameters
 |      ----------
 |      hdr : mapping-like
 |         hdr for which to guess endianness
 |      
 |      Returns
 |      -------
 |      endianness : {'<', '>'}
 |         Guessed endianness of header
 |      
 |      Examples
 |      --------
 |      Zeros header, no information, guess native
 |      
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr_data = np.zeros((), dtype=header_dtype)
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      A valid native header is guessed native
 |      
 |      >>> hdr_data = hdr.structarr.copy()
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      And, when swapped, is guessed as swapped
 |      
 |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
 |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
 |      True
 |      
 |      The algorithm is as follows:
 |      
 |      First, look at the first value in the ``dim`` field; this
 |      should be between 0 and 7.  If it is between 1 and 7, then
 |      this must be a native endian header.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = 6
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      
 |      If the first ``dim`` value is zeros, we need a tie breaker.
 |      In that case we check the ``sizeof_hdr`` field.  This should
 |      be 348.  If it looks like the byteswapped value of 348,
 |      assumed swapped.  Otherwise assume native.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      This is overridden by the ``dim[0]`` value though:
 |      
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  default_x_flip = True
 |  
 |  sizeof_hdr = 348
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __str__(self)
 |      Return string representation for printing
 |  
 |  get_value_label(self, fieldname)
 |      Returns label for coded field
 |      
 |      A coded field is an int field containing codes that stand for
 |      discrete values that also have string labels.
 |      
 |      Parameters
 |      ----------
 |      fieldname : str
 |         name of header field to get label for
 |      
 |      Returns
 |      -------
 |      label : str
 |         label for code value in header field `fieldname`
 |      
 |      Raises
 |      ------
 |      ValueError
 |          if field is not coded.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.volumeutils import Recoder
 |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
 |      >>> class C(LabeledWrapStruct):
 |      ...     template_dtype = np.dtype([('datatype', 'i2')])
 |      ...     _field_recoders = dict(datatype = recoder)
 |      >>> hdr  = C()
 |      >>> hdr.get_value_label('datatype')
 |      '<unknown code 0>'
 |      >>> hdr['datatype'] = 2
 |      >>> hdr.get_value_label('datatype')
 |      'two'
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __eq__(self, other)
 |      equality between two structures defined by binaryblock
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr2 = WrapStruct()
 |      >>> wstr == wstr2
 |      True
 |      >>> wstr3 = WrapStruct(endianness=swapped_code)
 |      >>> wstr == wstr3
 |      True
 |  
 |  __getitem__(self, item)
 |      Return values from structure data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] == 0
 |      True
 |  
 |  __iter__(self)
 |  
 |  __ne__(self, other)
 |      Return self!=value.
 |  
 |  __setitem__(self, item, value)
 |      Set values in structured data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] = 3
 |      >>> wstr['integer']
 |      array(3, dtype=int16)
 |  
 |  as_byteswapped(self, endianness=None)
 |      return new byteswapped object with given ``endianness``
 |      
 |      Guaranteed to make a copy even if endianness is the same as
 |      the current endianness.
 |      
 |      Parameters
 |      ----------
 |      endianness : None or string, optional
 |         endian code to which to swap.  None means swap from current
 |         endianness, and is the default
 |      
 |      Returns
 |      -------
 |      wstr : ``WrapStruct``
 |         ``WrapStruct`` object with given endianness
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr.endianness == native_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped()
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr is wstr
 |      False
 |      >>> bs_wstr == wstr
 |      True
 |      
 |      If you write to the resulting byteswapped data, it does not
 |      change the original.
 |      
 |      >>> bs_wstr['integer'] = 3
 |      >>> bs_wstr == wstr
 |      False
 |      
 |      If you swap to the same endianness, it returns a copy
 |      
 |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
 |      >>> nbs_wstr.endianness == native_code
 |      True
 |      >>> nbs_wstr is wstr
 |      False
 |  
 |  check_fix(self, logger=None, error_level=None)
 |      Check structured data with checks
 |      
 |      Parameters
 |      ----------
 |      logger : None or logging.Logger
 |      error_level : None or int
 |          Level of error severity at which to raise error.  Any error of
 |          severity >= `error_level` will cause an exception.
 |  
 |  get(self, k, d=None)
 |      Return value for the key k if present or d otherwise
 |  
 |  items(self)
 |      Return items from structured data
 |  
 |  keys(self)
 |      Return keys from structured data
 |  
 |  values(self)
 |      Return values from structured data
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
 |      Run checks over binary data, return string
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  binaryblock
 |      binary block of data as string
 |      
 |      Returns
 |      -------
 |      binaryblock : string
 |          string giving binary data block
 |      
 |      Examples
 |      --------
 |      >>> # Make default empty structure
 |      >>> wstr = WrapStruct()
 |      >>> len(wstr.binaryblock)
 |      2
 |  
 |  endianness
 |      endian code of binary data
 |      
 |      The endianness code gives the current byte order
 |      interpretation of the binary data.
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> code = wstr.endianness
 |      >>> code == native_code
 |      True
 |      
 |      Notes
 |      -----
 |      Endianness gives endian interpretation of binary data. It is
 |      read only because the only common use case is to set the
 |      endianness on initialization, or occasionally byteswapping the
 |      data - but this is done via the as_byteswapped method
 |  
 |  structarr
 |      Structured data, with data fields
 |      
 |      Examples
 |      --------
 |      >>> wstr1 = WrapStruct() # with default data
 |      >>> an_int = wstr1.structarr['integer']
 |      >>> wstr1.structarr = None
 |      Traceback (most recent call last):
 |         ...
 |      AttributeError: ...
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
 |  
 |  data_layout = 'F'
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Protocol:
 |  
 |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
 |      This method is called when a class is subclassed.
 |      
 |      The default implementation does nothing. It may be
 |      overridden to extend subclasses.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Generic:
 |  
 |  __class_getitem__(params) from typing._ProtocolMeta

None
&&&&&&&&&&&&&&&&&&&&&&&&& Nifti1Image &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Nifti1Image in module nibabel.nifti1:

class Nifti1Image(Nifti1Pair, nibabel.filebasedimages.SerializableImage)
 |  Nifti1Image(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |  
 |  Class for single file NIfTI1 format image
 |  
 |  Method resolution order:
 |      Nifti1Image
 |      Nifti1Pair
 |      nibabel.analyze.AnalyzeImage
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.SerializableImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  update_header(self)
 |      Harmonize header with image data and affine
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  files_types = (('image', '.nii'),)
 |  
 |  header_class = <class 'nibabel.nifti1.Nifti1Header'>
 |      Class for NIfTI1 header
 |      
 |      The NIfTI1 header has many more coded fields than the simpler Analyze
 |      variants.  NIfTI1 headers also have extensions.
 |      
 |      Nifti allows the header to be a separate file, as part of a nifti image /
 |      header pair, or to precede the data in a single file.  The object needs to
 |      know which type it is, in order to manage the voxel offset pointing to the
 |      data, extension reading, and writing the correct magic string.
 |      
 |      This class handles the header-preceding-data case.
 |  
 |  
 |  valid_exts = ('.nii',)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from Nifti1Pair:
 |  
 |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |      
 |      Notes
 |      -----
 |      
 |      If both a `header` and an `affine` are specified, and the `affine` does
 |      not match the affine that is in the `header`, the `affine` will be used,
 |      but the ``sform_code`` and ``qform_code`` fields in the header will be
 |      re-initialised to their default values. This is performed on the basis
 |      that, if you are changing the affine, you are likely to be changing the
 |      space to which the affine is pointing.  The :meth:`set_sform` and
 |      :meth:`set_qform` methods can be used to update the codes after an image
 |      has been created - see those methods, and the :ref:`manual
 |      <default-sform-qform-codes>` for more details.
 |  
 |  as_reoriented(self, ornt)
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |  
 |  get_data_dtype(self, finalize=False)
 |      Get numpy dtype for data
 |      
 |      If ``set_data_dtype()`` has been called with an alias
 |      and ``finalize`` is ``False``, return the alias.
 |      If ``finalize`` is ``True``, determine the appropriate dtype
 |      from the image data object and set the final dtype in the
 |      header before returning it.
 |  
 |  get_qform(self, coded=False)
 |      Return 4x4 affine matrix from qform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and qform code.  If False, just
 |          return affine.  {affine or None} means, return None if qform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine reconstructed from qform
 |          quaternion.  If `coded` is True, return None if qform code is 0,
 |          else return the affine.
 |      code : int
 |          Qform code. Only returned if `coded` is True.
 |      
 |      See also
 |      --------
 |      set_qform
 |      get_sform
 |  
 |  get_sform(self, coded=False)
 |      Return 4x4 affine matrix from sform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and sform code.  If False, just
 |          return affine.  {affine or None} means, return None if sform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine from sform fields. If
 |          `coded` is True, return None if sform code is 0, else return the
 |          affine.
 |      code : int
 |          Sform code. Only returned if `coded` is True.
 |      
 |      See also
 |      --------
 |      set_sform
 |      get_qform
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code, dtype, type or alias
 |      
 |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
 |      will be interpreted as ``np.int64``, which is almost never desired.
 |      ``np.int64`` is permitted for those intent on making poor choices.
 |      
 |      The following aliases are defined to allow for flexible specification:
 |      
 |        * ``'mask'`` - Alias for ``uint8``
 |        * ``'compat'`` - The nearest Analyze-compatible datatype
 |          (``uint8``, ``int16``, ``int32``, ``float32``)
 |        * ``'smallest'`` - The smallest Analyze-compatible integer
 |          (``uint8``, ``int16``, ``int32``)
 |      
 |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
 |      with a ``finalize=True`` flag. Until then, these aliases are not
 |      written to the header and will not persist to new images.
 |      
 |      Examples
 |      --------
 |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
 |      
 |      >>> img = Nifti1Image(ints, np.eye(4))
 |      >>> img.set_data_dtype(np.uint8)
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      >>> img.set_data_dtype('mask')
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      >>> img.set_data_dtype('compat')
 |      >>> img.get_data_dtype()
 |      'compat'
 |      >>> img.get_data_dtype(finalize=True)
 |      dtype('<i4')
 |      >>> img.get_data_dtype()
 |      dtype('<i4')
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.get_data_dtype()
 |      'smallest'
 |      >>> img.get_data_dtype(finalize=True)
 |      dtype('uint8')
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      
 |      Note that floating point values will not be coerced to ``int``
 |      
 |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> img = Nifti1Image(floats, np.eye(4))
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.get_data_dtype(finalize=True)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Cannot automatically cast array (of type float32) to an integer
 |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
 |      
 |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
 |      >>> img = Nifti1Image(arr, np.eye(4))
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.set_data_dtype('implausible')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
 |      >>> img.set_data_dtype('none')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
 |      >>> img.set_data_dtype(np.void)
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
 |      but not supported
 |      >>> img.set_data_dtype('int')
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
 |      >>> img.set_data_dtype(int)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
 |      numpy.int16.
 |      >>> img.set_data_dtype('int64')
 |      >>> img.get_data_dtype() == np.dtype('int64')
 |      True
 |  
 |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
 |      Set qform header values from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform. If None, only set code.
 |      code : None, string or integer
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing qform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing qform code in header != 0,
 |            `code`-> existing qform code in header
 |      
 |      strip_shears : bool, optional
 |          Whether to strip shears in `affine`.  If True, shears will be
 |          silently stripped. If False, the presence of shears will raise a
 |          ``HeaderDataError``
 |      update_affine : bool, optional
 |          Whether to update the image affine from the header best affine
 |          after setting the qform. Must be keyword argument (because of
 |          different position in `set_qform`). Default is True
 |      
 |      See also
 |      --------
 |      get_qform
 |      set_sform
 |      
 |      Examples
 |      --------
 |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> aff = np.diag([2, 3, 4, 1])
 |      >>> img = Nifti1Pair(data, aff)
 |      >>> img.get_qform()
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> img.get_qform(coded=True)
 |      (None, 0)
 |      >>> aff2 = np.diag([3, 4, 5, 1])
 |      >>> img.set_qform(aff2, 'talairach')
 |      >>> qaff, code = img.get_qform(coded=True)
 |      >>> np.all(qaff == aff2)
 |      True
 |      >>> int(code)
 |      3
 |  
 |  set_sform(self, affine, code=None, **kwargs)
 |      Set sform transform from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform.  If None, only set `code`
 |      code : None, string or integer
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing sform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing sform code in header != 0,
 |            `code`-> existing sform code in header
 |      
 |      update_affine : bool, optional
 |          Whether to update the image affine from the header best affine
 |          after setting the qform.  Must be keyword argument (because of
 |          different position in `set_qform`). Default is True
 |      
 |      See also
 |      --------
 |      get_sform
 |      set_qform
 |      
 |      Examples
 |      --------
 |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> aff = np.diag([2, 3, 4, 1])
 |      >>> img = Nifti1Pair(data, aff)
 |      >>> img.get_sform()
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> saff, code = img.get_sform(coded=True)
 |      >>> saff
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> int(code)
 |      2
 |      >>> aff2 = np.diag([3, 4, 5, 1])
 |      >>> img.set_sform(aff2, 'talairach')
 |      >>> saff, code = img.get_sform(coded=True)
 |      >>> np.all(saff == aff2)
 |      True
 |      >>> int(code)
 |      3
 |  
 |  to_file_map(self, file_map=None, dtype=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead
 |      dtype : dtype-like, optional
 |         The on-disk data type to coerce the data array.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from Nifti1Pair:
 |  
 |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
 |  
 |  rw = True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : AnalyzeImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
 |      Class to act as proxy for the array that can be read from a file
 |      
 |      The array proxy allows us to freeze the passed fileobj and header such that
 |      it returns the expected data array.
 |      
 |      This implementation assumes a contiguous array in the file object, with one
 |      of the numpy dtypes, starting at a given file position ``offset`` with
 |      single ``slope`` and ``intercept`` scaling to produce output values.
 |      
 |      The class ``__init__`` requires a spec which defines how the data will be
 |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
 |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
 |      with methods:
 |      
 |      * get_data_shape
 |      * get_data_dtype
 |      * get_data_offset
 |      * get_slope_inter
 |      
 |      A header should also have a 'copy' method.  This requirement will go away
 |      when the deprecated 'header' property goes away.
 |      
 |      This implementation allows us to deal with Analyze and its variants,
 |      including Nifti1, and with the MGH format.
 |      
 |      Other image types might need more specific classes to implement the API.
 |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
 |      examples.
 |  
 |  
 |  makeable = True
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  to_bytes(self, **kwargs) -> 'bytes'
 |      Return a ``bytes`` object with the contents of the file that would
 |      be written if the image were saved.
 |      
 |      Parameters
 |      ----------
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |      
 |      Returns
 |      -------
 |      bytes
 |          Serialized image
 |  
 |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
 |      Save image to writable IO stream
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Writable stream
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
 |      Construct image from a byte string
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      bytestring : bytes
 |          Byte string containing the on-disk representation of an image
 |  
 |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
 |      Load image from readable IO stream
 |      
 |      Convert to BytesIO to enable seeking, if input stream is not seekable
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Readable stream
 |  
 |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
 |      Retrieve and load an image from a URL
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      url : str or urllib.request.Request object
 |          URL of file to retrieve
 |      timeout : float, optional
 |          Time (in seconds) to wait for a response
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& Nifti1Pair &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Nifti1Pair in module nibabel.nifti1:

class Nifti1Pair(nibabel.analyze.AnalyzeImage)
 |  Nifti1Pair(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |  
 |  Class for NIfTI1 format image, header pair
 |  
 |  Method resolution order:
 |      Nifti1Pair
 |      nibabel.analyze.AnalyzeImage
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |      
 |      Notes
 |      -----
 |      
 |      If both a `header` and an `affine` are specified, and the `affine` does
 |      not match the affine that is in the `header`, the `affine` will be used,
 |      but the ``sform_code`` and ``qform_code`` fields in the header will be
 |      re-initialised to their default values. This is performed on the basis
 |      that, if you are changing the affine, you are likely to be changing the
 |      space to which the affine is pointing.  The :meth:`set_sform` and
 |      :meth:`set_qform` methods can be used to update the codes after an image
 |      has been created - see those methods, and the :ref:`manual
 |      <default-sform-qform-codes>` for more details.
 |  
 |  as_reoriented(self, ornt)
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |  
 |  get_data_dtype(self, finalize=False)
 |      Get numpy dtype for data
 |      
 |      If ``set_data_dtype()`` has been called with an alias
 |      and ``finalize`` is ``False``, return the alias.
 |      If ``finalize`` is ``True``, determine the appropriate dtype
 |      from the image data object and set the final dtype in the
 |      header before returning it.
 |  
 |  get_qform(self, coded=False)
 |      Return 4x4 affine matrix from qform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and qform code.  If False, just
 |          return affine.  {affine or None} means, return None if qform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine reconstructed from qform
 |          quaternion.  If `coded` is True, return None if qform code is 0,
 |          else return the affine.
 |      code : int
 |          Qform code. Only returned if `coded` is True.
 |      
 |      See also
 |      --------
 |      set_qform
 |      get_sform
 |  
 |  get_sform(self, coded=False)
 |      Return 4x4 affine matrix from sform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and sform code.  If False, just
 |          return affine.  {affine or None} means, return None if sform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine from sform fields. If
 |          `coded` is True, return None if sform code is 0, else return the
 |          affine.
 |      code : int
 |          Sform code. Only returned if `coded` is True.
 |      
 |      See also
 |      --------
 |      set_sform
 |      get_qform
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code, dtype, type or alias
 |      
 |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
 |      will be interpreted as ``np.int64``, which is almost never desired.
 |      ``np.int64`` is permitted for those intent on making poor choices.
 |      
 |      The following aliases are defined to allow for flexible specification:
 |      
 |        * ``'mask'`` - Alias for ``uint8``
 |        * ``'compat'`` - The nearest Analyze-compatible datatype
 |          (``uint8``, ``int16``, ``int32``, ``float32``)
 |        * ``'smallest'`` - The smallest Analyze-compatible integer
 |          (``uint8``, ``int16``, ``int32``)
 |      
 |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
 |      with a ``finalize=True`` flag. Until then, these aliases are not
 |      written to the header and will not persist to new images.
 |      
 |      Examples
 |      --------
 |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
 |      
 |      >>> img = Nifti1Image(ints, np.eye(4))
 |      >>> img.set_data_dtype(np.uint8)
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      >>> img.set_data_dtype('mask')
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      >>> img.set_data_dtype('compat')
 |      >>> img.get_data_dtype()
 |      'compat'
 |      >>> img.get_data_dtype(finalize=True)
 |      dtype('<i4')
 |      >>> img.get_data_dtype()
 |      dtype('<i4')
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.get_data_dtype()
 |      'smallest'
 |      >>> img.get_data_dtype(finalize=True)
 |      dtype('uint8')
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      
 |      Note that floating point values will not be coerced to ``int``
 |      
 |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> img = Nifti1Image(floats, np.eye(4))
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.get_data_dtype(finalize=True)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Cannot automatically cast array (of type float32) to an integer
 |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
 |      
 |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
 |      >>> img = Nifti1Image(arr, np.eye(4))
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.set_data_dtype('implausible')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
 |      >>> img.set_data_dtype('none')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
 |      >>> img.set_data_dtype(np.void)
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
 |      but not supported
 |      >>> img.set_data_dtype('int')
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
 |      >>> img.set_data_dtype(int)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
 |      numpy.int16.
 |      >>> img.set_data_dtype('int64')
 |      >>> img.get_data_dtype() == np.dtype('int64')
 |      True
 |  
 |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
 |      Set qform header values from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform. If None, only set code.
 |      code : None, string or integer
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing qform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing qform code in header != 0,
 |            `code`-> existing qform code in header
 |      
 |      strip_shears : bool, optional
 |          Whether to strip shears in `affine`.  If True, shears will be
 |          silently stripped. If False, the presence of shears will raise a
 |          ``HeaderDataError``
 |      update_affine : bool, optional
 |          Whether to update the image affine from the header best affine
 |          after setting the qform. Must be keyword argument (because of
 |          different position in `set_qform`). Default is True
 |      
 |      See also
 |      --------
 |      get_qform
 |      set_sform
 |      
 |      Examples
 |      --------
 |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> aff = np.diag([2, 3, 4, 1])
 |      >>> img = Nifti1Pair(data, aff)
 |      >>> img.get_qform()
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> img.get_qform(coded=True)
 |      (None, 0)
 |      >>> aff2 = np.diag([3, 4, 5, 1])
 |      >>> img.set_qform(aff2, 'talairach')
 |      >>> qaff, code = img.get_qform(coded=True)
 |      >>> np.all(qaff == aff2)
 |      True
 |      >>> int(code)
 |      3
 |  
 |  set_sform(self, affine, code=None, **kwargs)
 |      Set sform transform from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform.  If None, only set `code`
 |      code : None, string or integer
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing sform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing sform code in header != 0,
 |            `code`-> existing sform code in header
 |      
 |      update_affine : bool, optional
 |          Whether to update the image affine from the header best affine
 |          after setting the qform.  Must be keyword argument (because of
 |          different position in `set_qform`). Default is True
 |      
 |      See also
 |      --------
 |      get_sform
 |      set_qform
 |      
 |      Examples
 |      --------
 |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> aff = np.diag([2, 3, 4, 1])
 |      >>> img = Nifti1Pair(data, aff)
 |      >>> img.get_sform()
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> saff, code = img.get_sform(coded=True)
 |      >>> saff
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> int(code)
 |      2
 |      >>> aff2 = np.diag([3, 4, 5, 1])
 |      >>> img.set_sform(aff2, 'talairach')
 |      >>> saff, code = img.get_sform(coded=True)
 |      >>> np.all(saff == aff2)
 |      True
 |      >>> int(code)
 |      3
 |  
 |  to_file_map(self, file_map=None, dtype=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead
 |      dtype : dtype-like, optional
 |         The on-disk data type to coerce the data array.
 |  
 |  update_header(self)
 |      Harmonize header with image data and affine
 |      
 |      See AnalyzeImage.update_header for more examples
 |      
 |      Examples
 |      --------
 |      >>> data = np.zeros((2,3,4))
 |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
 |      >>> img = Nifti1Image(data, affine)
 |      >>> hdr = img.header
 |      >>> np.all(hdr.get_qform() == affine)
 |      True
 |      >>> np.all(hdr.get_sform() == affine)
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
 |  
 |  header_class = <class 'nibabel.nifti1.Nifti1PairHeader'>
 |      Class for NIfTI1 pair header
 |  
 |  
 |  rw = True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : AnalyzeImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
 |      Class to act as proxy for the array that can be read from a file
 |      
 |      The array proxy allows us to freeze the passed fileobj and header such that
 |      it returns the expected data array.
 |      
 |      This implementation assumes a contiguous array in the file object, with one
 |      of the numpy dtypes, starting at a given file position ``offset`` with
 |      single ``slope`` and ``intercept`` scaling to produce output values.
 |      
 |      The class ``__init__`` requires a spec which defines how the data will be
 |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
 |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
 |      with methods:
 |      
 |      * get_data_shape
 |      * get_data_dtype
 |      * get_data_offset
 |      * get_slope_inter
 |      
 |      A header should also have a 'copy' method.  This requirement will go away
 |      when the deprecated 'header' property goes away.
 |      
 |      This implementation allows us to deal with Analyze and its variants,
 |      including Nifti1, and with the MGH format.
 |      
 |      Other image types might need more specific classes to implement the API.
 |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
 |      examples.
 |  
 |  
 |  files_types = (('image', '.img'), ('header', '.hdr'))
 |  
 |  makeable = True
 |  
 |  valid_exts = ('.img', '.hdr')
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& Nifti2Header &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Nifti2Header in module nibabel.nifti2:

class Nifti2Header(nibabel.nifti1.Nifti1Header)
 |  Nifti2Header(binaryblock=None, endianness=None, check=True, extensions=())
 |  
 |  Class for NIfTI2 header
 |  
 |  NIfTI2 is a slightly simplified variant of NIfTI1 which replaces 32-bit
 |  floats with 64-bit floats, and increases some integer widths to 32 or 64
 |  bits.
 |  
 |  Method resolution order:
 |      Nifti2Header
 |      nibabel.nifti1.Nifti1Header
 |      nibabel.spm99analyze.SpmAnalyzeHeader
 |      nibabel.analyze.AnalyzeHeader
 |      nibabel.wrapstruct.LabeledWrapStruct
 |      nibabel.wrapstruct.WrapStruct
 |      nibabel.spatialimages.SpatialHeader
 |      nibabel.filebasedimages.FileBasedHeader
 |      nibabel.spatialimages.SpatialProtocol
 |      typing.Protocol
 |      typing.Generic
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __subclasshook__ = _proto_hook(other)
 |      # Set (or override) the protocol subclass hook.
 |  
 |  get_data_shape(self)
 |      Get shape of data
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti2Header()
 |      >>> hdr.get_data_shape()
 |      (0,)
 |      >>> hdr.set_data_shape((1,2,3))
 |      >>> hdr.get_data_shape()
 |      (1, 2, 3)
 |      
 |      Expanding number of dimensions gets default zooms
 |      
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0, 1.0)
 |      
 |      Notes
 |      -----
 |      Does not use Nifti1 freesurfer hack for large vectors described in
 |      :meth:`Nifti1Header.set_data_shape`
 |  
 |  set_data_shape(self, shape)
 |      Set shape of data
 |      
 |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
 |      ``ndims`` to 1.0
 |      
 |      Parameters
 |      ----------
 |      shape : sequence
 |         sequence of integers specifying data array shape
 |      
 |      Notes
 |      -----
 |      Does not apply nifti1 Freesurfer hack for long vectors (see
 |      :meth:`Nifti1Header.set_data_shape`)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  default_structarr(endianness=None) from typing._ProtocolMeta
 |      Create empty header binary block with given endianness
 |  
 |  may_contain_header(binaryblock) from typing._ProtocolMeta
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __abstractmethods__ = frozenset()
 |  
 |  __parameters__ = ()
 |  
 |  pair_magic = b'ni2'
 |  
 |  pair_vox_offset = 0
 |  
 |  quaternion_threshold = -6.661338147750939e-16
 |  
 |  single_magic = b'n+2'
 |  
 |  single_vox_offset = 544
 |  
 |  sizeof_hdr = 540
 |  
 |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('magic', 'S4'), (...16...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.nifti1.Nifti1Header:
 |  
 |  __init__(self, binaryblock=None, endianness=None, check=True, extensions=())
 |      Initialize header from binary data block and extensions
 |  
 |  copy(self)
 |      Return copy of header
 |      
 |      Take reference to extensions as well as copy of header contents
 |  
 |  get_best_affine(self)
 |      Select best of available transforms
 |  
 |  get_dim_info(self)
 |      Gets NIfTI MRI slice etc dimension information
 |      
 |      Returns
 |      -------
 |      freq : {None,0,1,2}
 |         Which data array axis is frequency encode direction
 |      phase : {None,0,1,2}
 |         Which data array axis is phase encode direction
 |      slice : {None,0,1,2}
 |         Which data array axis is slice encode direction
 |      
 |      where ``data array`` is the array returned by ``get_data``
 |      
 |      Because NIfTI1 files are natively Fortran indexed:
 |        0 is fastest changing in file
 |        1 is medium changing in file
 |        2 is slowest changing in file
 |      
 |      ``None`` means the axis appears not to be specified.
 |      
 |      Examples
 |      --------
 |      See set_dim_info function
 |  
 |  get_intent(self, code_repr='label')
 |      Get intent code, parameters and name
 |      
 |      Parameters
 |      ----------
 |      code_repr : string
 |         string giving output form of intent code representation.
 |         Default is 'label'; use 'code' for integer representation.
 |      
 |      Returns
 |      -------
 |      code : string or integer
 |          intent code, or string describing code
 |      parameters : tuple
 |          parameters for the intent
 |      name : string
 |          intent name
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_intent('t test', (10,), name='some score')
 |      >>> hdr.get_intent()
 |      ('t test', (10.0,), 'some score')
 |      >>> hdr.get_intent('code')
 |      (3, (10.0,), 'some score')
 |  
 |  get_n_slices(self)
 |      Return the number of slices
 |  
 |  get_qform(self, coded=False)
 |      Return 4x4 affine matrix from qform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and qform code.  If False, just
 |          return affine.  {affine or None} means, return None if qform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine reconstructed from qform
 |          quaternion.  If `coded` is True, return None if qform code is 0,
 |          else return the affine.
 |      code : int
 |          Qform code. Only returned if `coded` is True.
 |  
 |  get_qform_quaternion(self)
 |      Compute quaternion from b, c, d of quaternion
 |      
 |      Fills a value by assuming this is a unit quaternion
 |  
 |  get_sform(self, coded=False)
 |      Return 4x4 affine matrix from sform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and sform code.  If False, just
 |          return affine.  {affine or None} means, return None if sform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine from sform fields. If
 |          `coded` is True, return None if sform code is 0, else return the
 |          affine.
 |      code : int
 |          Sform code. Only returned if `coded` is True.
 |  
 |  get_slice_duration(self)
 |      Get slice duration
 |      
 |      Returns
 |      -------
 |      slice_duration : float
 |          time to acquire one slice
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_dim_info(slice=2)
 |      >>> hdr.set_slice_duration(0.3)
 |      >>> print("%0.1f" % hdr.get_slice_duration())
 |      0.3
 |      
 |      Notes
 |      -----
 |      The NIfTI1 spec appears to require the slice dimension to be
 |      defined for slice_duration to have meaning.
 |  
 |  get_slice_times(self)
 |      Get slice times from slice timing information
 |      
 |      Returns
 |      -------
 |      slice_times : tuple
 |          Times of acquisition of slices, where 0 is the beginning of
 |          the acquisition, ordered by position in file.  nifti allows
 |          slices at the top and bottom of the volume to be excluded from
 |          the standard slice timing specification, and calls these
 |          "padding slices".  We give padding slices ``None`` as a time
 |          of acquisition
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_dim_info(slice=2)
 |      >>> hdr.set_data_shape((1, 1, 7))
 |      >>> hdr.set_slice_duration(0.1)
 |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
 |      >>> slice_times = hdr.get_slice_times()
 |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
 |      True
 |  
 |  get_slope_inter(self)
 |      Get data scaling (slope) and DC offset (intercept) from header data
 |      
 |      Returns
 |      -------
 |      slope : None or float
 |         scaling (slope).  None if there is no valid scaling from these
 |         fields
 |      inter : None or float
 |         offset (intercept). None if there is no valid scaling or if offset
 |         is not finite.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.get_slope_inter()
 |      (1.0, 0.0)
 |      >>> hdr['scl_slope'] = 0
 |      >>> hdr.get_slope_inter()
 |      (None, None)
 |      >>> hdr['scl_slope'] = np.nan
 |      >>> hdr.get_slope_inter()
 |      (None, None)
 |      >>> hdr['scl_slope'] = 1
 |      >>> hdr['scl_inter'] = 1
 |      >>> hdr.get_slope_inter()
 |      (1.0, 1.0)
 |      >>> hdr['scl_inter'] = np.inf
 |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |          ...
 |      HeaderDataError: Valid slope but invalid intercept inf
 |  
 |  get_xyzt_units(self)
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code or dtype or type
 |      
 |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
 |      will be interpreted as ``np.int64``, which is almost never desired.
 |      ``np.int64`` is permitted for those intent on making poor choices.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_data_dtype(np.uint8)
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype('implausible')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
 |      >>> hdr.set_data_dtype('none')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
 |      >>> hdr.set_data_dtype(np.void)
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
 |      but not supported
 |      >>> hdr.set_data_dtype('int')
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
 |      >>> hdr.set_data_dtype(int)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
 |      numpy.int16.
 |      >>> hdr.set_data_dtype('int64')
 |      >>> hdr.get_data_dtype() == np.dtype('int64')
 |      True
 |  
 |  set_dim_info(self, freq=None, phase=None, slice=None)
 |      Sets nifti MRI slice etc dimension information
 |      
 |      Parameters
 |      ----------
 |      freq : {None, 0, 1, 2}
 |          axis of data array referring to frequency encoding
 |      phase : {None, 0, 1, 2}
 |          axis of data array referring to phase encoding
 |      slice : {None, 0, 1, 2}
 |          axis of data array referring to slice encoding
 |      
 |      ``None`` means the axis is not specified.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_dim_info(1, 2, 0)
 |      >>> hdr.get_dim_info()
 |      (1, 2, 0)
 |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
 |      >>> hdr.get_dim_info()
 |      (1, 2, 0)
 |      >>> hdr.set_dim_info()
 |      >>> hdr.get_dim_info()
 |      (None, None, None)
 |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
 |      >>> hdr.get_dim_info()
 |      (1, None, 0)
 |      
 |      Notes
 |      -----
 |      This is stored in one byte in the header
 |  
 |  set_intent(self, code, params=(), name='', allow_unknown=False)
 |      Set the intent code, parameters and name
 |      
 |      If parameters are not specified, assumed to be all zero. Each
 |      intent code has a set number of parameters associated. If you
 |      specify any parameters, then it will need to be the correct number
 |      (e.g the "f test" intent requires 2).  However, parameters can
 |      also be set in the file data, so we also allow not setting any
 |      parameters (empty parameter tuple).
 |      
 |      Parameters
 |      ----------
 |      code : integer or string
 |          code specifying nifti intent
 |      params : list, tuple of scalars
 |          parameters relating to intent (see intent_codes)
 |          defaults to ().  Unspecified parameters are set to 0.0
 |      name : string
 |          intent name (description). Defaults to ''
 |      allow_unknown : {False, True}, optional
 |          Allow unknown integer intent codes. If False (the default),
 |          a KeyError is raised on attempts to set the intent
 |          to an unknown code.
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_intent(0)  # no intent
 |      >>> hdr.set_intent('z score')
 |      >>> hdr.get_intent()
 |      ('z score', (), '')
 |      >>> hdr.get_intent('code')
 |      (5, (), '')
 |      >>> hdr.set_intent('t test', (10,), name='some score')
 |      >>> hdr.get_intent()
 |      ('t test', (10.0,), 'some score')
 |      >>> hdr.set_intent('f test', (2, 10), name='another score')
 |      >>> hdr.get_intent()
 |      ('f test', (2.0, 10.0), 'another score')
 |      >>> hdr.set_intent('f test')
 |      >>> hdr.get_intent()
 |      ('f test', (0.0, 0.0), '')
 |      >>> hdr.set_intent(9999, allow_unknown=True) # unknown code
 |      >>> hdr.get_intent()
 |      ('unknown code 9999', (), '')
 |  
 |  set_qform(self, affine, code=None, strip_shears=True)
 |      Set qform header values from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform. If None, only set code.
 |      code : None, string or integer, optional
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing qform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing qform code in header != 0,
 |            `code`-> existing qform code in header
 |      
 |      strip_shears : bool, optional
 |          Whether to strip shears in `affine`.  If True, shears will be
 |          silently stripped. If False, the presence of shears will raise a
 |          ``HeaderDataError``
 |      
 |      Notes
 |      -----
 |      The qform transform only encodes translations, rotations and
 |      zooms. If there are shear components to the `affine` transform, and
 |      `strip_shears` is True (the default), the written qform gives the
 |      closest approximation where the rotation matrix is orthogonal. This is
 |      to allow quaternion representation. The orthogonal representation
 |      enforces orthogonal axes.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> int(hdr['qform_code'])  # gives 0 - unknown
 |      0
 |      >>> affine = np.diag([1,2,3,1])
 |      >>> np.all(hdr.get_qform() == affine)
 |      False
 |      >>> hdr.set_qform(affine)
 |      >>> np.all(hdr.get_qform() == affine)
 |      True
 |      >>> int(hdr['qform_code'])  # gives 2 - aligned
 |      2
 |      >>> hdr.set_qform(affine, code='talairach')
 |      >>> int(hdr['qform_code'])
 |      3
 |      >>> hdr.set_qform(affine, code=None)
 |      >>> int(hdr['qform_code'])
 |      3
 |      >>> hdr.set_qform(affine, code='scanner')
 |      >>> int(hdr['qform_code'])
 |      1
 |      >>> hdr.set_qform(None)
 |      >>> int(hdr['qform_code'])
 |      0
 |  
 |  set_sform(self, affine, code=None)
 |      Set sform transform from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform.  If None, only set `code`
 |      code : None, string or integer, optional
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing sform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing sform code in header != 0,
 |            `code`-> existing sform code in header
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> int(hdr['sform_code'])  # gives 0 - unknown
 |      0
 |      >>> affine = np.diag([1,2,3,1])
 |      >>> np.all(hdr.get_sform() == affine)
 |      False
 |      >>> hdr.set_sform(affine)
 |      >>> np.all(hdr.get_sform() == affine)
 |      True
 |      >>> int(hdr['sform_code'])  # gives 2 - aligned
 |      2
 |      >>> hdr.set_sform(affine, code='talairach')
 |      >>> int(hdr['sform_code'])
 |      3
 |      >>> hdr.set_sform(affine, code=None)
 |      >>> int(hdr['sform_code'])
 |      3
 |      >>> hdr.set_sform(affine, code='scanner')
 |      >>> int(hdr['sform_code'])
 |      1
 |      >>> hdr.set_sform(None)
 |      >>> int(hdr['sform_code'])
 |      0
 |  
 |  set_slice_duration(self, duration)
 |      Set slice duration
 |      
 |      Parameters
 |      ----------
 |      duration : scalar
 |          time to acquire one slice
 |      
 |      Examples
 |      --------
 |      See ``get_slice_duration``
 |  
 |  set_slice_times(self, slice_times)
 |      Set slice times into *hdr*
 |      
 |      Parameters
 |      ----------
 |      slice_times : tuple
 |          tuple of slice times, one value per slice
 |          tuple can include None to indicate no slice time for that slice
 |      
 |      Examples
 |      --------
 |      >>> hdr = Nifti1Header()
 |      >>> hdr.set_dim_info(slice=2)
 |      >>> hdr.set_data_shape([1, 1, 7])
 |      >>> hdr.set_slice_duration(0.1)
 |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
 |      >>> hdr.set_slice_times(times)
 |      >>> hdr.get_value_label('slice_code')
 |      'alternating decreasing'
 |      >>> int(hdr['slice_start'])
 |      1
 |      >>> int(hdr['slice_end'])
 |      5
 |  
 |  set_slope_inter(self, slope, inter=None)
 |      Set slope and / or intercept into header
 |      
 |      Set slope and intercept for image data, such that, if the image
 |      data is ``arr``, then the scaled image data will be ``(arr *
 |      slope) + inter``
 |      
 |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
 |      set `slope`, `inter` automatically on write.
 |      
 |      Parameters
 |      ----------
 |      slope : None or float
 |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
 |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
 |         HeaderDataError
 |      inter : None or float, optional
 |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
 |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
 |         HeaderDataError
 |  
 |  set_xyzt_units(self, xyz=None, t=None)
 |  
 |  write_to(self, fileobj)
 |      Write structure to fileobj
 |      
 |      Write starts at fileobj current file position.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Should implement ``write`` method
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> wstr.write_to(str_io)
 |      >>> wstr.binaryblock == str_io.getvalue()
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.nifti1.Nifti1Header:
 |  
 |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
 |      Return read structure with given or guessed endiancode
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Needs to implement ``read`` method
 |      endianness : None or endian code, optional
 |         Code specifying endianness of read data
 |      
 |      Returns
 |      -------
 |      wstr : WrapStruct object
 |         WrapStruct object initialized from data in fileobj
 |  
 |  from_header(header=None, check=True) from typing._ProtocolMeta
 |      Class method to create header from another header
 |      
 |      Extend Analyze header copy by copying extensions from other Nifti
 |      types.
 |      
 |      Parameters
 |      ----------
 |      header : ``Header`` instance or mapping
 |         a header of this class, or another class of header for
 |         conversion to this type
 |      check : {True, False}
 |         whether to check header for integrity
 |      
 |      Returns
 |      -------
 |      hdr : header instance
 |         fresh header instance of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.nifti1.Nifti1Header:
 |  
 |  exts_klass = <class 'nibabel.nifti1.Nifti1Extensions'>
 |      Simple extension collection, implemented as a list-subclass.
 |  
 |  
 |  has_data_intercept = True
 |  
 |  has_data_slope = True
 |  
 |  is_single = True
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  as_analyze_map(self)
 |      Return header as mapping for conversion to Analyze types
 |      
 |      Collect data from custom header type to fill in fields for Analyze and
 |      derived header types (such as Nifti1 and Nifti2).
 |      
 |      When Analyze types convert another header type to their own type, they
 |      call this this method to check if there are other Analyze / Nifti
 |      fields that the source header would like to set.
 |      
 |      Returns
 |      -------
 |      analyze_map : mapping
 |          Object that can be used as a mapping thus::
 |      
 |              for key in analyze_map:
 |                  value = analyze_map[key]
 |      
 |          where ``key`` is the name of a field that can be set in an Analyze
 |          header type, such as Nifti1, and ``value`` is a value for the
 |          field.  For example, `analyze_map` might be a something like
 |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
 |          field present in both Analyze and Nifti1, and ``slice_duration`` is
 |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
 |          header type does not recognize the field name, it will throw away
 |          the value without error.  See :meth:`Analyze.from_header`.
 |      
 |      Notes
 |      -----
 |      You can also return a Nifti header with the relevant fields set.
 |      
 |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
 |      and ``get_zooms``, for the conversion, and these get called *after*
 |      using the analyze map, so the methods will override values set in the
 |      map.
 |  
 |  data_from_fileobj(self, fileobj)
 |      Read scaled data array from `fileobj`
 |      
 |      Use this routine to get the scaled image data from an image file
 |      `fileobj`, given a header `self`.  "Scaled" means, with any header
 |      scaling factors applied to the raw data in the file.  Use
 |      `raw_data_from_fileobj` to get the raw data.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         scaled data array
 |      
 |      Notes
 |      -----
 |      We use the header to get any scale or intercept values to apply to the
 |      data.  Raw Analyze files don't have scale factors or intercepts, but
 |      this routine also works with formats based on Analyze, that do have
 |      scaling, such as SPM analyze formats and NIfTI.
 |  
 |  data_to_fileobj(self, data, fileobj, rescale=True)
 |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
 |      
 |      In writing the data, we match the header to the written data, by
 |      setting the header scaling factors, iff `rescale` is True.  Thus we
 |      modify `self` in the process of writing the data.
 |      
 |      Parameters
 |      ----------
 |      data : array-like
 |         data to write; should match header defined shape
 |      fileobj : file-like object
 |         Object with file interface, implementing ``write`` and
 |         ``seek``
 |      rescale : {True, False}, optional
 |          Whether to try and rescale data to match output dtype specified by
 |          header. If True and scaling needed and header cannot scale, then
 |          raise ``HeaderTypeError``.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.analyze import AnalyzeHeader
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((1, 2, 3))
 |      >>> hdr.set_data_dtype(np.float64)
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> data = np.arange(6).reshape(1,2,3)
 |      >>> hdr.data_to_fileobj(data, str_io)
 |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
 |      True
 |  
 |  get_base_affine(self)
 |      Get affine from basic (shared) header fields
 |      
 |      Note that we get the translations from the center of the
 |      image.
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3, 2, 1))
 |      >>> hdr.default_x_flip
 |      True
 |      >>> hdr.get_base_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  get_data_dtype(self)
 |      Get numpy dtype for data
 |      
 |      For examples see ``set_data_dtype``
 |  
 |  get_data_offset(self)
 |      Return offset into data file to read data
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_data_offset()
 |      0
 |      >>> hdr['vox_offset'] = 12
 |      >>> hdr.get_data_offset()
 |      12
 |  
 |  get_zooms(self)
 |      Get zooms from header
 |      
 |      Returns
 |      -------
 |      z : tuple
 |         tuple of header zoom values
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_zooms()
 |      (1.0,)
 |      >>> hdr.set_data_shape((1,2))
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0)
 |      >>> hdr.set_zooms((3, 4))
 |      >>> hdr.get_zooms()
 |      (3.0, 4.0)
 |  
 |  raw_data_from_fileobj(self, fileobj)
 |      Read unscaled data array from `fileobj`
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         unscaled data array
 |  
 |  set_data_offset(self, offset)
 |      Set offset into data file to read data
 |  
 |  set_zooms(self, zooms)
 |      Set zooms into header fields
 |      
 |      See docstring for ``get_zooms`` for examples
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  guessed_endian(hdr) from typing._ProtocolMeta
 |      Guess intended endianness from mapping-like ``hdr``
 |      
 |      Parameters
 |      ----------
 |      hdr : mapping-like
 |         hdr for which to guess endianness
 |      
 |      Returns
 |      -------
 |      endianness : {'<', '>'}
 |         Guessed endianness of header
 |      
 |      Examples
 |      --------
 |      Zeros header, no information, guess native
 |      
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr_data = np.zeros((), dtype=header_dtype)
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      A valid native header is guessed native
 |      
 |      >>> hdr_data = hdr.structarr.copy()
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      And, when swapped, is guessed as swapped
 |      
 |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
 |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
 |      True
 |      
 |      The algorithm is as follows:
 |      
 |      First, look at the first value in the ``dim`` field; this
 |      should be between 0 and 7.  If it is between 1 and 7, then
 |      this must be a native endian header.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = 6
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      
 |      If the first ``dim`` value is zeros, we need a tie breaker.
 |      In that case we check the ``sizeof_hdr`` field.  This should
 |      be 348.  If it looks like the byteswapped value of 348,
 |      assumed swapped.  Otherwise assume native.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      This is overridden by the ``dim[0]`` value though:
 |      
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  default_x_flip = True
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __str__(self)
 |      Return string representation for printing
 |  
 |  get_value_label(self, fieldname)
 |      Returns label for coded field
 |      
 |      A coded field is an int field containing codes that stand for
 |      discrete values that also have string labels.
 |      
 |      Parameters
 |      ----------
 |      fieldname : str
 |         name of header field to get label for
 |      
 |      Returns
 |      -------
 |      label : str
 |         label for code value in header field `fieldname`
 |      
 |      Raises
 |      ------
 |      ValueError
 |          if field is not coded.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.volumeutils import Recoder
 |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
 |      >>> class C(LabeledWrapStruct):
 |      ...     template_dtype = np.dtype([('datatype', 'i2')])
 |      ...     _field_recoders = dict(datatype = recoder)
 |      >>> hdr  = C()
 |      >>> hdr.get_value_label('datatype')
 |      '<unknown code 0>'
 |      >>> hdr['datatype'] = 2
 |      >>> hdr.get_value_label('datatype')
 |      'two'
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __eq__(self, other)
 |      equality between two structures defined by binaryblock
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr2 = WrapStruct()
 |      >>> wstr == wstr2
 |      True
 |      >>> wstr3 = WrapStruct(endianness=swapped_code)
 |      >>> wstr == wstr3
 |      True
 |  
 |  __getitem__(self, item)
 |      Return values from structure data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] == 0
 |      True
 |  
 |  __iter__(self)
 |  
 |  __ne__(self, other)
 |      Return self!=value.
 |  
 |  __setitem__(self, item, value)
 |      Set values in structured data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] = 3
 |      >>> wstr['integer']
 |      array(3, dtype=int16)
 |  
 |  as_byteswapped(self, endianness=None)
 |      return new byteswapped object with given ``endianness``
 |      
 |      Guaranteed to make a copy even if endianness is the same as
 |      the current endianness.
 |      
 |      Parameters
 |      ----------
 |      endianness : None or string, optional
 |         endian code to which to swap.  None means swap from current
 |         endianness, and is the default
 |      
 |      Returns
 |      -------
 |      wstr : ``WrapStruct``
 |         ``WrapStruct`` object with given endianness
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr.endianness == native_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped()
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr is wstr
 |      False
 |      >>> bs_wstr == wstr
 |      True
 |      
 |      If you write to the resulting byteswapped data, it does not
 |      change the original.
 |      
 |      >>> bs_wstr['integer'] = 3
 |      >>> bs_wstr == wstr
 |      False
 |      
 |      If you swap to the same endianness, it returns a copy
 |      
 |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
 |      >>> nbs_wstr.endianness == native_code
 |      True
 |      >>> nbs_wstr is wstr
 |      False
 |  
 |  check_fix(self, logger=None, error_level=None)
 |      Check structured data with checks
 |      
 |      Parameters
 |      ----------
 |      logger : None or logging.Logger
 |      error_level : None or int
 |          Level of error severity at which to raise error.  Any error of
 |          severity >= `error_level` will cause an exception.
 |  
 |  get(self, k, d=None)
 |      Return value for the key k if present or d otherwise
 |  
 |  items(self)
 |      Return items from structured data
 |  
 |  keys(self)
 |      Return keys from structured data
 |  
 |  values(self)
 |      Return values from structured data
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
 |      Run checks over binary data, return string
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  binaryblock
 |      binary block of data as string
 |      
 |      Returns
 |      -------
 |      binaryblock : string
 |          string giving binary data block
 |      
 |      Examples
 |      --------
 |      >>> # Make default empty structure
 |      >>> wstr = WrapStruct()
 |      >>> len(wstr.binaryblock)
 |      2
 |  
 |  endianness
 |      endian code of binary data
 |      
 |      The endianness code gives the current byte order
 |      interpretation of the binary data.
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> code = wstr.endianness
 |      >>> code == native_code
 |      True
 |      
 |      Notes
 |      -----
 |      Endianness gives endian interpretation of binary data. It is
 |      read only because the only common use case is to set the
 |      endianness on initialization, or occasionally byteswapping the
 |      data - but this is done via the as_byteswapped method
 |  
 |  structarr
 |      Structured data, with data fields
 |      
 |      Examples
 |      --------
 |      >>> wstr1 = WrapStruct() # with default data
 |      >>> an_int = wstr1.structarr['integer']
 |      >>> wstr1.structarr = None
 |      Traceback (most recent call last):
 |         ...
 |      AttributeError: ...
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
 |  
 |  data_layout = 'F'
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Protocol:
 |  
 |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
 |      This method is called when a class is subclassed.
 |      
 |      The default implementation does nothing. It may be
 |      overridden to extend subclasses.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Generic:
 |  
 |  __class_getitem__(params) from typing._ProtocolMeta

None
&&&&&&&&&&&&&&&&&&&&&&&&& Nifti2Image &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Nifti2Image in module nibabel.nifti2:

class Nifti2Image(nibabel.nifti1.Nifti1Image)
 |  Nifti2Image(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |  
 |  Class for single file NIfTI2 format image
 |  
 |  Method resolution order:
 |      Nifti2Image
 |      nibabel.nifti1.Nifti1Image
 |      nibabel.nifti1.Nifti1Pair
 |      nibabel.analyze.AnalyzeImage
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.SerializableImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Data and other attributes defined here:
 |  
 |  header_class = <class 'nibabel.nifti2.Nifti2Header'>
 |      Class for NIfTI2 header
 |      
 |      NIfTI2 is a slightly simplified variant of NIfTI1 which replaces 32-bit
 |      floats with 64-bit floats, and increases some integer widths to 32 or 64
 |      bits.
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.nifti1.Nifti1Image:
 |  
 |  update_header(self)
 |      Harmonize header with image data and affine
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.nifti1.Nifti1Image:
 |  
 |  files_types = (('image', '.nii'),)
 |  
 |  valid_exts = ('.nii',)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.nifti1.Nifti1Pair:
 |  
 |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |      
 |      Notes
 |      -----
 |      
 |      If both a `header` and an `affine` are specified, and the `affine` does
 |      not match the affine that is in the `header`, the `affine` will be used,
 |      but the ``sform_code`` and ``qform_code`` fields in the header will be
 |      re-initialised to their default values. This is performed on the basis
 |      that, if you are changing the affine, you are likely to be changing the
 |      space to which the affine is pointing.  The :meth:`set_sform` and
 |      :meth:`set_qform` methods can be used to update the codes after an image
 |      has been created - see those methods, and the :ref:`manual
 |      <default-sform-qform-codes>` for more details.
 |  
 |  as_reoriented(self, ornt)
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |  
 |  get_data_dtype(self, finalize=False)
 |      Get numpy dtype for data
 |      
 |      If ``set_data_dtype()`` has been called with an alias
 |      and ``finalize`` is ``False``, return the alias.
 |      If ``finalize`` is ``True``, determine the appropriate dtype
 |      from the image data object and set the final dtype in the
 |      header before returning it.
 |  
 |  get_qform(self, coded=False)
 |      Return 4x4 affine matrix from qform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and qform code.  If False, just
 |          return affine.  {affine or None} means, return None if qform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine reconstructed from qform
 |          quaternion.  If `coded` is True, return None if qform code is 0,
 |          else return the affine.
 |      code : int
 |          Qform code. Only returned if `coded` is True.
 |      
 |      See also
 |      --------
 |      set_qform
 |      get_sform
 |  
 |  get_sform(self, coded=False)
 |      Return 4x4 affine matrix from sform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and sform code.  If False, just
 |          return affine.  {affine or None} means, return None if sform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine from sform fields. If
 |          `coded` is True, return None if sform code is 0, else return the
 |          affine.
 |      code : int
 |          Sform code. Only returned if `coded` is True.
 |      
 |      See also
 |      --------
 |      set_sform
 |      get_qform
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code, dtype, type or alias
 |      
 |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
 |      will be interpreted as ``np.int64``, which is almost never desired.
 |      ``np.int64`` is permitted for those intent on making poor choices.
 |      
 |      The following aliases are defined to allow for flexible specification:
 |      
 |        * ``'mask'`` - Alias for ``uint8``
 |        * ``'compat'`` - The nearest Analyze-compatible datatype
 |          (``uint8``, ``int16``, ``int32``, ``float32``)
 |        * ``'smallest'`` - The smallest Analyze-compatible integer
 |          (``uint8``, ``int16``, ``int32``)
 |      
 |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
 |      with a ``finalize=True`` flag. Until then, these aliases are not
 |      written to the header and will not persist to new images.
 |      
 |      Examples
 |      --------
 |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
 |      
 |      >>> img = Nifti1Image(ints, np.eye(4))
 |      >>> img.set_data_dtype(np.uint8)
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      >>> img.set_data_dtype('mask')
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      >>> img.set_data_dtype('compat')
 |      >>> img.get_data_dtype()
 |      'compat'
 |      >>> img.get_data_dtype(finalize=True)
 |      dtype('<i4')
 |      >>> img.get_data_dtype()
 |      dtype('<i4')
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.get_data_dtype()
 |      'smallest'
 |      >>> img.get_data_dtype(finalize=True)
 |      dtype('uint8')
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      
 |      Note that floating point values will not be coerced to ``int``
 |      
 |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> img = Nifti1Image(floats, np.eye(4))
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.get_data_dtype(finalize=True)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Cannot automatically cast array (of type float32) to an integer
 |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
 |      
 |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
 |      >>> img = Nifti1Image(arr, np.eye(4))
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.set_data_dtype('implausible')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
 |      >>> img.set_data_dtype('none')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
 |      >>> img.set_data_dtype(np.void)
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
 |      but not supported
 |      >>> img.set_data_dtype('int')
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
 |      >>> img.set_data_dtype(int)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
 |      numpy.int16.
 |      >>> img.set_data_dtype('int64')
 |      >>> img.get_data_dtype() == np.dtype('int64')
 |      True
 |  
 |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
 |      Set qform header values from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform. If None, only set code.
 |      code : None, string or integer
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing qform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing qform code in header != 0,
 |            `code`-> existing qform code in header
 |      
 |      strip_shears : bool, optional
 |          Whether to strip shears in `affine`.  If True, shears will be
 |          silently stripped. If False, the presence of shears will raise a
 |          ``HeaderDataError``
 |      update_affine : bool, optional
 |          Whether to update the image affine from the header best affine
 |          after setting the qform. Must be keyword argument (because of
 |          different position in `set_qform`). Default is True
 |      
 |      See also
 |      --------
 |      get_qform
 |      set_sform
 |      
 |      Examples
 |      --------
 |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> aff = np.diag([2, 3, 4, 1])
 |      >>> img = Nifti1Pair(data, aff)
 |      >>> img.get_qform()
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> img.get_qform(coded=True)
 |      (None, 0)
 |      >>> aff2 = np.diag([3, 4, 5, 1])
 |      >>> img.set_qform(aff2, 'talairach')
 |      >>> qaff, code = img.get_qform(coded=True)
 |      >>> np.all(qaff == aff2)
 |      True
 |      >>> int(code)
 |      3
 |  
 |  set_sform(self, affine, code=None, **kwargs)
 |      Set sform transform from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform.  If None, only set `code`
 |      code : None, string or integer
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing sform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing sform code in header != 0,
 |            `code`-> existing sform code in header
 |      
 |      update_affine : bool, optional
 |          Whether to update the image affine from the header best affine
 |          after setting the qform.  Must be keyword argument (because of
 |          different position in `set_qform`). Default is True
 |      
 |      See also
 |      --------
 |      get_sform
 |      set_qform
 |      
 |      Examples
 |      --------
 |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> aff = np.diag([2, 3, 4, 1])
 |      >>> img = Nifti1Pair(data, aff)
 |      >>> img.get_sform()
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> saff, code = img.get_sform(coded=True)
 |      >>> saff
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> int(code)
 |      2
 |      >>> aff2 = np.diag([3, 4, 5, 1])
 |      >>> img.set_sform(aff2, 'talairach')
 |      >>> saff, code = img.get_sform(coded=True)
 |      >>> np.all(saff == aff2)
 |      True
 |      >>> int(code)
 |      3
 |  
 |  to_file_map(self, file_map=None, dtype=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead
 |      dtype : dtype-like, optional
 |         The on-disk data type to coerce the data array.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.nifti1.Nifti1Pair:
 |  
 |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
 |  
 |  rw = True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : AnalyzeImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
 |      Class to act as proxy for the array that can be read from a file
 |      
 |      The array proxy allows us to freeze the passed fileobj and header such that
 |      it returns the expected data array.
 |      
 |      This implementation assumes a contiguous array in the file object, with one
 |      of the numpy dtypes, starting at a given file position ``offset`` with
 |      single ``slope`` and ``intercept`` scaling to produce output values.
 |      
 |      The class ``__init__`` requires a spec which defines how the data will be
 |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
 |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
 |      with methods:
 |      
 |      * get_data_shape
 |      * get_data_dtype
 |      * get_data_offset
 |      * get_slope_inter
 |      
 |      A header should also have a 'copy' method.  This requirement will go away
 |      when the deprecated 'header' property goes away.
 |      
 |      This implementation allows us to deal with Analyze and its variants,
 |      including Nifti1, and with the MGH format.
 |      
 |      Other image types might need more specific classes to implement the API.
 |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
 |      examples.
 |  
 |  
 |  makeable = True
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  to_bytes(self, **kwargs) -> 'bytes'
 |      Return a ``bytes`` object with the contents of the file that would
 |      be written if the image were saved.
 |      
 |      Parameters
 |      ----------
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |      
 |      Returns
 |      -------
 |      bytes
 |          Serialized image
 |  
 |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
 |      Save image to writable IO stream
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Writable stream
 |      \*\*kwargs : keyword arguments
 |          Keyword arguments that may be passed to ``img.to_file_map()``
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.SerializableImage:
 |  
 |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
 |      Construct image from a byte string
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      bytestring : bytes
 |          Byte string containing the on-disk representation of an image
 |  
 |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
 |      Load image from readable IO stream
 |      
 |      Convert to BytesIO to enable seeking, if input stream is not seekable
 |      
 |      Parameters
 |      ----------
 |      io_obj : IOBase object
 |          Readable stream
 |  
 |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
 |      Retrieve and load an image from a URL
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      url : str or urllib.request.Request object
 |          URL of file to retrieve
 |      timeout : float, optional
 |          Time (in seconds) to wait for a response
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& Nifti2Pair &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Nifti2Pair in module nibabel.nifti2:

class Nifti2Pair(nibabel.nifti1.Nifti1Pair)
 |  Nifti2Pair(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |  
 |  Class for NIfTI2 format image, header pair
 |  
 |  Method resolution order:
 |      Nifti2Pair
 |      nibabel.nifti1.Nifti1Pair
 |      nibabel.analyze.AnalyzeImage
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Data and other attributes defined here:
 |  
 |  header_class = <class 'nibabel.nifti2.Nifti2PairHeader'>
 |      Class for NIfTI2 pair header
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.nifti1.Nifti1Pair:
 |  
 |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |      
 |      Notes
 |      -----
 |      
 |      If both a `header` and an `affine` are specified, and the `affine` does
 |      not match the affine that is in the `header`, the `affine` will be used,
 |      but the ``sform_code`` and ``qform_code`` fields in the header will be
 |      re-initialised to their default values. This is performed on the basis
 |      that, if you are changing the affine, you are likely to be changing the
 |      space to which the affine is pointing.  The :meth:`set_sform` and
 |      :meth:`set_qform` methods can be used to update the codes after an image
 |      has been created - see those methods, and the :ref:`manual
 |      <default-sform-qform-codes>` for more details.
 |  
 |  as_reoriented(self, ornt)
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |  
 |  get_data_dtype(self, finalize=False)
 |      Get numpy dtype for data
 |      
 |      If ``set_data_dtype()`` has been called with an alias
 |      and ``finalize`` is ``False``, return the alias.
 |      If ``finalize`` is ``True``, determine the appropriate dtype
 |      from the image data object and set the final dtype in the
 |      header before returning it.
 |  
 |  get_qform(self, coded=False)
 |      Return 4x4 affine matrix from qform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and qform code.  If False, just
 |          return affine.  {affine or None} means, return None if qform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine reconstructed from qform
 |          quaternion.  If `coded` is True, return None if qform code is 0,
 |          else return the affine.
 |      code : int
 |          Qform code. Only returned if `coded` is True.
 |      
 |      See also
 |      --------
 |      set_qform
 |      get_sform
 |  
 |  get_sform(self, coded=False)
 |      Return 4x4 affine matrix from sform parameters in header
 |      
 |      Parameters
 |      ----------
 |      coded : bool, optional
 |          If True, return {affine or None}, and sform code.  If False, just
 |          return affine.  {affine or None} means, return None if sform code
 |          == 0, and affine otherwise.
 |      
 |      Returns
 |      -------
 |      affine : None or (4,4) ndarray
 |          If `coded` is False, always return affine from sform fields. If
 |          `coded` is True, return None if sform code is 0, else return the
 |          affine.
 |      code : int
 |          Sform code. Only returned if `coded` is True.
 |      
 |      See also
 |      --------
 |      set_sform
 |      get_qform
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code, dtype, type or alias
 |      
 |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
 |      will be interpreted as ``np.int64``, which is almost never desired.
 |      ``np.int64`` is permitted for those intent on making poor choices.
 |      
 |      The following aliases are defined to allow for flexible specification:
 |      
 |        * ``'mask'`` - Alias for ``uint8``
 |        * ``'compat'`` - The nearest Analyze-compatible datatype
 |          (``uint8``, ``int16``, ``int32``, ``float32``)
 |        * ``'smallest'`` - The smallest Analyze-compatible integer
 |          (``uint8``, ``int16``, ``int32``)
 |      
 |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
 |      with a ``finalize=True`` flag. Until then, these aliases are not
 |      written to the header and will not persist to new images.
 |      
 |      Examples
 |      --------
 |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
 |      
 |      >>> img = Nifti1Image(ints, np.eye(4))
 |      >>> img.set_data_dtype(np.uint8)
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      >>> img.set_data_dtype('mask')
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      >>> img.set_data_dtype('compat')
 |      >>> img.get_data_dtype()
 |      'compat'
 |      >>> img.get_data_dtype(finalize=True)
 |      dtype('<i4')
 |      >>> img.get_data_dtype()
 |      dtype('<i4')
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.get_data_dtype()
 |      'smallest'
 |      >>> img.get_data_dtype(finalize=True)
 |      dtype('uint8')
 |      >>> img.get_data_dtype()
 |      dtype('uint8')
 |      
 |      Note that floating point values will not be coerced to ``int``
 |      
 |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> img = Nifti1Image(floats, np.eye(4))
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.get_data_dtype(finalize=True)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Cannot automatically cast array (of type float32) to an integer
 |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
 |      
 |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
 |      >>> img = Nifti1Image(arr, np.eye(4))
 |      >>> img.set_data_dtype('smallest')
 |      >>> img.set_data_dtype('implausible')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
 |      >>> img.set_data_dtype('none')
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
 |      >>> img.set_data_dtype(np.void)
 |      Traceback (most recent call last):
 |         ...
 |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
 |      but not supported
 |      >>> img.set_data_dtype('int')
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
 |      >>> img.set_data_dtype(int)
 |      Traceback (most recent call last):
 |         ...
 |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
 |      numpy.int16.
 |      >>> img.set_data_dtype('int64')
 |      >>> img.get_data_dtype() == np.dtype('int64')
 |      True
 |  
 |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
 |      Set qform header values from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform. If None, only set code.
 |      code : None, string or integer
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing qform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing qform code in header != 0,
 |            `code`-> existing qform code in header
 |      
 |      strip_shears : bool, optional
 |          Whether to strip shears in `affine`.  If True, shears will be
 |          silently stripped. If False, the presence of shears will raise a
 |          ``HeaderDataError``
 |      update_affine : bool, optional
 |          Whether to update the image affine from the header best affine
 |          after setting the qform. Must be keyword argument (because of
 |          different position in `set_qform`). Default is True
 |      
 |      See also
 |      --------
 |      get_qform
 |      set_sform
 |      
 |      Examples
 |      --------
 |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> aff = np.diag([2, 3, 4, 1])
 |      >>> img = Nifti1Pair(data, aff)
 |      >>> img.get_qform()
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> img.get_qform(coded=True)
 |      (None, 0)
 |      >>> aff2 = np.diag([3, 4, 5, 1])
 |      >>> img.set_qform(aff2, 'talairach')
 |      >>> qaff, code = img.get_qform(coded=True)
 |      >>> np.all(qaff == aff2)
 |      True
 |      >>> int(code)
 |      3
 |  
 |  set_sform(self, affine, code=None, **kwargs)
 |      Set sform transform from 4x4 affine
 |      
 |      Parameters
 |      ----------
 |      affine : None or 4x4 array
 |          affine transform to write into sform.  If None, only set `code`
 |      code : None, string or integer
 |          String or integer giving meaning of transform in *affine*.
 |          The default is None.  If code is None, then:
 |      
 |          * If affine is None, `code`-> 0
 |          * If affine not None and existing sform code in header == 0,
 |            `code`-> 2 (aligned)
 |          * If affine not None and existing sform code in header != 0,
 |            `code`-> existing sform code in header
 |      
 |      update_affine : bool, optional
 |          Whether to update the image affine from the header best affine
 |          after setting the qform.  Must be keyword argument (because of
 |          different position in `set_qform`). Default is True
 |      
 |      See also
 |      --------
 |      get_sform
 |      set_qform
 |      
 |      Examples
 |      --------
 |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
 |      >>> aff = np.diag([2, 3, 4, 1])
 |      >>> img = Nifti1Pair(data, aff)
 |      >>> img.get_sform()
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> saff, code = img.get_sform(coded=True)
 |      >>> saff
 |      array([[2., 0., 0., 0.],
 |             [0., 3., 0., 0.],
 |             [0., 0., 4., 0.],
 |             [0., 0., 0., 1.]])
 |      >>> int(code)
 |      2
 |      >>> aff2 = np.diag([3, 4, 5, 1])
 |      >>> img.set_sform(aff2, 'talairach')
 |      >>> saff, code = img.get_sform(coded=True)
 |      >>> np.all(saff == aff2)
 |      True
 |      >>> int(code)
 |      3
 |  
 |  to_file_map(self, file_map=None, dtype=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead
 |      dtype : dtype-like, optional
 |         The on-disk data type to coerce the data array.
 |  
 |  update_header(self)
 |      Harmonize header with image data and affine
 |      
 |      See AnalyzeImage.update_header for more examples
 |      
 |      Examples
 |      --------
 |      >>> data = np.zeros((2,3,4))
 |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
 |      >>> img = Nifti1Image(data, affine)
 |      >>> hdr = img.header
 |      >>> np.all(hdr.get_qform() == affine)
 |      True
 |      >>> np.all(hdr.get_sform() == affine)
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.nifti1.Nifti1Pair:
 |  
 |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
 |  
 |  rw = True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : AnalyzeImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
 |      Class to act as proxy for the array that can be read from a file
 |      
 |      The array proxy allows us to freeze the passed fileobj and header such that
 |      it returns the expected data array.
 |      
 |      This implementation assumes a contiguous array in the file object, with one
 |      of the numpy dtypes, starting at a given file position ``offset`` with
 |      single ``slope`` and ``intercept`` scaling to produce output values.
 |      
 |      The class ``__init__`` requires a spec which defines how the data will be
 |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
 |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
 |      with methods:
 |      
 |      * get_data_shape
 |      * get_data_dtype
 |      * get_data_offset
 |      * get_slope_inter
 |      
 |      A header should also have a 'copy' method.  This requirement will go away
 |      when the deprecated 'header' property goes away.
 |      
 |      This implementation allows us to deal with Analyze and its variants,
 |      including Nifti1, and with the MGH format.
 |      
 |      Other image types might need more specific classes to implement the API.
 |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
 |      examples.
 |  
 |  
 |  files_types = (('image', '.img'), ('header', '.hdr'))
 |  
 |  makeable = True
 |  
 |  valid_exts = ('.img', '.hdr')
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& OrientationError &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class OrientationError in module nibabel.orientations:

class OrientationError(builtins.Exception)
 |  Method resolution order:
 |      OrientationError
 |      builtins.Exception
 |      builtins.BaseException
 |      builtins.object
 |  
 |  Data descriptors defined here:
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.Exception:
 |  
 |  __init__(self, /, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from builtins.Exception:
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.BaseException:
 |  
 |  __delattr__(self, name, /)
 |      Implement delattr(self, name).
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __reduce__(...)
 |      Helper for pickle.
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __setattr__(self, name, value, /)
 |      Implement setattr(self, name, value).
 |  
 |  __setstate__(...)
 |  
 |  __str__(self, /)
 |      Return str(self).
 |  
 |  with_traceback(...)
 |      Exception.with_traceback(tb) --
 |      set self.__traceback__ to tb and return self.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from builtins.BaseException:
 |  
 |  __cause__
 |      exception cause
 |  
 |  __context__
 |      exception context
 |  
 |  __dict__
 |  
 |  __suppress_context__
 |  
 |  __traceback__
 |  
 |  args

None
&&&&&&&&&&&&&&&&&&&&&&&&& Spm2AnalyzeHeader &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Spm2AnalyzeHeader in module nibabel.spm2analyze:

class Spm2AnalyzeHeader(nibabel.spm99analyze.Spm99AnalyzeHeader)
 |  Spm2AnalyzeHeader(binaryblock=None, endianness=None, check=True)
 |  
 |  Class for SPM2 variant of basic Analyze header
 |  
 |  SPM2 variant adds the following to basic Analyze format:
 |  
 |  * voxel origin;
 |  * slope scaling of data;
 |  * reading - but not writing - intercept of data.
 |  
 |  Method resolution order:
 |      Spm2AnalyzeHeader
 |      nibabel.spm99analyze.Spm99AnalyzeHeader
 |      nibabel.spm99analyze.SpmAnalyzeHeader
 |      nibabel.analyze.AnalyzeHeader
 |      nibabel.wrapstruct.LabeledWrapStruct
 |      nibabel.wrapstruct.WrapStruct
 |      nibabel.spatialimages.SpatialHeader
 |      nibabel.filebasedimages.FileBasedHeader
 |      nibabel.spatialimages.SpatialProtocol
 |      typing.Protocol
 |      typing.Generic
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __subclasshook__ = _proto_hook(other)
 |      # Set (or override) the protocol subclass hook.
 |  
 |  get_slope_inter(self)
 |      Get data scaling (slope) and intercept from header data
 |      
 |      Uses the algorithm from SPM2 spm_vol_ana.m by John Ashburner
 |      
 |      Parameters
 |      ----------
 |      self : header
 |         Mapping with fields:
 |         * scl_slope - slope
 |         * scl_inter - possible intercept (SPM2 use - shared by nifti)
 |         * glmax - the (recorded) maximum value in the data (unscaled)
 |         * glmin - recorded minimum unscaled value
 |         * cal_max - the calibrated (scaled) maximum value in the dataset
 |         * cal_min - ditto minimum value
 |      
 |      Returns
 |      -------
 |      scl_slope : None or float
 |          slope.  None if there is no valid scaling from these fields
 |      scl_inter : None or float
 |          intercept.  Also None if there is no valid slope, intercept
 |      
 |      Examples
 |      --------
 |      >>> fields = {'scl_slope': 1, 'scl_inter': 0, 'glmax': 0, 'glmin': 0,
 |      ...           'cal_max': 0, 'cal_min': 0}
 |      >>> hdr = Spm2AnalyzeHeader()
 |      >>> for key, value in fields.items():
 |      ...     hdr[key] = value
 |      >>> hdr.get_slope_inter()
 |      (1.0, 0.0)
 |      >>> hdr['scl_inter'] = 0.5
 |      >>> hdr.get_slope_inter()
 |      (1.0, 0.5)
 |      >>> hdr['scl_inter'] = np.nan
 |      >>> hdr.get_slope_inter()
 |      (1.0, 0.0)
 |      
 |      If 'scl_slope' is 0, nan or inf, cannot use 'scl_slope'.
 |      Without valid information in the gl / cal fields, we cannot get
 |      scaling, and return None
 |      
 |      >>> hdr['scl_slope'] = 0
 |      >>> hdr.get_slope_inter()
 |      (None, None)
 |      >>> hdr['scl_slope'] = np.nan
 |      >>> hdr.get_slope_inter()
 |      (None, None)
 |      
 |      Valid information in the gl AND cal fields are needed
 |      
 |      >>> hdr['cal_max'] = 0.8
 |      >>> hdr['cal_min'] = 0.2
 |      >>> hdr.get_slope_inter()
 |      (None, None)
 |      >>> hdr['glmax'] = 110
 |      >>> hdr['glmin'] = 10
 |      >>> np.allclose(hdr.get_slope_inter(), [0.6/100, 0.2-0.6/100*10])
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  may_contain_header(binaryblock) from typing._ProtocolMeta
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __abstractmethods__ = frozenset()
 |  
 |  __parameters__ = ()
 |  
 |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spm99analyze.Spm99AnalyzeHeader:
 |  
 |  get_best_affine = get_origin_affine(self)
 |  
 |  get_origin_affine(self)
 |      Get affine from header, using SPM origin field if sensible
 |      
 |      The default translations are got from the ``origin``
 |      field, if set, or from the center of the image otherwise.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Spm99AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3, 2, 1))
 |      >>> hdr.default_x_flip
 |      True
 |      >>> hdr.get_origin_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |      >>> hdr['origin'][:3] = [3,4,5]
 |      >>> hdr.get_origin_affine() # using origin
 |      array([[-3.,  0.,  0.,  6.],
 |             [ 0.,  2.,  0., -6.],
 |             [ 0.,  0.,  1., -4.],
 |             [ 0.,  0.,  0.,  1.]])
 |      >>> hdr['origin'] = 0 # unset origin
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.get_origin_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  set_origin_from_affine(self, affine)
 |      Set SPM origin to header from affine matrix.
 |      
 |      The ``origin`` field was read but not written by SPM99 and 2.  It was
 |      used for storing a central voxel coordinate, that could be used in
 |      aligning the image to some standard position - a proxy for a full
 |      translation vector that was usually stored in a separate matlab .mat
 |      file.
 |      
 |      Nifti uses the space occupied by the SPM ``origin`` field for important
 |      other information (the transform codes), so writing the origin will
 |      make the header a confusing Nifti file.  If you work with both Analyze
 |      and Nifti, you should probably avoid doing this.
 |      
 |      Parameters
 |      ----------
 |      affine : array-like, shape (4,4)
 |         Affine matrix to set
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> hdr = Spm99AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3,2,1))
 |      >>> hdr.get_origin_affine()
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |      >>> affine = np.diag([3,2,1,1])
 |      >>> affine[:3,3] = [-6, -6, -4]
 |      >>> hdr.set_origin_from_affine(affine)
 |      >>> np.all(hdr['origin'][:3] == [3,4,5])
 |      True
 |      >>> hdr.get_origin_affine()
 |      array([[-3.,  0.,  0.,  6.],
 |             [ 0.,  2.,  0., -6.],
 |             [ 0.,  0.,  1., -4.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
 |  
 |  set_slope_inter(self, slope, inter=None)
 |      Set slope and / or intercept into header
 |      
 |      Set slope and intercept for image data, such that, if the image
 |      data is ``arr``, then the scaled image data will be ``(arr *
 |      slope) + inter``
 |      
 |      The SPM Analyze header can't save an intercept value, and we raise an
 |      error unless `inter` is None, NaN or 0
 |      
 |      Parameters
 |      ----------
 |      slope : None or float
 |         If None, implies `slope` of NaN.  NaN is a signal to the image
 |         writing routines to rescale on save.  0, Inf, -Inf are invalid and
 |         cause a HeaderDataError
 |      inter : None or float, optional
 |         intercept. Must be None, NaN or 0, because SPM99 cannot store
 |         intercepts.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
 |  
 |  default_structarr(endianness=None) from typing._ProtocolMeta
 |      Create empty header binary block with given endianness
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
 |  
 |  has_data_intercept = False
 |  
 |  has_data_slope = True
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  __init__(self, binaryblock=None, endianness=None, check=True)
 |      Initialize header from binary data block
 |      
 |      Parameters
 |      ----------
 |      binaryblock : {None, string} optional
 |          binary block to set into header.  By default, None, in
 |          which case we insert the default empty header block
 |      endianness : {None, '<','>', other endian code} string, optional
 |          endianness of the binaryblock.  If None, guess endianness
 |          from the data.
 |      check : bool, optional
 |          Whether to check content of header in initialization.
 |          Default is True.
 |      
 |      Examples
 |      --------
 |      >>> hdr1 = AnalyzeHeader() # an empty header
 |      >>> hdr1.endianness == native_code
 |      True
 |      >>> hdr1.get_data_shape()
 |      (0,)
 |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
 |      >>> hdr1.get_data_shape()
 |      (1, 2, 3)
 |      
 |      We can set the binary block directly via this initialization.
 |      Here we get it from the header we have just made
 |      
 |      >>> binblock2 = hdr1.binaryblock
 |      >>> hdr2 = AnalyzeHeader(binblock2)
 |      >>> hdr2.get_data_shape()
 |      (1, 2, 3)
 |      
 |      Empty headers are native endian by default
 |      
 |      >>> hdr2.endianness == native_code
 |      True
 |      
 |      You can pass valid opposite endian headers with the
 |      ``endianness`` parameter. Even empty headers can have
 |      endianness
 |      
 |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
 |      >>> hdr3.endianness == swapped_code
 |      True
 |      
 |      If you do not pass an endianness, and you pass some data, we
 |      will try to guess from the passed data.
 |      
 |      >>> binblock3 = hdr3.binaryblock
 |      >>> hdr4 = AnalyzeHeader(binblock3)
 |      >>> hdr4.endianness == swapped_code
 |      True
 |  
 |  as_analyze_map(self)
 |      Return header as mapping for conversion to Analyze types
 |      
 |      Collect data from custom header type to fill in fields for Analyze and
 |      derived header types (such as Nifti1 and Nifti2).
 |      
 |      When Analyze types convert another header type to their own type, they
 |      call this this method to check if there are other Analyze / Nifti
 |      fields that the source header would like to set.
 |      
 |      Returns
 |      -------
 |      analyze_map : mapping
 |          Object that can be used as a mapping thus::
 |      
 |              for key in analyze_map:
 |                  value = analyze_map[key]
 |      
 |          where ``key`` is the name of a field that can be set in an Analyze
 |          header type, such as Nifti1, and ``value`` is a value for the
 |          field.  For example, `analyze_map` might be a something like
 |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
 |          field present in both Analyze and Nifti1, and ``slice_duration`` is
 |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
 |          header type does not recognize the field name, it will throw away
 |          the value without error.  See :meth:`Analyze.from_header`.
 |      
 |      Notes
 |      -----
 |      You can also return a Nifti header with the relevant fields set.
 |      
 |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
 |      and ``get_zooms``, for the conversion, and these get called *after*
 |      using the analyze map, so the methods will override values set in the
 |      map.
 |  
 |  data_from_fileobj(self, fileobj)
 |      Read scaled data array from `fileobj`
 |      
 |      Use this routine to get the scaled image data from an image file
 |      `fileobj`, given a header `self`.  "Scaled" means, with any header
 |      scaling factors applied to the raw data in the file.  Use
 |      `raw_data_from_fileobj` to get the raw data.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         scaled data array
 |      
 |      Notes
 |      -----
 |      We use the header to get any scale or intercept values to apply to the
 |      data.  Raw Analyze files don't have scale factors or intercepts, but
 |      this routine also works with formats based on Analyze, that do have
 |      scaling, such as SPM analyze formats and NIfTI.
 |  
 |  data_to_fileobj(self, data, fileobj, rescale=True)
 |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
 |      
 |      In writing the data, we match the header to the written data, by
 |      setting the header scaling factors, iff `rescale` is True.  Thus we
 |      modify `self` in the process of writing the data.
 |      
 |      Parameters
 |      ----------
 |      data : array-like
 |         data to write; should match header defined shape
 |      fileobj : file-like object
 |         Object with file interface, implementing ``write`` and
 |         ``seek``
 |      rescale : {True, False}, optional
 |          Whether to try and rescale data to match output dtype specified by
 |          header. If True and scaling needed and header cannot scale, then
 |          raise ``HeaderTypeError``.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.analyze import AnalyzeHeader
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((1, 2, 3))
 |      >>> hdr.set_data_dtype(np.float64)
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> data = np.arange(6).reshape(1,2,3)
 |      >>> hdr.data_to_fileobj(data, str_io)
 |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
 |      True
 |  
 |  get_base_affine(self)
 |      Get affine from basic (shared) header fields
 |      
 |      Note that we get the translations from the center of the
 |      image.
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3, 2, 1))
 |      >>> hdr.default_x_flip
 |      True
 |      >>> hdr.get_base_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  get_data_dtype(self)
 |      Get numpy dtype for data
 |      
 |      For examples see ``set_data_dtype``
 |  
 |  get_data_offset(self)
 |      Return offset into data file to read data
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_data_offset()
 |      0
 |      >>> hdr['vox_offset'] = 12
 |      >>> hdr.get_data_offset()
 |      12
 |  
 |  get_data_shape(self)
 |      Get shape of data
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_data_shape()
 |      (0,)
 |      >>> hdr.set_data_shape((1,2,3))
 |      >>> hdr.get_data_shape()
 |      (1, 2, 3)
 |      
 |      Expanding number of dimensions gets default zooms
 |      
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0, 1.0)
 |  
 |  get_zooms(self)
 |      Get zooms from header
 |      
 |      Returns
 |      -------
 |      z : tuple
 |         tuple of header zoom values
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_zooms()
 |      (1.0,)
 |      >>> hdr.set_data_shape((1,2))
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0)
 |      >>> hdr.set_zooms((3, 4))
 |      >>> hdr.get_zooms()
 |      (3.0, 4.0)
 |  
 |  raw_data_from_fileobj(self, fileobj)
 |      Read unscaled data array from `fileobj`
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         unscaled data array
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code or dtype or type
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_dtype(np.uint8)
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "implausible" not recognized
 |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "none" known but not supported
 |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
 |  
 |  set_data_offset(self, offset)
 |      Set offset into data file to read data
 |  
 |  set_data_shape(self, shape)
 |      Set shape of data
 |      
 |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
 |      ``ndims`` to 1.0
 |      
 |      Parameters
 |      ----------
 |      shape : sequence
 |         sequence of integers specifying data array shape
 |  
 |  set_zooms(self, zooms)
 |      Set zooms into header fields
 |      
 |      See docstring for ``get_zooms`` for examples
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  from_header(header=None, check=True) from typing._ProtocolMeta
 |      Class method to create header from another header
 |      
 |      Parameters
 |      ----------
 |      header : ``Header`` instance or mapping
 |         a header of this class, or another class of header for
 |         conversion to this type
 |      check : {True, False}
 |         whether to check header for integrity
 |      
 |      Returns
 |      -------
 |      hdr : header instance
 |         fresh header instance of our own class
 |  
 |  guessed_endian(hdr) from typing._ProtocolMeta
 |      Guess intended endianness from mapping-like ``hdr``
 |      
 |      Parameters
 |      ----------
 |      hdr : mapping-like
 |         hdr for which to guess endianness
 |      
 |      Returns
 |      -------
 |      endianness : {'<', '>'}
 |         Guessed endianness of header
 |      
 |      Examples
 |      --------
 |      Zeros header, no information, guess native
 |      
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr_data = np.zeros((), dtype=header_dtype)
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      A valid native header is guessed native
 |      
 |      >>> hdr_data = hdr.structarr.copy()
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      And, when swapped, is guessed as swapped
 |      
 |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
 |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
 |      True
 |      
 |      The algorithm is as follows:
 |      
 |      First, look at the first value in the ``dim`` field; this
 |      should be between 0 and 7.  If it is between 1 and 7, then
 |      this must be a native endian header.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = 6
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      
 |      If the first ``dim`` value is zeros, we need a tie breaker.
 |      In that case we check the ``sizeof_hdr`` field.  This should
 |      be 348.  If it looks like the byteswapped value of 348,
 |      assumed swapped.  Otherwise assume native.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      This is overridden by the ``dim[0]`` value though:
 |      
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  default_x_flip = True
 |  
 |  sizeof_hdr = 348
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __str__(self)
 |      Return string representation for printing
 |  
 |  get_value_label(self, fieldname)
 |      Returns label for coded field
 |      
 |      A coded field is an int field containing codes that stand for
 |      discrete values that also have string labels.
 |      
 |      Parameters
 |      ----------
 |      fieldname : str
 |         name of header field to get label for
 |      
 |      Returns
 |      -------
 |      label : str
 |         label for code value in header field `fieldname`
 |      
 |      Raises
 |      ------
 |      ValueError
 |          if field is not coded.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.volumeutils import Recoder
 |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
 |      >>> class C(LabeledWrapStruct):
 |      ...     template_dtype = np.dtype([('datatype', 'i2')])
 |      ...     _field_recoders = dict(datatype = recoder)
 |      >>> hdr  = C()
 |      >>> hdr.get_value_label('datatype')
 |      '<unknown code 0>'
 |      >>> hdr['datatype'] = 2
 |      >>> hdr.get_value_label('datatype')
 |      'two'
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __eq__(self, other)
 |      equality between two structures defined by binaryblock
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr2 = WrapStruct()
 |      >>> wstr == wstr2
 |      True
 |      >>> wstr3 = WrapStruct(endianness=swapped_code)
 |      >>> wstr == wstr3
 |      True
 |  
 |  __getitem__(self, item)
 |      Return values from structure data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] == 0
 |      True
 |  
 |  __iter__(self)
 |  
 |  __ne__(self, other)
 |      Return self!=value.
 |  
 |  __setitem__(self, item, value)
 |      Set values in structured data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] = 3
 |      >>> wstr['integer']
 |      array(3, dtype=int16)
 |  
 |  as_byteswapped(self, endianness=None)
 |      return new byteswapped object with given ``endianness``
 |      
 |      Guaranteed to make a copy even if endianness is the same as
 |      the current endianness.
 |      
 |      Parameters
 |      ----------
 |      endianness : None or string, optional
 |         endian code to which to swap.  None means swap from current
 |         endianness, and is the default
 |      
 |      Returns
 |      -------
 |      wstr : ``WrapStruct``
 |         ``WrapStruct`` object with given endianness
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr.endianness == native_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped()
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr is wstr
 |      False
 |      >>> bs_wstr == wstr
 |      True
 |      
 |      If you write to the resulting byteswapped data, it does not
 |      change the original.
 |      
 |      >>> bs_wstr['integer'] = 3
 |      >>> bs_wstr == wstr
 |      False
 |      
 |      If you swap to the same endianness, it returns a copy
 |      
 |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
 |      >>> nbs_wstr.endianness == native_code
 |      True
 |      >>> nbs_wstr is wstr
 |      False
 |  
 |  check_fix(self, logger=None, error_level=None)
 |      Check structured data with checks
 |      
 |      Parameters
 |      ----------
 |      logger : None or logging.Logger
 |      error_level : None or int
 |          Level of error severity at which to raise error.  Any error of
 |          severity >= `error_level` will cause an exception.
 |  
 |  copy(self)
 |      Return copy of structure
 |      
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] = 3
 |      >>> wstr2 = wstr.copy()
 |      >>> wstr2 is wstr
 |      False
 |      >>> wstr2['integer']
 |      array(3, dtype=int16)
 |  
 |  get(self, k, d=None)
 |      Return value for the key k if present or d otherwise
 |  
 |  items(self)
 |      Return items from structured data
 |  
 |  keys(self)
 |      Return keys from structured data
 |  
 |  values(self)
 |      Return values from structured data
 |  
 |  write_to(self, fileobj)
 |      Write structure to fileobj
 |      
 |      Write starts at fileobj current file position.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Should implement ``write`` method
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> wstr.write_to(str_io)
 |      >>> wstr.binaryblock == str_io.getvalue()
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
 |      Run checks over binary data, return string
 |  
 |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
 |      Return read structure with given or guessed endiancode
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Needs to implement ``read`` method
 |      endianness : None or endian code, optional
 |         Code specifying endianness of read data
 |      
 |      Returns
 |      -------
 |      wstr : WrapStruct object
 |         WrapStruct object initialized from data in fileobj
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  binaryblock
 |      binary block of data as string
 |      
 |      Returns
 |      -------
 |      binaryblock : string
 |          string giving binary data block
 |      
 |      Examples
 |      --------
 |      >>> # Make default empty structure
 |      >>> wstr = WrapStruct()
 |      >>> len(wstr.binaryblock)
 |      2
 |  
 |  endianness
 |      endian code of binary data
 |      
 |      The endianness code gives the current byte order
 |      interpretation of the binary data.
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> code = wstr.endianness
 |      >>> code == native_code
 |      True
 |      
 |      Notes
 |      -----
 |      Endianness gives endian interpretation of binary data. It is
 |      read only because the only common use case is to set the
 |      endianness on initialization, or occasionally byteswapping the
 |      data - but this is done via the as_byteswapped method
 |  
 |  structarr
 |      Structured data, with data fields
 |      
 |      Examples
 |      --------
 |      >>> wstr1 = WrapStruct() # with default data
 |      >>> an_int = wstr1.structarr['integer']
 |      >>> wstr1.structarr = None
 |      Traceback (most recent call last):
 |         ...
 |      AttributeError: ...
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
 |  
 |  data_layout = 'F'
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Protocol:
 |  
 |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
 |      This method is called when a class is subclassed.
 |      
 |      The default implementation does nothing. It may be
 |      overridden to extend subclasses.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Generic:
 |  
 |  __class_getitem__(params) from typing._ProtocolMeta

None
&&&&&&&&&&&&&&&&&&&&&&&&& Spm2AnalyzeImage &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Spm2AnalyzeImage in module nibabel.spm2analyze:

class Spm2AnalyzeImage(nibabel.spm99analyze.Spm99AnalyzeImage)
 |  Spm2AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |  
 |  Class for SPM2 variant of basic Analyze image
 |  
 |  Method resolution order:
 |      Spm2AnalyzeImage
 |      nibabel.spm99analyze.Spm99AnalyzeImage
 |      nibabel.analyze.AnalyzeImage
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Data and other attributes defined here:
 |  
 |  __annotations__ = {'header': <class 'nibabel.spm2analyze.Spm2AnalyzeHe...
 |  
 |  header_class = <class 'nibabel.spm2analyze.Spm2AnalyzeHeader'>
 |      Class for SPM2 variant of basic Analyze header
 |      
 |      SPM2 variant adds the following to basic Analyze format:
 |      
 |      * voxel origin;
 |      * slope scaling of data;
 |      * reading - but not writing - intercept of data.
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
 |  
 |  to_file_map(self, file_map=None, dtype=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Extends Analyze ``to_file_map`` method by writing ``mat`` file
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : Spm99AnalyzeImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
 |  
 |  files_types = (('image', '.img'), ('header', '.hdr'), ('mat', '.mat'))
 |  
 |  has_affine = True
 |  
 |  makeable = True
 |  
 |  rw = True
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |  
 |  get_data_dtype(self)
 |  
 |  set_data_dtype(self, dtype)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
 |      Class to act as proxy for the array that can be read from a file
 |      
 |      The array proxy allows us to freeze the passed fileobj and header such that
 |      it returns the expected data array.
 |      
 |      This implementation assumes a contiguous array in the file object, with one
 |      of the numpy dtypes, starting at a given file position ``offset`` with
 |      single ``slope`` and ``intercept`` scaling to produce output values.
 |      
 |      The class ``__init__`` requires a spec which defines how the data will be
 |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
 |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
 |      with methods:
 |      
 |      * get_data_shape
 |      * get_data_dtype
 |      * get_data_offset
 |      * get_slope_inter
 |      
 |      A header should also have a 'copy' method.  This requirement will go away
 |      when the deprecated 'header' property goes away.
 |      
 |      This implementation allows us to deal with Analyze and its variants,
 |      including Nifti1, and with the MGH format.
 |      
 |      Other image types might need more specific classes to implement the API.
 |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
 |      examples.
 |  
 |  
 |  valid_exts = ('.img', '.hdr')
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |      
 |      Notes
 |      -----
 |      Subclasses should override this if they have additional requirements
 |      when re-orienting an image.
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  update_header(self) -> 'None'
 |      Harmonize header with image data and affine
 |      
 |      >>> data = np.zeros((2,3,4))
 |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
 |      >>> img = SpatialImage(data, affine)
 |      >>> img.shape == (2, 3, 4)
 |      True
 |      >>> img.update_header()
 |      >>> img.header.get_data_shape() == (2, 3, 4)
 |      True
 |      >>> img.header.get_zooms()
 |      (1.0, 2.0, 3.0)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& Spm99AnalyzeHeader &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Spm99AnalyzeHeader in module nibabel.spm99analyze:

class Spm99AnalyzeHeader(SpmAnalyzeHeader)
 |  Spm99AnalyzeHeader(binaryblock=None, endianness=None, check=True)
 |  
 |  Class for SPM99 variant of basic Analyze header
 |  
 |  SPM99 variant adds the following to basic Analyze format:
 |  
 |  * voxel origin;
 |  * slope scaling of data.
 |  
 |  Method resolution order:
 |      Spm99AnalyzeHeader
 |      SpmAnalyzeHeader
 |      nibabel.analyze.AnalyzeHeader
 |      nibabel.wrapstruct.LabeledWrapStruct
 |      nibabel.wrapstruct.WrapStruct
 |      nibabel.spatialimages.SpatialHeader
 |      nibabel.filebasedimages.FileBasedHeader
 |      nibabel.spatialimages.SpatialProtocol
 |      typing.Protocol
 |      typing.Generic
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __subclasshook__ = _proto_hook(other)
 |      # Set (or override) the protocol subclass hook.
 |  
 |  get_best_affine = get_origin_affine(self)
 |  
 |  get_origin_affine(self)
 |      Get affine from header, using SPM origin field if sensible
 |      
 |      The default translations are got from the ``origin``
 |      field, if set, or from the center of the image otherwise.
 |      
 |      Examples
 |      --------
 |      >>> hdr = Spm99AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3, 2, 1))
 |      >>> hdr.default_x_flip
 |      True
 |      >>> hdr.get_origin_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |      >>> hdr['origin'][:3] = [3,4,5]
 |      >>> hdr.get_origin_affine() # using origin
 |      array([[-3.,  0.,  0.,  6.],
 |             [ 0.,  2.,  0., -6.],
 |             [ 0.,  0.,  1., -4.],
 |             [ 0.,  0.,  0.,  1.]])
 |      >>> hdr['origin'] = 0 # unset origin
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.get_origin_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  set_origin_from_affine(self, affine)
 |      Set SPM origin to header from affine matrix.
 |      
 |      The ``origin`` field was read but not written by SPM99 and 2.  It was
 |      used for storing a central voxel coordinate, that could be used in
 |      aligning the image to some standard position - a proxy for a full
 |      translation vector that was usually stored in a separate matlab .mat
 |      file.
 |      
 |      Nifti uses the space occupied by the SPM ``origin`` field for important
 |      other information (the transform codes), so writing the origin will
 |      make the header a confusing Nifti file.  If you work with both Analyze
 |      and Nifti, you should probably avoid doing this.
 |      
 |      Parameters
 |      ----------
 |      affine : array-like, shape (4,4)
 |         Affine matrix to set
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> hdr = Spm99AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3,2,1))
 |      >>> hdr.get_origin_affine()
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |      >>> affine = np.diag([3,2,1,1])
 |      >>> affine[:3,3] = [-6, -6, -4]
 |      >>> hdr.set_origin_from_affine(affine)
 |      >>> np.all(hdr['origin'][:3] == [3,4,5])
 |      True
 |      >>> hdr.get_origin_affine()
 |      array([[-3.,  0.,  0.,  6.],
 |             [ 0.,  2.,  0., -6.],
 |             [ 0.,  0.,  1., -4.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __abstractmethods__ = frozenset()
 |  
 |  __parameters__ = ()
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from SpmAnalyzeHeader:
 |  
 |  get_slope_inter(self)
 |      Get scalefactor and intercept
 |      
 |      If scalefactor is 0.0 return None to indicate no scalefactor.
 |      Intercept is always None because SPM99 analyze cannot store intercepts.
 |  
 |  set_slope_inter(self, slope, inter=None)
 |      Set slope and / or intercept into header
 |      
 |      Set slope and intercept for image data, such that, if the image
 |      data is ``arr``, then the scaled image data will be ``(arr *
 |      slope) + inter``
 |      
 |      The SPM Analyze header can't save an intercept value, and we raise an
 |      error unless `inter` is None, NaN or 0
 |      
 |      Parameters
 |      ----------
 |      slope : None or float
 |         If None, implies `slope` of NaN.  NaN is a signal to the image
 |         writing routines to rescale on save.  0, Inf, -Inf are invalid and
 |         cause a HeaderDataError
 |      inter : None or float, optional
 |         intercept. Must be None, NaN or 0, because SPM99 cannot store
 |         intercepts.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from SpmAnalyzeHeader:
 |  
 |  default_structarr(endianness=None) from typing._ProtocolMeta
 |      Create empty header binary block with given endianness
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from SpmAnalyzeHeader:
 |  
 |  has_data_intercept = False
 |  
 |  has_data_slope = True
 |  
 |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  __init__(self, binaryblock=None, endianness=None, check=True)
 |      Initialize header from binary data block
 |      
 |      Parameters
 |      ----------
 |      binaryblock : {None, string} optional
 |          binary block to set into header.  By default, None, in
 |          which case we insert the default empty header block
 |      endianness : {None, '<','>', other endian code} string, optional
 |          endianness of the binaryblock.  If None, guess endianness
 |          from the data.
 |      check : bool, optional
 |          Whether to check content of header in initialization.
 |          Default is True.
 |      
 |      Examples
 |      --------
 |      >>> hdr1 = AnalyzeHeader() # an empty header
 |      >>> hdr1.endianness == native_code
 |      True
 |      >>> hdr1.get_data_shape()
 |      (0,)
 |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
 |      >>> hdr1.get_data_shape()
 |      (1, 2, 3)
 |      
 |      We can set the binary block directly via this initialization.
 |      Here we get it from the header we have just made
 |      
 |      >>> binblock2 = hdr1.binaryblock
 |      >>> hdr2 = AnalyzeHeader(binblock2)
 |      >>> hdr2.get_data_shape()
 |      (1, 2, 3)
 |      
 |      Empty headers are native endian by default
 |      
 |      >>> hdr2.endianness == native_code
 |      True
 |      
 |      You can pass valid opposite endian headers with the
 |      ``endianness`` parameter. Even empty headers can have
 |      endianness
 |      
 |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
 |      >>> hdr3.endianness == swapped_code
 |      True
 |      
 |      If you do not pass an endianness, and you pass some data, we
 |      will try to guess from the passed data.
 |      
 |      >>> binblock3 = hdr3.binaryblock
 |      >>> hdr4 = AnalyzeHeader(binblock3)
 |      >>> hdr4.endianness == swapped_code
 |      True
 |  
 |  as_analyze_map(self)
 |      Return header as mapping for conversion to Analyze types
 |      
 |      Collect data from custom header type to fill in fields for Analyze and
 |      derived header types (such as Nifti1 and Nifti2).
 |      
 |      When Analyze types convert another header type to their own type, they
 |      call this this method to check if there are other Analyze / Nifti
 |      fields that the source header would like to set.
 |      
 |      Returns
 |      -------
 |      analyze_map : mapping
 |          Object that can be used as a mapping thus::
 |      
 |              for key in analyze_map:
 |                  value = analyze_map[key]
 |      
 |          where ``key`` is the name of a field that can be set in an Analyze
 |          header type, such as Nifti1, and ``value`` is a value for the
 |          field.  For example, `analyze_map` might be a something like
 |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
 |          field present in both Analyze and Nifti1, and ``slice_duration`` is
 |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
 |          header type does not recognize the field name, it will throw away
 |          the value without error.  See :meth:`Analyze.from_header`.
 |      
 |      Notes
 |      -----
 |      You can also return a Nifti header with the relevant fields set.
 |      
 |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
 |      and ``get_zooms``, for the conversion, and these get called *after*
 |      using the analyze map, so the methods will override values set in the
 |      map.
 |  
 |  data_from_fileobj(self, fileobj)
 |      Read scaled data array from `fileobj`
 |      
 |      Use this routine to get the scaled image data from an image file
 |      `fileobj`, given a header `self`.  "Scaled" means, with any header
 |      scaling factors applied to the raw data in the file.  Use
 |      `raw_data_from_fileobj` to get the raw data.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         scaled data array
 |      
 |      Notes
 |      -----
 |      We use the header to get any scale or intercept values to apply to the
 |      data.  Raw Analyze files don't have scale factors or intercepts, but
 |      this routine also works with formats based on Analyze, that do have
 |      scaling, such as SPM analyze formats and NIfTI.
 |  
 |  data_to_fileobj(self, data, fileobj, rescale=True)
 |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
 |      
 |      In writing the data, we match the header to the written data, by
 |      setting the header scaling factors, iff `rescale` is True.  Thus we
 |      modify `self` in the process of writing the data.
 |      
 |      Parameters
 |      ----------
 |      data : array-like
 |         data to write; should match header defined shape
 |      fileobj : file-like object
 |         Object with file interface, implementing ``write`` and
 |         ``seek``
 |      rescale : {True, False}, optional
 |          Whether to try and rescale data to match output dtype specified by
 |          header. If True and scaling needed and header cannot scale, then
 |          raise ``HeaderTypeError``.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.analyze import AnalyzeHeader
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((1, 2, 3))
 |      >>> hdr.set_data_dtype(np.float64)
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> data = np.arange(6).reshape(1,2,3)
 |      >>> hdr.data_to_fileobj(data, str_io)
 |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
 |      True
 |  
 |  get_base_affine(self)
 |      Get affine from basic (shared) header fields
 |      
 |      Note that we get the translations from the center of the
 |      image.
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_shape((3, 5, 7))
 |      >>> hdr.set_zooms((3, 2, 1))
 |      >>> hdr.default_x_flip
 |      True
 |      >>> hdr.get_base_affine() # from center of image
 |      array([[-3.,  0.,  0.,  3.],
 |             [ 0.,  2.,  0., -4.],
 |             [ 0.,  0.,  1., -3.],
 |             [ 0.,  0.,  0.,  1.]])
 |  
 |  get_data_dtype(self)
 |      Get numpy dtype for data
 |      
 |      For examples see ``set_data_dtype``
 |  
 |  get_data_offset(self)
 |      Return offset into data file to read data
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_data_offset()
 |      0
 |      >>> hdr['vox_offset'] = 12
 |      >>> hdr.get_data_offset()
 |      12
 |  
 |  get_data_shape(self)
 |      Get shape of data
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_data_shape()
 |      (0,)
 |      >>> hdr.set_data_shape((1,2,3))
 |      >>> hdr.get_data_shape()
 |      (1, 2, 3)
 |      
 |      Expanding number of dimensions gets default zooms
 |      
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0, 1.0)
 |  
 |  get_zooms(self)
 |      Get zooms from header
 |      
 |      Returns
 |      -------
 |      z : tuple
 |         tuple of header zoom values
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.get_zooms()
 |      (1.0,)
 |      >>> hdr.set_data_shape((1,2))
 |      >>> hdr.get_zooms()
 |      (1.0, 1.0)
 |      >>> hdr.set_zooms((3, 4))
 |      >>> hdr.get_zooms()
 |      (3.0, 4.0)
 |  
 |  raw_data_from_fileobj(self, fileobj)
 |      Read unscaled data array from `fileobj`
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like
 |         Must be open, and implement ``read`` and ``seek`` methods
 |      
 |      Returns
 |      -------
 |      arr : ndarray
 |         unscaled data array
 |  
 |  set_data_dtype(self, datatype)
 |      Set numpy dtype for data from code or dtype or type
 |      
 |      Examples
 |      --------
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr.set_data_dtype(np.uint8)
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
 |      >>> hdr.get_data_dtype()
 |      dtype('uint8')
 |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "implausible" not recognized
 |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "none" known but not supported
 |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |         ...
 |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
 |  
 |  set_data_offset(self, offset)
 |      Set offset into data file to read data
 |  
 |  set_data_shape(self, shape)
 |      Set shape of data
 |      
 |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
 |      ``ndims`` to 1.0
 |      
 |      Parameters
 |      ----------
 |      shape : sequence
 |         sequence of integers specifying data array shape
 |  
 |  set_zooms(self, zooms)
 |      Set zooms into header fields
 |      
 |      See docstring for ``get_zooms`` for examples
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  from_header(header=None, check=True) from typing._ProtocolMeta
 |      Class method to create header from another header
 |      
 |      Parameters
 |      ----------
 |      header : ``Header`` instance or mapping
 |         a header of this class, or another class of header for
 |         conversion to this type
 |      check : {True, False}
 |         whether to check header for integrity
 |      
 |      Returns
 |      -------
 |      hdr : header instance
 |         fresh header instance of our own class
 |  
 |  guessed_endian(hdr) from typing._ProtocolMeta
 |      Guess intended endianness from mapping-like ``hdr``
 |      
 |      Parameters
 |      ----------
 |      hdr : mapping-like
 |         hdr for which to guess endianness
 |      
 |      Returns
 |      -------
 |      endianness : {'<', '>'}
 |         Guessed endianness of header
 |      
 |      Examples
 |      --------
 |      Zeros header, no information, guess native
 |      
 |      >>> hdr = AnalyzeHeader()
 |      >>> hdr_data = np.zeros((), dtype=header_dtype)
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      A valid native header is guessed native
 |      
 |      >>> hdr_data = hdr.structarr.copy()
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      And, when swapped, is guessed as swapped
 |      
 |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
 |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
 |      True
 |      
 |      The algorithm is as follows:
 |      
 |      First, look at the first value in the ``dim`` field; this
 |      should be between 0 and 7.  If it is between 1 and 7, then
 |      this must be a native endian header.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = 6
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['dim'][0] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      
 |      If the first ``dim`` value is zeros, we need a tie breaker.
 |      In that case we check the ``sizeof_hdr`` field.  This should
 |      be 348.  If it looks like the byteswapped value of 348,
 |      assumed swapped.  Otherwise assume native.
 |      
 |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
 |      True
 |      >>> hdr_data['sizeof_hdr'] = -1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |      
 |      This is overridden by the ``dim[0]`` value though:
 |      
 |      >>> hdr_data['sizeof_hdr'] = 1543569408
 |      >>> hdr_data['dim'][0] = 1
 |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
 |      True
 |  
 |  may_contain_header(binaryblock) from typing._ProtocolMeta
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
 |  
 |  default_x_flip = True
 |  
 |  sizeof_hdr = 348
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __str__(self)
 |      Return string representation for printing
 |  
 |  get_value_label(self, fieldname)
 |      Returns label for coded field
 |      
 |      A coded field is an int field containing codes that stand for
 |      discrete values that also have string labels.
 |      
 |      Parameters
 |      ----------
 |      fieldname : str
 |         name of header field to get label for
 |      
 |      Returns
 |      -------
 |      label : str
 |         label for code value in header field `fieldname`
 |      
 |      Raises
 |      ------
 |      ValueError
 |          if field is not coded.
 |      
 |      Examples
 |      --------
 |      >>> from nibabel.volumeutils import Recoder
 |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
 |      >>> class C(LabeledWrapStruct):
 |      ...     template_dtype = np.dtype([('datatype', 'i2')])
 |      ...     _field_recoders = dict(datatype = recoder)
 |      >>> hdr  = C()
 |      >>> hdr.get_value_label('datatype')
 |      '<unknown code 0>'
 |      >>> hdr['datatype'] = 2
 |      >>> hdr.get_value_label('datatype')
 |      'two'
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
 |  
 |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __eq__(self, other)
 |      equality between two structures defined by binaryblock
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr2 = WrapStruct()
 |      >>> wstr == wstr2
 |      True
 |      >>> wstr3 = WrapStruct(endianness=swapped_code)
 |      >>> wstr == wstr3
 |      True
 |  
 |  __getitem__(self, item)
 |      Return values from structure data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] == 0
 |      True
 |  
 |  __iter__(self)
 |  
 |  __ne__(self, other)
 |      Return self!=value.
 |  
 |  __setitem__(self, item, value)
 |      Set values in structured data
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] = 3
 |      >>> wstr['integer']
 |      array(3, dtype=int16)
 |  
 |  as_byteswapped(self, endianness=None)
 |      return new byteswapped object with given ``endianness``
 |      
 |      Guaranteed to make a copy even if endianness is the same as
 |      the current endianness.
 |      
 |      Parameters
 |      ----------
 |      endianness : None or string, optional
 |         endian code to which to swap.  None means swap from current
 |         endianness, and is the default
 |      
 |      Returns
 |      -------
 |      wstr : ``WrapStruct``
 |         ``WrapStruct`` object with given endianness
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> wstr.endianness == native_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped()
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
 |      >>> bs_wstr.endianness == swapped_code
 |      True
 |      >>> bs_wstr is wstr
 |      False
 |      >>> bs_wstr == wstr
 |      True
 |      
 |      If you write to the resulting byteswapped data, it does not
 |      change the original.
 |      
 |      >>> bs_wstr['integer'] = 3
 |      >>> bs_wstr == wstr
 |      False
 |      
 |      If you swap to the same endianness, it returns a copy
 |      
 |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
 |      >>> nbs_wstr.endianness == native_code
 |      True
 |      >>> nbs_wstr is wstr
 |      False
 |  
 |  check_fix(self, logger=None, error_level=None)
 |      Check structured data with checks
 |      
 |      Parameters
 |      ----------
 |      logger : None or logging.Logger
 |      error_level : None or int
 |          Level of error severity at which to raise error.  Any error of
 |          severity >= `error_level` will cause an exception.
 |  
 |  copy(self)
 |      Return copy of structure
 |      
 |      >>> wstr = WrapStruct()
 |      >>> wstr['integer'] = 3
 |      >>> wstr2 = wstr.copy()
 |      >>> wstr2 is wstr
 |      False
 |      >>> wstr2['integer']
 |      array(3, dtype=int16)
 |  
 |  get(self, k, d=None)
 |      Return value for the key k if present or d otherwise
 |  
 |  items(self)
 |      Return items from structured data
 |  
 |  keys(self)
 |      Return keys from structured data
 |  
 |  values(self)
 |      Return values from structured data
 |  
 |  write_to(self, fileobj)
 |      Write structure to fileobj
 |      
 |      Write starts at fileobj current file position.
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Should implement ``write`` method
 |      
 |      Returns
 |      -------
 |      None
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> from io import BytesIO
 |      >>> str_io = BytesIO()
 |      >>> wstr.write_to(str_io)
 |      >>> wstr.binaryblock == str_io.getvalue()
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
 |      Run checks over binary data, return string
 |  
 |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
 |      Return read structure with given or guessed endiancode
 |      
 |      Parameters
 |      ----------
 |      fileobj : file-like object
 |         Needs to implement ``read`` method
 |      endianness : None or endian code, optional
 |         Code specifying endianness of read data
 |      
 |      Returns
 |      -------
 |      wstr : WrapStruct object
 |         WrapStruct object initialized from data in fileobj
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  binaryblock
 |      binary block of data as string
 |      
 |      Returns
 |      -------
 |      binaryblock : string
 |          string giving binary data block
 |      
 |      Examples
 |      --------
 |      >>> # Make default empty structure
 |      >>> wstr = WrapStruct()
 |      >>> len(wstr.binaryblock)
 |      2
 |  
 |  endianness
 |      endian code of binary data
 |      
 |      The endianness code gives the current byte order
 |      interpretation of the binary data.
 |      
 |      Examples
 |      --------
 |      >>> wstr = WrapStruct()
 |      >>> code = wstr.endianness
 |      >>> code == native_code
 |      True
 |      
 |      Notes
 |      -----
 |      Endianness gives endian interpretation of binary data. It is
 |      read only because the only common use case is to set the
 |      endianness on initialization, or occasionally byteswapping the
 |      data - but this is done via the as_byteswapped method
 |  
 |  structarr
 |      Structured data, with data fields
 |      
 |      Examples
 |      --------
 |      >>> wstr1 = WrapStruct() # with default data
 |      >>> an_int = wstr1.structarr['integer']
 |      >>> wstr1.structarr = None
 |      Traceback (most recent call last):
 |         ...
 |      AttributeError: ...
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
 |  
 |  data_layout = 'F'
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Protocol:
 |  
 |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
 |      This method is called when a class is subclassed.
 |      
 |      The default implementation does nothing. It may be
 |      overridden to extend subclasses.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Generic:
 |  
 |  __class_getitem__(params) from typing._ProtocolMeta

None
&&&&&&&&&&&&&&&&&&&&&&&&& Spm99AnalyzeImage &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on class Spm99AnalyzeImage in module nibabel.spm99analyze:

class Spm99AnalyzeImage(nibabel.analyze.AnalyzeImage)
 |  Spm99AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |  
 |  Class for SPM99 variant of basic Analyze image
 |  
 |  Method resolution order:
 |      Spm99AnalyzeImage
 |      nibabel.analyze.AnalyzeImage
 |      nibabel.spatialimages.SpatialImage
 |      nibabel.dataobj_images.DataobjImage
 |      nibabel.filebasedimages.FileBasedImage
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  to_file_map(self, file_map=None, dtype=None)
 |      Write image to `file_map` or contained ``self.file_map``
 |      
 |      Extends Analyze ``to_file_map`` method by writing ``mat`` file
 |      
 |      Parameters
 |      ----------
 |      file_map : None or mapping, optional
 |         files mapping.  If None (default) use object's ``file_map``
 |         attribute instead
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
 |      Class method to create image from mapping in ``file_map``
 |      
 |      Parameters
 |      ----------
 |      file_map : dict
 |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
 |          instance giving file-likes for each file needed for this image
 |          type.
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          If ``file_map`` refers to an open file handle, this setting has no
 |          effect. The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : Spm99AnalyzeImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __annotations__ = {'header': <class 'nibabel.spm99analyze.Spm99Analyze...
 |  
 |  files_types = (('image', '.img'), ('header', '.hdr'), ('mat', '.mat'))
 |  
 |  has_affine = True
 |  
 |  header_class = <class 'nibabel.spm99analyze.Spm99AnalyzeHeader'>
 |      Class for SPM99 variant of basic Analyze header
 |      
 |      SPM99 variant adds the following to basic Analyze format:
 |      
 |      * voxel origin;
 |      * slope scaling of data.
 |  
 |  
 |  makeable = True
 |  
 |  rw = True
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
 |      Initialize image
 |      
 |      The image is a combination of (array-like, affine matrix, header), with
 |      optional metadata in `extra`, and filename / file-like objects
 |      contained in the `file_map` mapping.
 |      
 |      Parameters
 |      ----------
 |      dataobj : object
 |         Object containing image data.  It should be some object that returns an
 |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
 |         or property
 |      affine : None or (4,4) array-like
 |         homogeneous affine giving relationship between voxel coordinates and
 |         world coordinates.  Affine can also be None.  In this case,
 |         ``obj.affine`` also returns None, and the affine as written to disk
 |         will depend on the file format.
 |      header : None or mapping or header instance, optional
 |         metadata for this image format
 |      extra : None or mapping, optional
 |         metadata to associate with image that cannot be stored in the
 |         metadata of this image type
 |      file_map : mapping, optional
 |         mapping giving file information for this image format
 |  
 |  get_data_dtype(self)
 |  
 |  set_data_dtype(self, dtype)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
 |  
 |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
 |      Class to act as proxy for the array that can be read from a file
 |      
 |      The array proxy allows us to freeze the passed fileobj and header such that
 |      it returns the expected data array.
 |      
 |      This implementation assumes a contiguous array in the file object, with one
 |      of the numpy dtypes, starting at a given file position ``offset`` with
 |      single ``slope`` and ``intercept`` scaling to produce output values.
 |      
 |      The class ``__init__`` requires a spec which defines how the data will be
 |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
 |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
 |      with methods:
 |      
 |      * get_data_shape
 |      * get_data_dtype
 |      * get_data_offset
 |      * get_slope_inter
 |      
 |      A header should also have a 'copy' method.  This requirement will go away
 |      when the deprecated 'header' property goes away.
 |      
 |      This implementation allows us to deal with Analyze and its variants,
 |      including Nifti1, and with the MGH format.
 |      
 |      Other image types might need more specific classes to implement the API.
 |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
 |      examples.
 |  
 |  
 |  valid_exts = ('.img', '.hdr')
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  __getitem__(self, idx: 'object') -> 'None'
 |      No slicing or dictionary interface for images
 |      
 |      Use the slicer attribute to perform cropping and subsampling at your
 |      own risk.
 |  
 |  __str__(self) -> 'str'
 |      Return str(self).
 |  
 |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
 |      Apply an orientation change and return a new image
 |      
 |      If ornt is identity transform, return the original image, unchanged
 |      
 |      Parameters
 |      ----------
 |      ornt : (n,2) orientation array
 |         orientation transform. ``ornt[N,1]` is flip of axis N of the
 |         array implied by `shape`, where 1 means no flip and -1 means
 |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
 |         there's an array ``arr`` of shape `shape`, the flip would
 |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
 |         the transpose that needs to be done to the implied array, as in
 |         ``arr.transpose(ornt[:,0])``
 |      
 |      Notes
 |      -----
 |      Subclasses should override this if they have additional requirements
 |      when re-orienting an image.
 |  
 |  orthoview(self) -> 'OrthoSlicer3D'
 |      Plot the image using OrthoSlicer3D
 |      
 |      Returns
 |      -------
 |      viewer : instance of OrthoSlicer3D
 |          The viewer.
 |      
 |      Notes
 |      -----
 |      This requires matplotlib. If a non-interactive backend is used,
 |      consider using viewer.show() (equivalently plt.show()) to show
 |      the figure.
 |  
 |  update_header(self) -> 'None'
 |      Harmonize header with image data and affine
 |      
 |      >>> data = np.zeros((2,3,4))
 |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
 |      >>> img = SpatialImage(data, affine)
 |      >>> img.shape == (2, 3, 4)
 |      True
 |      >>> img.update_header()
 |      >>> img.header.get_data_shape() == (2, 3, 4)
 |      True
 |      >>> img.header.get_zooms()
 |      (1.0, 2.0, 3.0)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
 |      Class method to create new instance of own class from `img`
 |      
 |      Parameters
 |      ----------
 |      img : ``spatialimage`` instance
 |         In fact, an object with the API of ``spatialimage`` -
 |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
 |      
 |      Returns
 |      -------
 |      cimg : ``spatialimage`` instance
 |         Image, of our own class
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  affine
 |  
 |  slicer
 |      Slicer object that returns cropped and subsampled images
 |      
 |      The image is resliced in the current orientation; no rotation or
 |      resampling is performed, and no attempt is made to filter the image
 |      to avoid `aliasing`_.
 |      
 |      The affine matrix is updated with the new intercept (and scales, if
 |      down-sampling is used), so that all values are found at the same RAS
 |      locations.
 |      
 |      Slicing may include non-spatial dimensions.
 |      However, this method does not currently adjust the repetition time in
 |      the image header.
 |      
 |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
 |  
 |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
 |      Slicing interface that returns a new image with an updated affine
 |      
 |      Checks that an image's first three axes are spatial
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  get_data(self, caching='fill')
 |      Return image data from image with any necessary scaling applied
 |      
 |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
 |      
 |      * deprecated from version: 3.0
 |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
 |  
 |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
 |      Return floating point image data with necessary scaling applied
 |      
 |      The image ``dataobj`` property can be an array proxy or an array.  An
 |      array proxy is an object that knows how to load the image data from
 |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
 |      image with an array in ``dataobj`` is an *array image*.
 |      
 |      The default behavior for ``get_fdata()`` on a proxy image is to read
 |      the data from the proxy, and store in an internal cache.  Future calls
 |      to ``get_fdata`` will return the cached array.  This is the behavior
 |      selected with `caching` == "fill".
 |      
 |      Once the data has been cached and returned from an array proxy, if you
 |      modify the returned array, you will also modify the cached array
 |      (because they are the same array).  Regardless of the `caching` flag,
 |      this is always true of an array image.
 |      
 |      Parameters
 |      ----------
 |      caching : {'fill', 'unchanged'}, optional
 |          See the Notes section for a detailed explanation.  This argument
 |          specifies whether the image object should fill in an internal
 |          cached reference to the returned image data array. "fill" specifies
 |          that the image should fill an internal cached reference if
 |          currently empty.  Future calls to ``get_fdata`` will return this
 |          cached reference.  You might prefer "fill" to save the image object
 |          from having to reload the array data from disk on each call to
 |          ``get_fdata``.  "unchanged" means that the image should not fill in
 |          the internal cached reference if the cache is currently empty.  You
 |          might prefer "unchanged" to "fill" if you want to make sure that
 |          the call to ``get_fdata`` does not create an extra (cached)
 |          reference to the returned array.  In this case it is easier for
 |          Python to free the memory from the returned array.
 |      dtype : numpy dtype specifier
 |          A numpy dtype specifier specifying a floating point type.  Data is
 |          returned as this floating point type.  Default is ``np.float64``.
 |      
 |      Returns
 |      -------
 |      fdata : array
 |          Array of image data of data type `dtype`.
 |      
 |      See also
 |      --------
 |      uncache: empty the array data cache
 |      
 |      Notes
 |      -----
 |      All images have a property ``dataobj`` that represents the image array
 |      data.  Images that have been loaded from files usually do not load the
 |      array data from file immediately, in order to reduce image load time
 |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
 |      object that knows how to load the image array data from file.
 |      
 |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
 |      proxy image, we load the array data from disk, store (cache) an
 |      internal reference to this array data, and return the array.  The next
 |      time you call ``get_fdata``, you will get the cached reference to the
 |      array, so we don't have to load the array data from disk again.
 |      
 |      Array images have a ``dataobj`` property that already refers to an
 |      array in memory, so there is no benefit to caching, and the `caching`
 |      keywords have no effect.
 |      
 |      For proxy images, you may not want to fill the cache after reading the
 |      data from disk because the cache will hold onto the array memory until
 |      the image object is deleted, or you use the image ``uncache`` method.
 |      If you don't want to fill the cache, then always use
 |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
 |      fill the cache (store the reference to the array) if the cache is empty
 |      (no reference to the array).  If the cache is full, "unchanged" leaves
 |      the cache full and returns the cached array reference.
 |      
 |      The cache can effect the behavior of the image, because if the cache is
 |      full, or you have an array image, then modifying the returned array
 |      will modify the result of future calls to ``get_fdata()``.  For example
 |      you might do this:
 |      
 |      >>> import os
 |      >>> import nibabel as nib
 |      >>> from nibabel.testing import data_path
 |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
 |      
 |      >>> img = nib.load(img_fname) # This is a proxy image
 |      >>> nib.is_proxy(img.dataobj)
 |      True
 |      
 |      The array is not yet cached by a call to "get_fdata", so:
 |      
 |      >>> img.in_memory
 |      False
 |      
 |      After we call ``get_fdata`` using the default `caching` == 'fill', the
 |      cache contains a reference to the returned array ``data``:
 |      
 |      >>> data = img.get_fdata()
 |      >>> img.in_memory
 |      True
 |      
 |      We modify an element in the returned data array:
 |      
 |      >>> data[0, 0, 0, 0]
 |      0.0
 |      >>> data[0, 0, 0, 0] = 99
 |      >>> data[0, 0, 0, 0]
 |      99.0
 |      
 |      The next time we call 'get_fdata', the method returns the cached
 |      reference to the (modified) array:
 |      
 |      >>> data_again = img.get_fdata()
 |      >>> data_again is data
 |      True
 |      >>> data_again[0, 0, 0, 0]
 |      99.0
 |      
 |      If you had *initially* used `caching` == 'unchanged' then the returned
 |      ``data`` array would have been loaded from file, but not cached, and:
 |      
 |      >>> img = nib.load(img_fname)  # a proxy image again
 |      >>> data = img.get_fdata(caching='unchanged')
 |      >>> img.in_memory
 |      False
 |      >>> data[0, 0, 0] = 99
 |      >>> data_again = img.get_fdata(caching='unchanged')
 |      >>> data_again is data
 |      False
 |      >>> data_again[0, 0, 0, 0]
 |      0.0
 |  
 |  uncache(self) -> 'None'
 |      Delete any cached read of data from proxied data
 |      
 |      Remember there are two types of images:
 |      
 |      * *array images* where the data ``img.dataobj`` is an array
 |      * *proxy images* where the data ``img.dataobj`` is a proxy object
 |      
 |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
 |      from the proxy gets cached inside the image object, and this cache is
 |      what gets returned from the next call to ``img.get_fdata()``.  If you
 |      modify the returned data, as in::
 |      
 |          data = img.get_fdata()
 |          data[:] = 42
 |      
 |      then the next call to ``img.get_fdata()`` returns the modified array,
 |      whether the image is an array image or a proxy image::
 |      
 |          assert np.all(img.get_fdata() == 42)
 |      
 |      When you uncache an array image, this has no effect on the return of
 |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
 |      ``img.get_fdata()`` returns to its original value.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
 |      Class method to create image from filename `filename`
 |      
 |      Parameters
 |      ----------
 |      filename : str
 |          Filename of image to load
 |      mmap : {True, False, 'c', 'r'}, optional, keyword only
 |          `mmap` controls the use of numpy memory mapping for reading image
 |          array data.  If False, do not try numpy ``memmap`` for data array.
 |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
 |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
 |          image data file cannot be memory-mapped, ignore `mmap` value and
 |          read array from file.
 |      keep_file_open : { None, True, False }, optional, keyword only
 |          `keep_file_open` controls whether a new file handle is created
 |          every time the image is accessed, or a single file handle is
 |          created and used for the lifetime of this ``ArrayProxy``. If
 |          ``True``, a single file handle is created and used. If ``False``,
 |          a new file handle is created every time the image is accessed.
 |          The default value (``None``) will result in the value of
 |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
 |      
 |      Returns
 |      -------
 |      img : DataobjImage instance
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
 |  
 |  dataobj
 |  
 |  in_memory
 |      True when any array data is in memory cache
 |      
 |      There are separate caches for `get_data` reads and `get_fdata` reads.
 |      This property is True if either of those caches are set.
 |  
 |  ndim
 |  
 |  shape
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  get_filename(self) -> 'str | None'
 |      Fetch the image filename
 |      
 |      Parameters
 |      ----------
 |      None
 |      
 |      Returns
 |      -------
 |      fname : None or str
 |         Returns None if there is no filename, or a filename string.
 |         If an image may have several filenames associated with it (e.g.
 |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
 |         filename (the ``.img`` filename in the case of Analyze')
 |  
 |  set_filename(self, filename: 'str') -> 'None'
 |      Sets the files in the object from a given filename
 |      
 |      The different image formats may check whether the filename has
 |      an extension characteristic of the format, and raise an error if
 |      not.
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         If the image format only has one file associated with it,
 |         this will be the only filename set into the image
 |         ``.file_map`` attribute. Otherwise, the image instance will
 |         try and guess the other filenames from this given filename.
 |  
 |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
 |      Write image to files implied by filename string
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |         filename to which to save image.  We will parse `filename`
 |         with ``filespec_to_file_map`` to work out names for image,
 |         header etc.
 |      \*\*kwargs : keyword arguments
 |         Keyword arguments to format-specific save
 |      
 |      Returns
 |      -------
 |      None
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
 |      Make `file_map` for this class from filename `filespec`
 |      
 |      Class method
 |      
 |      Parameters
 |      ----------
 |      filespec : str or os.PathLike
 |          Filename that might be for this image file type.
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |          `file_map` dict with (key, value) pairs of (``file_type``,
 |          FileHolder instance), where ``file_type`` is a string giving the
 |          type of the contained file.
 |      
 |      Raises
 |      ------
 |      ImageFileError
 |          if `filespec` is not recognizable as being a filename for this
 |          image type.
 |  
 |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
 |      Save `img` in our own format, to name implied by `filename`
 |      
 |      This is a class method
 |      
 |      Parameters
 |      ----------
 |      img : ``any FileBasedImage`` instance
 |      
 |      filename : str
 |         Filename, implying name to which to save image.
 |  
 |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
 |      Class method to make files holder for this image type
 |      
 |      Parameters
 |      ----------
 |      mapping : None or mapping, optional
 |         mapping with keys corresponding to image file types (such as
 |         'image', 'header' etc, depending on image class) and values
 |         that are filenames or file-like.  Default is None
 |      
 |      Returns
 |      -------
 |      file_map : dict
 |         dict with string keys given by first entry in tuples in
 |         sequence klass.files_types, and values of type FileHolder,
 |         where FileHolder objects have default values, other than
 |         those given by `mapping`
 |  
 |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
 |      Return True if `filename` may be image matching this class
 |      
 |      Parameters
 |      ----------
 |      filename : str or os.PathLike
 |          Filename for an image, or an image header (metadata) file.
 |          If `filename` points to an image data file, and the image type has
 |          a separate "header" file, we work out the name of the header file,
 |          and read from that instead of `filename`.
 |      sniff : None or (bytes, filename), optional
 |          Bytes content read from a previous call to this method, on another
 |          class, with metadata filename.  This allows us to read metadata
 |          bytes once from the image or header, and pass this read set of
 |          bytes to other image classes, therefore saving a repeat read of the
 |          metadata.  `filename` is used to validate that metadata would be
 |          read from the same file, re-reading if not.  None forces this
 |          method to read the metadata.
 |      sniff_max : int, optional
 |          The maximum number of bytes to read from the metadata.  If the
 |          metadata file is long enough, we read this many bytes from the
 |          file, otherwise we read to the end of the file.  Longer values
 |          sniff more of the metadata / image file, making it more likely that
 |          the returned sniff will be useful for later calls to
 |          ``path_maybe_image`` for other image classes.
 |      
 |      Returns
 |      -------
 |      maybe_image : bool
 |          True if `filename` may be valid for an image of this class.
 |      sniff : None or (bytes, filename)
 |          Read bytes content from found metadata.  May be None if the file
 |          does not appear to have useful metadata.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  header
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
&&&&&&&&&&&&&&&&&&&&&&&&& aff2axcodes &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function aff2axcodes in module nibabel.orientations:

aff2axcodes(aff, labels=None, tol=None)
    axis direction codes for affine `aff`
    
    Parameters
    ----------
    aff : (N,M) array-like
        affine transformation matrix
    labels : optional, None or sequence of (2,) sequences
        Labels for negative and positive ends of output axes of `aff`.  See
        docstring for ``ornt2axcodes`` for more detail
    tol : None or float
        Tolerance for SVD of affine - see ``io_orientation`` for more detail.
    
    Returns
    -------
    axcodes : (N,) tuple
        labels for positive end of voxel axes.  Dropped axes get a label of
        None.
    
    Examples
    --------
    >>> aff = [[0,1,0,10],[-1,0,0,20],[0,0,1,30],[0,0,0,1]]
    >>> aff2axcodes(aff, (('L','R'),('B','F'),('D','U')))
    ('B', 'R', 'U')

None
&&&&&&&&&&&&&&&&&&&&&&&&& affines &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.affines in nibabel:

NAME
    nibabel.affines - Utility routines for working with points and affine transforms

CLASSES
    builtins.ValueError(builtins.Exception)
        AffineError
    
    class AffineError(builtins.ValueError)
     |  Errors in calculating or using affines
     |  
     |  Method resolution order:
     |      AffineError
     |      builtins.ValueError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ValueError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.ValueError:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    append_diag(aff, steps, starts=())
        Add diagonal elements `steps` and translations `starts` to affine
        
        Typical use is in expanding 4x4 affines to larger dimensions.  Nipy is the
        main consumer because it uses NxM affines, whereas we generally only use
        4x4 affines; the routine is here for convenience.
        
        Parameters
        ----------
        aff : 2D array
            N by M affine matrix
        steps : scalar or sequence
            diagonal elements to append.
        starts : scalar or sequence
            elements to append to last column of `aff`, representing translations
            corresponding to the `steps`. If empty, expands to a vector of zeros
            of the same length as `steps`
        
        Returns
        -------
        aff_plus : 2D array
            Now P by Q where L = ``len(steps)`` and P == N+L, Q=N+L
        
        Examples
        --------
        >>> aff = np.eye(4)
        >>> aff[:3,:3] = np.arange(9).reshape((3,3))
        >>> append_diag(aff, [9, 10], [99,100])
        array([[  0.,   1.,   2.,   0.,   0.,   0.],
               [  3.,   4.,   5.,   0.,   0.,   0.],
               [  6.,   7.,   8.,   0.,   0.,   0.],
               [  0.,   0.,   0.,   9.,   0.,  99.],
               [  0.,   0.,   0.,   0.,  10., 100.],
               [  0.,   0.,   0.,   0.,   0.,   1.]])
    
    apply_affine(aff, pts, inplace=False)
        Apply affine matrix `aff` to points `pts`
        
        Returns result of application of `aff` to the *right* of `pts`.  The
        coordinate dimension of `pts` should be the last.
        
        For the 3D case, `aff` will be shape (4,4) and `pts` will have final axis
        length 3 - maybe it will just be N by 3. The return value is the
        transformed points, in this case::
        
            res = np.dot(aff[:3,:3], pts.T) + aff[:3,3:4]
            transformed_pts = res.T
        
        This routine is more general than 3D, in that `aff` can have any shape
        (N,N), and `pts` can have any shape, as long as the last dimension is for
        the coordinates, and is therefore length N-1.
        
        Parameters
        ----------
        aff : (N, N) array-like
            Homogeneous affine, for 3D points, will be 4 by 4. Contrary to first
            appearance, the affine will be applied on the left of `pts`.
        pts : (..., N-1) array-like
            Points, where the last dimension contains the coordinates of each
            point.  For 3D, the last dimension will be length 3.
        inplace : bool, optional
            If True, attempt to apply the affine directly to ``pts``.
            If False, or in-place application fails, a freshly allocated
            array will be returned.
        
        Returns
        -------
        transformed_pts : (..., N-1) array
            transformed points
        
        Examples
        --------
        >>> aff = np.array([[0,2,0,10],[3,0,0,11],[0,0,4,12],[0,0,0,1]])
        >>> pts = np.array([[1,2,3],[2,3,4],[4,5,6],[6,7,8]])
        >>> apply_affine(aff, pts) #doctest: +ELLIPSIS
        array([[14, 14, 24],
               [16, 17, 28],
               [20, 23, 36],
               [24, 29, 44]]...)
        
        Just to show that in the simple 3D case, it is equivalent to:
        
        >>> (np.dot(aff[:3,:3], pts.T) + aff[:3,3:4]).T #doctest: +ELLIPSIS
        array([[14, 14, 24],
               [16, 17, 28],
               [20, 23, 36],
               [24, 29, 44]]...)
        
        But `pts` can be a more complicated shape:
        
        >>> pts = pts.reshape((2,2,3))
        >>> apply_affine(aff, pts) #doctest: +ELLIPSIS
        array([[[14, 14, 24],
                [16, 17, 28]],
        <BLANKLINE>
               [[20, 23, 36],
                [24, 29, 44]]]...)
    
    dot_reduce(*args)
        Apply numpy dot product function from right to left on arrays
        
        For passed arrays :math:`A, B, C, ... Z` returns :math:`A \dot B \dot C ...
        \dot Z` where "." is the numpy array dot product.
        
        Parameters
        ----------
        \*\*args : arrays
            Arrays that can be passed to numpy ``dot`` function
        
        Returns
        -------
        dot_product : array
            If there are N arguments, result of ``arg[0].dot(arg[1].dot(arg[2].dot
            ...  arg[N-2].dot(arg[N-1])))...``
    
    from_matvec(matrix, vector=None)
        Combine a matrix and vector into an homogeneous affine
        
        Combine a rotation / scaling / shearing matrix and translation vector into
        a transform in homogeneous coordinates.
        
        Parameters
        ----------
        matrix : array-like
            An NxM array representing the the linear part of the transform.
            A transform from an M-dimensional space to an N-dimensional space.
        vector : None or array-like, optional
            None or an (N,) array representing the translation. None corresponds to
            an (N,) array of zeros.
        
        Returns
        -------
        xform : array
            An (N+1, M+1) homogeneous transform matrix.
        
        See Also
        --------
        to_matvec
        
        Examples
        --------
        >>> from_matvec(np.diag([2, 3, 4]), [9, 10, 11])
        array([[ 2,  0,  0,  9],
               [ 0,  3,  0, 10],
               [ 0,  0,  4, 11],
               [ 0,  0,  0,  1]])
        
        The `vector` argument is optional:
        
        >>> from_matvec(np.diag([2, 3, 4]))
        array([[2, 0, 0, 0],
               [0, 3, 0, 0],
               [0, 0, 4, 0],
               [0, 0, 0, 1]])
    
    obliquity(affine)
        Estimate the *obliquity* an affine's axes represent
        
        The term *obliquity* is defined here as the rotation of those axes with
        respect to the cardinal axes.
        This implementation is inspired by `AFNI's implementation
        <https://github.com/afni/afni/blob/b6a9f7a21c1f3231ff09efbd861f8975ad48e525/src/thd_coords.c#L660-L698>`_.
        For further details about *obliquity*, check `AFNI's documentation
        <https://sscc.nimh.nih.gov/sscc/dglen/Obliquity>`_.
        
        Parameters
        ----------
        affine : 2D array-like
            Affine transformation array.  Usually shape (4, 4), but can be any 2D
            array.
        
        Returns
        -------
        angles : 1D array-like
            The *obliquity* of each axis with respect to the cardinal axes, in radians.
    
    reduce(...)
        reduce(function, sequence[, initial]) -> value
        
        Apply a function of two arguments cumulatively to the items of a sequence,
        from left to right, so as to reduce the sequence to a single value.
        For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
        ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
        of the sequence in the calculation, and serves as a default when the
        sequence is empty.
    
    rescale_affine(affine, shape, zooms, new_shape=None)
        Return a new affine matrix with updated voxel sizes (zooms)
        
        This function preserves the rotations and shears of the original
        affine, as well as the RAS location of the central voxel of the
        image.
        
        Parameters
        ----------
        affine : (N, N) array-like
            NxN transform matrix in homogeneous coordinates representing an affine
            transformation from an (N-1)-dimensional space to an (N-1)-dimensional
            space. An example is a 4x4 transform representing rotations and
            translations in 3 dimensions.
        shape : (N-1,) array-like
            The extent of the (N-1) dimensions of the original space
        zooms : (N-1,) array-like
            The size of voxels of the output affine
        new_shape : (N-1,) array-like, optional
            The extent of the (N-1) dimensions of the space described by the
            new affine. If ``None``, use ``shape``.
        
        Returns
        -------
        affine : (N, N) array
            A new affine transform with the specified voxel sizes
    
    to_matvec(transform)
        Split a transform into its matrix and vector components
        
        The transformation must be represented in homogeneous coordinates and is
        split into its rotation matrix and translation vector components.
        
        Parameters
        ----------
        transform : array-like
            NxM transform matrix in homogeneous coordinates representing an affine
            transformation from an (N-1)-dimensional space to an (M-1)-dimensional
            space. An example is a 4x4 transform representing rotations and
            translations in 3 dimensions. A 4x3 matrix can represent a
            2-dimensional plane embedded in 3 dimensional space.
        
        Returns
        -------
        matrix : (N-1, M-1) array
            Matrix component of `transform`
        vector : (M-1,) array
            Vector component of `transform`
        
        See Also
        --------
        from_matvec
        
        Examples
        --------
        >>> aff = np.diag([2, 3, 4, 1])
        >>> aff[:3,3] = [9, 10, 11]
        >>> to_matvec(aff)
        (array([[2, 0, 0],
               [0, 3, 0],
               [0, 0, 4]]), array([ 9, 10, 11]))
    
    voxel_sizes(affine)
        Return voxel size for each input axis given `affine`
        
        The `affine` is the mapping between array (voxel) coordinates and mm
        (world) coordinates.
        
        The voxel size for the first voxel (array) axis is the distance moved in
        world coordinates when moving one unit along the first voxel (array) axis.
        This is the distance between the world coordinate of voxel (0, 0, 0) and
        the world coordinate of voxel (1, 0, 0).  The world coordinate vector of
        voxel coordinate vector (0, 0, 0) is given by ``v0 = affine.dot((0, 0, 0,
        1)[:3]``.  The world coordinate vector of voxel vector (1, 0, 0) is
        ``v1_ax1 = affine.dot((1, 0, 0, 1))[:3]``.  The final 1 in the voxel
        vectors and the ``[:3]`` at the end are because the affine works on
        homogeneous coordinates.  The translations part of the affine is ``trans =
        affine[:3, 3]``, and the rotations, zooms and shearing part of the affine
        is ``rzs = affine[:3, :3]``. Because of the final 1 in the input voxel
        vector, ``v0 == rzs.dot((0, 0, 0)) + trans``, and ``v1_ax1 == rzs.dot((1,
        0, 0)) + trans``, and the difference vector is ``rzs.dot((0, 0, 0)) -
        rzs.dot((1, 0, 0)) == rzs.dot((1, 0, 0)) == rzs[:, 0]``.  The distance
        vectors in world coordinates between (0, 0, 0) and (1, 0, 0), (0, 1, 0),
        (0, 0, 1) are given by ``rzs.dot(np.eye(3)) = rzs``.  The voxel sizes are
        the Euclidean lengths of the distance vectors.  So, the voxel sizes are
        the Euclidean lengths of the columns of the affine (excluding the last row
        and column of the affine).
        
        Parameters
        ----------
        affine : 2D array-like
            Affine transformation array.  Usually shape (4, 4), but can be any 2D
            array.
        
        Returns
        -------
        vox_sizes : 1D array
            Voxel sizes for each input axis of affine.  Usually 1D array length 3,
            but in general has length (N-1) where input `affine` is shape (M, N).

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/affines.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& all_image_classes &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on list object:

class list(object)
 |  list(iterable=(), /)
 |  
 |  Built-in mutable sequence.
 |  
 |  If no argument is given, the constructor creates a new empty list.
 |  The argument must be an iterable if specified.
 |  
 |  Methods defined here:
 |  
 |  __add__(self, value, /)
 |      Return self+value.
 |  
 |  __contains__(self, key, /)
 |      Return key in self.
 |  
 |  __delitem__(self, key, /)
 |      Delete self[key].
 |  
 |  __eq__(self, value, /)
 |      Return self==value.
 |  
 |  __ge__(self, value, /)
 |      Return self>=value.
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __getitem__(...)
 |      x.__getitem__(y) <==> x[y]
 |  
 |  __gt__(self, value, /)
 |      Return self>value.
 |  
 |  __iadd__(self, value, /)
 |      Implement self+=value.
 |  
 |  __imul__(self, value, /)
 |      Implement self*=value.
 |  
 |  __init__(self, /, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __iter__(self, /)
 |      Implement iter(self).
 |  
 |  __le__(self, value, /)
 |      Return self<=value.
 |  
 |  __len__(self, /)
 |      Return len(self).
 |  
 |  __lt__(self, value, /)
 |      Return self<value.
 |  
 |  __mul__(self, value, /)
 |      Return self*value.
 |  
 |  __ne__(self, value, /)
 |      Return self!=value.
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __reversed__(self, /)
 |      Return a reverse iterator over the list.
 |  
 |  __rmul__(self, value, /)
 |      Return value*self.
 |  
 |  __setitem__(self, key, value, /)
 |      Set self[key] to value.
 |  
 |  __sizeof__(self, /)
 |      Return the size of the list in memory, in bytes.
 |  
 |  append(self, object, /)
 |      Append object to the end of the list.
 |  
 |  clear(self, /)
 |      Remove all items from list.
 |  
 |  copy(self, /)
 |      Return a shallow copy of the list.
 |  
 |  count(self, value, /)
 |      Return number of occurrences of value.
 |  
 |  extend(self, iterable, /)
 |      Extend list by appending elements from the iterable.
 |  
 |  index(self, value, start=0, stop=9223372036854775807, /)
 |      Return first index of value.
 |      
 |      Raises ValueError if the value is not present.
 |  
 |  insert(self, index, object, /)
 |      Insert object before index.
 |  
 |  pop(self, index=-1, /)
 |      Remove and return item at index (default last).
 |      
 |      Raises IndexError if list is empty or index is out of range.
 |  
 |  remove(self, value, /)
 |      Remove first occurrence of value.
 |      
 |      Raises ValueError if the value is not present.
 |  
 |  reverse(self, /)
 |      Reverse *IN PLACE*.
 |  
 |  sort(self, /, *, key=None, reverse=False)
 |      Sort the list in ascending order and return None.
 |      
 |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
 |      order of two equal elements is maintained).
 |      
 |      If a key function is given, apply it once to each list item and sort them,
 |      ascending or descending, according to their function values.
 |      
 |      The reverse flag can be set to sort in descending order.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  __class_getitem__(...) from builtins.type
 |      See PEP 585
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

None
&&&&&&&&&&&&&&&&&&&&&&&&& ana &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.analyze in nibabel:

NAME
    nibabel.analyze - Read / write access to the basic Mayo Analyze format

DESCRIPTION
    ===========================
     The Analyze header format
    ===========================
    
    This is a binary header format and inherits from ``WrapStruct``
    
    Apart from the attributes and methods of WrapStruct:
    
    Class attributes are::
    
        .default_x_flip
    
    with methods::
    
        .get/set_data_shape
        .get/set_data_dtype
        .get/set_zooms
        .get/set_data_offset
        .get_base_affine()
        .get_best_affine()
        .data_to_fileobj
        .data_from_fileobj
    
    and class methods::
    
        .from_header(hdr)
    
    More sophisticated headers can add more methods and attributes.
    
    Notes
    -----
    
    This - basic - analyze header cannot encode full affines (only
    diagonal affines), and cannot do integer scaling.
    
    The inability to store affines means that we have to guess what orientation the
    image has.  Most Analyze images are stored on disk in (fastest-changing to
    slowest-changing) R->L, P->A and I->S order.  That is, the first voxel is the
    rightmost, most posterior and most inferior voxel location in the image, and
    the next voxel is one voxel towards the left of the image.
    
    Most people refer to this disk storage format as 'radiological', on the basis
    that, if you load up the data as an array ``img_arr`` where the first axis is
    the fastest changing, then take a slice in the I->S axis - ``img_arr[:,:,10]``
    - then the right part of the brain will be on the left of your displayed slice.
    Radiologists like looking at images where the left of the brain is on the right
    side of the image.
    
    Conversely, if the image has the voxels stored with the left voxels first -
    L->R, P->A, I->S, then this would be 'neurological' format.  Neurologists like
    looking at images where the left side of the brain is on the left of the image.
    
    When we are guessing at an affine for Analyze, this translates to the problem
    of whether the affine should consider proceeding within the data down an X line
    as being from left to right, or right to left.
    
    By default we assume that the image is stored in R->L format.  We encode this
    choice in the ``default_x_flip`` flag that can be True or False.  True means
    assume radiological.
    
    If the image is 3D, and the X, Y and Z zooms are x, y, and z, then::
    
        if default_x_flip is True::
            affine = np.diag((-x,y,z,1))
        else:
            affine = np.diag((x,y,z,1))
    
    In our implementation, there is no way of saving this assumed flip into the
    header.  One way of doing this, that we have not used, is to allow negative
    zooms, in particular, negative X zooms.  We did not do this because the image
    can be loaded with and without a default flip, so the saved zoom will not
    constrain the affine.

CLASSES
    nibabel.spatialimages.SpatialHeader(nibabel.filebasedimages.FileBasedHeader, nibabel.spatialimages.SpatialProtocol)
        AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
    nibabel.spatialimages.SpatialImage(nibabel.dataobj_images.DataobjImage)
        AnalyzeImage
    nibabel.wrapstruct.LabeledWrapStruct(nibabel.wrapstruct.WrapStruct)
        AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
    
    class AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
     |  AnalyzeHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Class for basic analyze header
     |  
     |  Implements zoom-only setting of affine transform, and no image
     |  scaling
     |  
     |  Method resolution order:
     |      AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize header from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into header.  By default, None, in
     |          which case we insert the default empty header block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of header in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> hdr1 = AnalyzeHeader() # an empty header
     |      >>> hdr1.endianness == native_code
     |      True
     |      >>> hdr1.get_data_shape()
     |      (0,)
     |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
     |      >>> hdr1.get_data_shape()
     |      (1, 2, 3)
     |      
     |      We can set the binary block directly via this initialization.
     |      Here we get it from the header we have just made
     |      
     |      >>> binblock2 = hdr1.binaryblock
     |      >>> hdr2 = AnalyzeHeader(binblock2)
     |      >>> hdr2.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Empty headers are native endian by default
     |      
     |      >>> hdr2.endianness == native_code
     |      True
     |      
     |      You can pass valid opposite endian headers with the
     |      ``endianness`` parameter. Even empty headers can have
     |      endianness
     |      
     |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
     |      >>> hdr3.endianness == swapped_code
     |      True
     |      
     |      If you do not pass an endianness, and you pass some data, we
     |      will try to guess from the passed data.
     |      
     |      >>> binblock3 = hdr3.binaryblock
     |      >>> hdr4 = AnalyzeHeader(binblock3)
     |      >>> hdr4.endianness == swapped_code
     |      True
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_best_affine = get_base_affine(self)
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |  
     |  get_slope_inter(self)
     |      Get scalefactor and intercept
     |      
     |      These are not implemented for basic Analyze
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      In this case, for Analyze images, we can't store the slope or the
     |      intercept, so this method only checks that `slope` is None or NaN or
     |      1.0, and that `inter` is None or NaN or 0.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |          If float, value must be NaN or 1.0 or we raise a ``HeaderTypeError``
     |      inter : None or float, optional
     |          If float, value must be 0.0 or we raise a ``HeaderTypeError``
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Return header data for empty header with given endianness
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  default_x_flip = True
     |  
     |  has_data_intercept = False
     |  
     |  has_data_slope = False
     |  
     |  sizeof_hdr = 348
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class AnalyzeImage(nibabel.spatialimages.SpatialImage)
     |  AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for basic Analyze format image
     |  
     |  Method resolution order:
     |      AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_data_dtype(self)
     |  
     |  set_data_dtype(self, dtype)
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |      dtype : dtype-like, optional
     |         The on-disk data type to coerce the data array.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  __annotations__ = {'_compressed_suffixes': 'tuple[str, ...]', 'files_t...
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'))
     |  
     |  header_class = <class 'nibabel.analyze.AnalyzeHeader'>
     |      Class for basic analyze header
     |      
     |      Implements zoom-only setting of affine transform, and no image
     |      scaling
     |  
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    __annotations__ = {'data_history_dtd': 'list[tuple[str, str] | tuple[s...
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    data_history_dtd = [('descrip', 'S80'), ('aux_file', 'S24'), ('orient'...
    data_type_codes = <nibabel.volumeutils.Recoder object>
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...omin...
    header_key_dtd = [('sizeof_hdr', 'i4'), ('data_type', 'S10'), ('db_nam...
    image_dimension_dtd = [('dim', 'i2', (8,)), ('vox_units', 'S4'), ('cal...
    native_code = '<'
    swapped_code = '>'

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/analyze.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& analyze &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.analyze in nibabel:

NAME
    nibabel.analyze - Read / write access to the basic Mayo Analyze format

DESCRIPTION
    ===========================
     The Analyze header format
    ===========================
    
    This is a binary header format and inherits from ``WrapStruct``
    
    Apart from the attributes and methods of WrapStruct:
    
    Class attributes are::
    
        .default_x_flip
    
    with methods::
    
        .get/set_data_shape
        .get/set_data_dtype
        .get/set_zooms
        .get/set_data_offset
        .get_base_affine()
        .get_best_affine()
        .data_to_fileobj
        .data_from_fileobj
    
    and class methods::
    
        .from_header(hdr)
    
    More sophisticated headers can add more methods and attributes.
    
    Notes
    -----
    
    This - basic - analyze header cannot encode full affines (only
    diagonal affines), and cannot do integer scaling.
    
    The inability to store affines means that we have to guess what orientation the
    image has.  Most Analyze images are stored on disk in (fastest-changing to
    slowest-changing) R->L, P->A and I->S order.  That is, the first voxel is the
    rightmost, most posterior and most inferior voxel location in the image, and
    the next voxel is one voxel towards the left of the image.
    
    Most people refer to this disk storage format as 'radiological', on the basis
    that, if you load up the data as an array ``img_arr`` where the first axis is
    the fastest changing, then take a slice in the I->S axis - ``img_arr[:,:,10]``
    - then the right part of the brain will be on the left of your displayed slice.
    Radiologists like looking at images where the left of the brain is on the right
    side of the image.
    
    Conversely, if the image has the voxels stored with the left voxels first -
    L->R, P->A, I->S, then this would be 'neurological' format.  Neurologists like
    looking at images where the left side of the brain is on the left of the image.
    
    When we are guessing at an affine for Analyze, this translates to the problem
    of whether the affine should consider proceeding within the data down an X line
    as being from left to right, or right to left.
    
    By default we assume that the image is stored in R->L format.  We encode this
    choice in the ``default_x_flip`` flag that can be True or False.  True means
    assume radiological.
    
    If the image is 3D, and the X, Y and Z zooms are x, y, and z, then::
    
        if default_x_flip is True::
            affine = np.diag((-x,y,z,1))
        else:
            affine = np.diag((x,y,z,1))
    
    In our implementation, there is no way of saving this assumed flip into the
    header.  One way of doing this, that we have not used, is to allow negative
    zooms, in particular, negative X zooms.  We did not do this because the image
    can be loaded with and without a default flip, so the saved zoom will not
    constrain the affine.

CLASSES
    nibabel.spatialimages.SpatialHeader(nibabel.filebasedimages.FileBasedHeader, nibabel.spatialimages.SpatialProtocol)
        AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
    nibabel.spatialimages.SpatialImage(nibabel.dataobj_images.DataobjImage)
        AnalyzeImage
    nibabel.wrapstruct.LabeledWrapStruct(nibabel.wrapstruct.WrapStruct)
        AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
    
    class AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
     |  AnalyzeHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Class for basic analyze header
     |  
     |  Implements zoom-only setting of affine transform, and no image
     |  scaling
     |  
     |  Method resolution order:
     |      AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize header from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into header.  By default, None, in
     |          which case we insert the default empty header block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of header in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> hdr1 = AnalyzeHeader() # an empty header
     |      >>> hdr1.endianness == native_code
     |      True
     |      >>> hdr1.get_data_shape()
     |      (0,)
     |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
     |      >>> hdr1.get_data_shape()
     |      (1, 2, 3)
     |      
     |      We can set the binary block directly via this initialization.
     |      Here we get it from the header we have just made
     |      
     |      >>> binblock2 = hdr1.binaryblock
     |      >>> hdr2 = AnalyzeHeader(binblock2)
     |      >>> hdr2.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Empty headers are native endian by default
     |      
     |      >>> hdr2.endianness == native_code
     |      True
     |      
     |      You can pass valid opposite endian headers with the
     |      ``endianness`` parameter. Even empty headers can have
     |      endianness
     |      
     |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
     |      >>> hdr3.endianness == swapped_code
     |      True
     |      
     |      If you do not pass an endianness, and you pass some data, we
     |      will try to guess from the passed data.
     |      
     |      >>> binblock3 = hdr3.binaryblock
     |      >>> hdr4 = AnalyzeHeader(binblock3)
     |      >>> hdr4.endianness == swapped_code
     |      True
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_best_affine = get_base_affine(self)
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |  
     |  get_slope_inter(self)
     |      Get scalefactor and intercept
     |      
     |      These are not implemented for basic Analyze
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      In this case, for Analyze images, we can't store the slope or the
     |      intercept, so this method only checks that `slope` is None or NaN or
     |      1.0, and that `inter` is None or NaN or 0.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |          If float, value must be NaN or 1.0 or we raise a ``HeaderTypeError``
     |      inter : None or float, optional
     |          If float, value must be 0.0 or we raise a ``HeaderTypeError``
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Return header data for empty header with given endianness
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  default_x_flip = True
     |  
     |  has_data_intercept = False
     |  
     |  has_data_slope = False
     |  
     |  sizeof_hdr = 348
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class AnalyzeImage(nibabel.spatialimages.SpatialImage)
     |  AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for basic Analyze format image
     |  
     |  Method resolution order:
     |      AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_data_dtype(self)
     |  
     |  set_data_dtype(self, dtype)
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |      dtype : dtype-like, optional
     |         The on-disk data type to coerce the data array.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  __annotations__ = {'_compressed_suffixes': 'tuple[str, ...]', 'files_t...
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'))
     |  
     |  header_class = <class 'nibabel.analyze.AnalyzeHeader'>
     |      Class for basic analyze header
     |      
     |      Implements zoom-only setting of affine transform, and no image
     |      scaling
     |  
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    __annotations__ = {'data_history_dtd': 'list[tuple[str, str] | tuple[s...
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    data_history_dtd = [('descrip', 'S80'), ('aux_file', 'S24'), ('orient'...
    data_type_codes = <nibabel.volumeutils.Recoder object>
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...omin...
    header_key_dtd = [('sizeof_hdr', 'i4'), ('data_type', 'S10'), ('db_nam...
    image_dimension_dtd = [('dim', 'i2', (8,)), ('vox_units', 'S4'), ('cal...
    native_code = '<'
    swapped_code = '>'

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/analyze.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& apply_orientation &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function apply_orientation in module nibabel.orientations:

apply_orientation(arr, ornt)
    Apply transformations implied by `ornt` to the first
    n axes of the array `arr`
    
    Parameters
    ----------
    arr : array-like of data with ndim >= n
    ornt : (n,2) orientation array
       orientation transform. ``ornt[N,1]` is flip of axis N of the
       array implied by `shape`, where 1 means no flip and -1 means
       flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
       there's an array ``arr`` of shape `shape`, the flip would
       correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
       the transpose that needs to be done to the implied array, as in
       ``arr.transpose(ornt[:,0])``
    
    Returns
    -------
    t_arr : ndarray
       data array `arr` transformed according to ornt

None
&&&&&&&&&&&&&&&&&&&&&&&&& arrayproxy &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.arrayproxy in nibabel:

NAME
    nibabel.arrayproxy - Array proxy base class

DESCRIPTION
    The proxy API is - at minimum:
    
    * The object has a read-only attribute ``shape``
    * read only ``is_proxy`` attribute / property set to True
    * the object returns the data array from ``np.asarray(prox)``
    * returns array slice from ``prox[<slice_spec>]`` where ``<slice_spec>`` is any
      ndarray slice specification that does not use numpy 'advanced indexing'.
    * modifying no object outside ``obj`` will affect the result of
      ``np.asarray(obj)``.  Specifically:
    
      * Changes in position (``obj.tell()``) of passed file-like objects will
        not affect the output of from ``np.asarray(proxy)``.
      * if you pass a header into the __init__, then modifying the original
        header will not affect the result of the array return.
    
    See :mod:`nibabel.tests.test_proxy_api` for proxy API conformance checks.

CLASSES
    typing.Protocol(typing.Generic)
        ArrayLike
            ArrayProxy
    
    class ArrayLike(typing.Protocol)
     |  ArrayLike(*args, **kwargs)
     |  
     |  Protocol for numpy ndarray-like objects
     |  
     |  This is more stringent than :class:`numpy.typing.ArrayLike`, but guarantees
     |  access to shape, ndim and slicing.
     |  
     |  Method resolution order:
     |      ArrayLike
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __array__ = _overload_dummy(*args, **kwds)
     |      Helper for @overload to raise when called.
     |  
     |  __getitem__(self, key, /) -> 'npt.NDArray'
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  ndim
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __annotations__ = {'shape': 'tuple[int, ...]'}
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class ArrayProxy(ArrayLike)
     |  ArrayProxy(file_like, spec, *, mmap=True, order=None, keep_file_open=None)
     |  
     |  Class to act as proxy for the array that can be read from a file
     |  
     |  The array proxy allows us to freeze the passed fileobj and header such that
     |  it returns the expected data array.
     |  
     |  This implementation assumes a contiguous array in the file object, with one
     |  of the numpy dtypes, starting at a given file position ``offset`` with
     |  single ``slope`` and ``intercept`` scaling to produce output values.
     |  
     |  The class ``__init__`` requires a spec which defines how the data will be
     |  read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |  shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |  with methods:
     |  
     |  * get_data_shape
     |  * get_data_dtype
     |  * get_data_offset
     |  * get_slope_inter
     |  
     |  A header should also have a 'copy' method.  This requirement will go away
     |  when the deprecated 'header' property goes away.
     |  
     |  This implementation allows us to deal with Analyze and its variants,
     |  including Nifti1, and with the MGH format.
     |  
     |  Other image types might need more specific classes to implement the API.
     |  See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |  examples.
     |  
     |  Method resolution order:
     |      ArrayProxy
     |      ArrayLike
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __array__(self, dtype=None)
     |      Read data from file and apply scaling, casting to ``dtype``
     |      
     |      If ``dtype`` is unspecified, the dtype of the returned array is the
     |      narrowest dtype that can represent the data without overflow.
     |      Generally, it is the wider of the dtypes of the slopes or intercepts.
     |      
     |      The types of the scale factors will generally be determined by the
     |      parameter size in the image header, and so should be consistent for a
     |      given image format, but may vary across formats.
     |      
     |      Parameters
     |      ----------
     |      dtype : numpy dtype specifier, optional
     |          A numpy dtype specifier specifying the type of the returned array.
     |      
     |      Returns
     |      -------
     |      array
     |          Scaled image data with type `dtype`.
     |  
     |  __del__(self)
     |      If this ``ArrayProxy`` was created with ``keep_file_open=True``,
     |      the open file object is closed if necessary.
     |  
     |  __getitem__(self, slicer)
     |  
     |  __getstate__(self)
     |      Returns the state of this ``ArrayProxy`` during pickling.
     |  
     |  __init__(self, file_like, spec, *, mmap=True, order=None, keep_file_open=None)
     |      Initialize array proxy instance
     |      
     |      Parameters
     |      ----------
     |      file_like : object
     |          File-like object or filename. If file-like object, should implement
     |          at least ``read`` and ``seek``.
     |      spec : object or tuple
     |          Tuple must have length 2-5, with the following values:
     |      
     |          #. shape: tuple - tuple of ints describing shape of data;
     |          #. storage_dtype: dtype specifier - dtype of array inside proxied
     |             file, or input to ``numpy.dtype`` to specify array dtype;
     |          #. offset: int - offset, in bytes, of data array from start of file
     |             (default: 0);
     |          #. slope: float - scaling factor for resulting data (default: 1.0);
     |          #. inter: float - intercept for rescaled data (default: 0.0).
     |      
     |          OR
     |      
     |          Header object implementing ``get_data_shape``, ``get_data_dtype``,
     |          ``get_data_offset``, ``get_slope_inter``
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading data.
     |          If False, do not try numpy ``memmap`` for data array.  If one of
     |          {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A `mmap` value of
     |          True gives the same behavior as ``mmap='c'``.  If `file_like`
     |          cannot be memory-mapped, ignore `mmap` value and read array from
     |          file.
     |      order : {None, 'F', 'C'}, optional, keyword only
     |          `order` controls the order of the data array layout. Fortran-style,
     |          column-major order may be indicated with 'F', and C-style, row-major
     |          order may be indicated with 'C'. None gives the default order, that
     |          comes from the `_default_order` class variable.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_like`` is an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``KEEP_FILE_OPEN_DEFAULT`` being used.
     |  
     |  __setstate__(self, state)
     |      Sets the state of this ``ArrayProxy`` during unpickling.
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  copy(self) -> 'Self'
     |      Create a new ArrayProxy for the same file and parameters
     |      
     |      If the proxied file is an open file handle, the new ArrayProxy
     |      will share a lock with the old one.
     |  
     |  get_unscaled(self)
     |      Read data from file
     |      
     |      This is an optional part of the proxy API
     |  
     |  reshape(self, shape)
     |      Return an ArrayProxy with a new shape, without modifying data
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  dtype
     |  
     |  inter
     |  
     |  is_proxy
     |  
     |  ndim
     |  
     |  offset
     |  
     |  shape
     |  
     |  slope
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArrayLike:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ArrayLike:
     |  
     |  __annotations__ = {'shape': 'tuple[int, ...]'}
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta

FUNCTIONS
    get_obj_dtype(obj)
        Get the effective dtype of an array-like object
    
    is_proxy(obj)
        Return True if `obj` is an array proxy
    
    reshape_dataobj(obj, shape)
        Use `obj` reshape method if possible, else numpy reshape function

DATA
    KEEP_FILE_OPEN_DEFAULT = False
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/arrayproxy.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& arraywriters &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.arraywriters in nibabel:

NAME
    nibabel.arraywriters - Array writer objects

DESCRIPTION
    Array writers have init signature::
    
        def __init__(self, array, out_dtype=None)
    
    and methods
    
    * scaling_needed() - returns True if array requires scaling for write
    * finite_range() - returns min, max of self.array
    * to_fileobj(fileobj, offset=None, order='F')
    
    They must have attributes / properties of:
    
    * array
    * out_dtype
    * has_nan
    
    They may have attributes:
    
    * slope
    * inter
    
    They are designed to write arrays to a fileobj with reasonable memory
    efficiency.
    
    Array writers may be able to scale the array or apply an intercept, or do
    something else to make sense of conversions between float and int, or between
    larger ints and smaller.

CLASSES
    builtins.Exception(builtins.BaseException)
        WriterError
            ScalingError
    builtins.object
        ArrayWriter
            SlopeArrayWriter
                SlopeInterArrayWriter
    
    class ArrayWriter(builtins.object)
     |  ArrayWriter(array, out_dtype=None, **kwargs)
     |  
     |  Methods defined here:
     |  
     |  __init__(self, array, out_dtype=None, **kwargs)
     |      Initialize array writer
     |      
     |      Parameters
     |      ----------
     |      array : array-like
     |          array-like object
     |      out_dtype : None or dtype
     |          dtype with which `array` will be written.  For this class,
     |          `out_dtype`` needs to be the same as the dtype of the input `array`
     |          or a swapped version of the same.
     |      \*\*kwargs : keyword arguments
     |          This class processes only:
     |      
     |          * nan2zero : bool, optional
     |            Whether to set NaN values to 0 when writing integer output.
     |            Defaults to True.  If False, NaNs get converted with numpy
     |            ``astype``, and the behavior is undefined.  Ignored for floating
     |            point output.
     |          * check_scaling : bool, optional
     |            If True, check if scaling needed and raise error if so. Default
     |            is True
     |      
     |      Examples
     |      --------
     |      >>> arr = np.array([0, 255], np.uint8)
     |      >>> aw = ArrayWriter(arr)
     |      >>> aw = ArrayWriter(arr, np.int8) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      WriterError: Scaling needed but cannot scale
     |      >>> aw = ArrayWriter(arr, np.int8, check_scaling=False)
     |  
     |  finite_range(self)
     |      Return (maybe cached) finite range of data array
     |  
     |  scaling_needed(self)
     |      Checks if scaling is needed for input array
     |      
     |      Raises WriterError if no scaling possible.
     |      
     |      The rules are in the code, but:
     |      
     |      * If numpy will cast, return False (no scaling needed)
     |      * If input or output is an object or structured type, raise
     |      * If input is complex, raise
     |      * If the output is float, return False
     |      * If the input array is all zero, return False
     |      * By now we are casting to (u)int. If the input type is a float, return
     |        True (we do need scaling)
     |      * Now input and output types are (u)ints. If the min and max in the
     |        data are within range of the output type, return False
     |      * Otherwise return True
     |  
     |  to_fileobj(self, fileobj, order='F')
     |      Write array into `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |      order : {'F', 'C'}
     |          order (Fortran or C) to which to write array
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  array
     |      Return array from arraywriter
     |  
     |  has_nan
     |      True if array has NaNs
     |  
     |  out_dtype
     |      Return `out_dtype` from arraywriter
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ScalingError(WriterError)
     |  Method resolution order:
     |      ScalingError
     |      WriterError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from WriterError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class SlopeArrayWriter(ArrayWriter)
     |  SlopeArrayWriter(array, out_dtype=None, calc_scale=True, scaler_dtype=<class 'numpy.float32'>, **kwargs)
     |  
     |  ArrayWriter that can use scalefactor for writing arrays
     |  
     |  The scalefactor allows the array writer to write floats to int output
     |  types, and rescale larger ints to smaller.  It can therefore lose
     |  precision.
     |  
     |  It extends the ArrayWriter class with attribute:
     |  
     |  * slope
     |  
     |  and methods:
     |  
     |  * reset() - reset slope to default (not adapted to self.array)
     |  * calc_scale() - calculate slope to best write self.array
     |  
     |  Method resolution order:
     |      SlopeArrayWriter
     |      ArrayWriter
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, array, out_dtype=None, calc_scale=True, scaler_dtype=<class 'numpy.float32'>, **kwargs)
     |      Initialize array writer
     |      
     |      Parameters
     |      ----------
     |      array : array-like
     |          array-like object
     |      out_dtype : None or dtype
     |          dtype with which `array` will be written.  For this class,
     |          `out_dtype`` needs to be the same as the dtype of the input `array`
     |          or a swapped version of the same.
     |      calc_scale : {True, False}, optional
     |          Whether to calculate scaling for writing `array` on initialization.
     |          If False, then you can calculate this scaling with
     |          ``obj.calc_scale()`` - see examples
     |      scaler_dtype : dtype-like, optional
     |          specifier for numpy dtype for scaling
     |      \*\*kwargs : keyword arguments
     |          This class processes only:
     |      
     |          * nan2zero : bool, optional
     |            Whether to set NaN values to 0 when writing integer output.
     |            Defaults to True.  If False, NaNs get converted with numpy
     |            ``astype``, and the behavior is undefined.  Ignored for floating
     |            point output.
     |      
     |      Examples
     |      --------
     |      >>> arr = np.array([0, 254], np.uint8)
     |      >>> aw = SlopeArrayWriter(arr)
     |      >>> aw.slope
     |      1.0
     |      >>> aw = SlopeArrayWriter(arr, np.int8)
     |      >>> aw.slope
     |      2.0
     |      >>> aw = SlopeArrayWriter(arr, np.int8, calc_scale=False)
     |      >>> aw.slope
     |      1.0
     |      >>> aw.calc_scale()
     |      >>> aw.slope
     |      2.0
     |  
     |  calc_scale(self, force=False)
     |      Calculate / set scaling for floats/(u)ints to (u)ints
     |  
     |  reset(self)
     |      Set object to values before any scaling calculation
     |  
     |  scaling_needed(self)
     |      Checks if scaling is needed for input array
     |      
     |      Raises WriterError if no scaling possible.
     |      
     |      The rules are in the code, but:
     |      
     |      * If numpy will cast, return False (no scaling needed)
     |      * If input or output is an object or structured type, raise
     |      * If input is complex, raise
     |      * If the output is float, return False
     |      * If the input array is all zero, return False
     |      * If there is no finite value, return False (the writer will strip the
     |        non-finite values)
     |      * By now we are casting to (u)int. If the input type is a float, return
     |        True (we do need scaling)
     |      * Now input and output types are (u)ints. If the min and max in the
     |        data are within range of the output type, return False
     |      * Otherwise return True
     |  
     |  to_fileobj(self, fileobj, order='F')
     |      Write array into `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |      order : {'F', 'C'}
     |          order (Fortran or C) to which to write array
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  slope
     |      get/set slope
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArrayWriter:
     |  
     |  finite_range(self)
     |      Return (maybe cached) finite range of data array
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from ArrayWriter:
     |  
     |  array
     |      Return array from arraywriter
     |  
     |  has_nan
     |      True if array has NaNs
     |  
     |  out_dtype
     |      Return `out_dtype` from arraywriter
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArrayWriter:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class SlopeInterArrayWriter(SlopeArrayWriter)
     |  SlopeInterArrayWriter(array, out_dtype=None, calc_scale=True, scaler_dtype=<class 'numpy.float32'>, **kwargs)
     |  
     |  Array writer that can use slope and intercept to scale array
     |  
     |  The writer can subtract an intercept, and divided by a slope, in order to
     |  be able to convert floating point values into a (u)int range, or to convert
     |  larger (u)ints to smaller.
     |  
     |  It extends the ArrayWriter class with attributes:
     |  
     |  * inter
     |  * slope
     |  
     |  and methods:
     |  
     |  * reset() - reset inter, slope to default (not adapted to self.array)
     |  * calc_scale() - calculate inter, slope to best write self.array
     |  
     |  Method resolution order:
     |      SlopeInterArrayWriter
     |      SlopeArrayWriter
     |      ArrayWriter
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, array, out_dtype=None, calc_scale=True, scaler_dtype=<class 'numpy.float32'>, **kwargs)
     |      Initialize array writer
     |      
     |      Parameters
     |      ----------
     |      array : array-like
     |          array-like object
     |      out_dtype : None or dtype
     |          dtype with which `array` will be written.  For this class,
     |          `out_dtype`` needs to be the same as the dtype of the input `array`
     |          or a swapped version of the same.
     |      calc_scale : {True, False}, optional
     |          Whether to calculate scaling for writing `array` on initialization.
     |          If False, then you can calculate this scaling with
     |          ``obj.calc_scale()`` - see examples
     |      scaler_dtype : dtype-like, optional
     |          specifier for numpy dtype for slope, intercept
     |      \*\*kwargs : keyword arguments
     |          This class processes only:
     |      
     |          * nan2zero : bool, optional
     |            Whether to set NaN values to 0 when writing integer output.
     |            Defaults to True.  If False, NaNs get converted with numpy
     |            ``astype``, and the behavior is undefined.  Ignored for floating
     |            point output.
     |      
     |      Examples
     |      --------
     |      >>> arr = np.array([0, 255], np.uint8)
     |      >>> aw = SlopeInterArrayWriter(arr)
     |      >>> aw.slope, aw.inter
     |      (1.0, 0.0)
     |      >>> aw = SlopeInterArrayWriter(arr, np.int8)
     |      >>> (aw.slope, aw.inter) == (1.0, 128)
     |      True
     |      >>> aw = SlopeInterArrayWriter(arr, np.int8, calc_scale=False)
     |      >>> aw.slope, aw.inter
     |      (1.0, 0.0)
     |      >>> aw.calc_scale()
     |      >>> (aw.slope, aw.inter) == (1.0, 128)
     |      True
     |  
     |  reset(self)
     |      Set object to values before any scaling calculation
     |  
     |  to_fileobj(self, fileobj, order='F')
     |      Write array into `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |      order : {'F', 'C'}
     |          order (Fortran or C) to which to write array
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  inter
     |      get/set inter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from SlopeArrayWriter:
     |  
     |  calc_scale(self, force=False)
     |      Calculate / set scaling for floats/(u)ints to (u)ints
     |  
     |  scaling_needed(self)
     |      Checks if scaling is needed for input array
     |      
     |      Raises WriterError if no scaling possible.
     |      
     |      The rules are in the code, but:
     |      
     |      * If numpy will cast, return False (no scaling needed)
     |      * If input or output is an object or structured type, raise
     |      * If input is complex, raise
     |      * If the output is float, return False
     |      * If the input array is all zero, return False
     |      * If there is no finite value, return False (the writer will strip the
     |        non-finite values)
     |      * By now we are casting to (u)int. If the input type is a float, return
     |        True (we do need scaling)
     |      * Now input and output types are (u)ints. If the min and max in the
     |        data are within range of the output type, return False
     |      * Otherwise return True
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SlopeArrayWriter:
     |  
     |  slope
     |      get/set slope
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArrayWriter:
     |  
     |  finite_range(self)
     |      Return (maybe cached) finite range of data array
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from ArrayWriter:
     |  
     |  array
     |      Return array from arraywriter
     |  
     |  has_nan
     |      True if array has NaNs
     |  
     |  out_dtype
     |      Return `out_dtype` from arraywriter
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArrayWriter:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class WriterError(builtins.Exception)
     |  Method resolution order:
     |      WriterError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    get_slope_inter(writer)
        Return slope, intercept from array writer object
        
        Parameters
        ----------
        writer : ArrayWriter instance
        
        Returns
        -------
        slope : scalar
            slope in `writer` or 1.0 if not present
        inter : scalar
            intercept in `writer` or 0.0 if not present
        
        Examples
        --------
        >>> arr = np.arange(10)
        >>> get_slope_inter(ArrayWriter(arr))
        (1.0, 0.0)
        >>> get_slope_inter(SlopeArrayWriter(arr))
        (1.0, 0.0)
        >>> get_slope_inter(SlopeInterArrayWriter(arr))
        (1.0, 0.0)
    
    make_array_writer(data, out_type, has_slope=True, has_intercept=True, **kwargs)
        Make array writer instance for array `data` and output type `out_type`
        
        Parameters
        ----------
        data : array-like
            array for which to create array writer
        out_type : dtype-like
            input to numpy dtype to specify array writer output type
        has_slope : {True, False}
            If True, array write can use scaling to adapt the array to `out_type`
        has_intercept : {True, False}
            If True, array write can use intercept to adapt the array to `out_type`
        \*\*kwargs : other keyword arguments
            to pass to the arraywriter class
        
        Returns
        -------
        writer : arraywriter instance
            Instance of array writer, with class adapted to `has_intercept` and
            `has_slope`.
        
        Examples
        --------
        >>> aw = make_array_writer(np.arange(10), np.uint8, True, True)
        >>> type(aw) == SlopeInterArrayWriter
        True
        >>> aw = make_array_writer(np.arange(10), np.uint8, True, False)
        >>> type(aw) == SlopeArrayWriter
        True
        >>> aw = make_array_writer(np.arange(10), np.uint8, False, False)
        >>> type(aw) == ArrayWriter
        True

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/arraywriters.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& as_closest_canonical &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function as_closest_canonical in module nibabel.funcs:

as_closest_canonical(img, enforce_diag=False)
    Return `img` with data reordered to be closest to canonical
    
    Canonical order is the ordering of the output axes.
    
    Parameters
    ----------
    img : ``spatialimage``
    enforce_diag : {False, True}, optional
       If True, before transforming image, check if the resulting image
       affine will be close to diagonal, and if not, raise an error
    
    Returns
    -------
    canonical_img : ``spatialimage``
       Version of `img` where the underlying array may have been
       reordered and / or flipped so that axes 0,1,2 are those axes in
       the input data that are, respectively, closest to the output axis
       orientation.  We modify the affine accordingly.  If `img` is
       already has the correct data ordering, we just return `img`
       unmodified.

None
&&&&&&&&&&&&&&&&&&&&&&&&& batteryrunners &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.batteryrunners in nibabel:

NAME
    nibabel.batteryrunners - Battery runner classes and Report classes

DESCRIPTION
    These classes / objects are for generic checking / fixing batteries
    
    The ``BatteryRunner`` class will run a series of checks on a single
    object.
    
    A check is a callable, of signature ``func(obj, fix=False)`` which
    returns a tuple ``(obj, Report)`` for ``func(obj, False)`` or
    ``func(obj, True)``, where the obj may be a modified object, or a
    different object, if ``fix==True``.
    
    To run checks only, and return problem report objects:
    
    >>> from nibabel.batteryrunners import BatteryRunner, Report
    >>> def chk(obj, fix=False): # minimal check
    ...     return obj, Report()
    >>> btrun = BatteryRunner((chk,))
    >>> reports = btrun.check_only('a string')
    
    To run checks and fixes, returning fixed object and problem report
    sequence, with possible fix messages:
    
    >>> fixed_obj, report_seq = btrun.check_fix('a string')
    
    Reports are iterable things, where the elements in the iterations are
    ``Problems``, with attributes ``error``, ``problem_level``,
    ``problem_msg``, and possibly empty ``fix_msg``.  The ``problem_level``
    is an integer, giving the level of problem, from 0 (no problem) to 50
    (very bad problem).  The levels follow the log levels from the logging
    module (e.g 40 equivalent to "error" level, 50 to "critical").  The
    ``error`` can be one of ``None`` if no error to suggest, or an Exception
    class that the user might consider raising for this situation.  The
    ``problem_msg`` and ``fix_msg`` are human readable strings that should
    explain what happened.
    
    =======================
     More about ``checks``
    =======================
    
    Checks are callables returning objects and reports, like ``chk`` below,
    such that::
    
       obj, report = chk(obj, fix=False)
       obj, report = chk(obj, fix=True)
    
    For example, for the Analyze header, we need to check the datatype::
    
        def chk_datatype(hdr, fix=True):
            rep = Report(hdr, HeaderDataError)
            code = int(hdr['datatype'])
            try:
                dtype = AnalyzeHeader._data_type_codes.dtype[code]
            except KeyError:
                rep.problem_level = 40
                rep.problem_msg = 'data code not recognized'
            else:
                if dtype.type is np.void:
                    rep.problem_level = 40
                    rep.problem_msg = 'data code not supported'
                else:
                    return hdr, rep
            if fix:
                rep.fix_problem_msg = 'not attempting fix'
            return hdr, rep
    
    or the bitpix::
    
        def chk_bitpix(hdr, fix=True):
            rep = Report(HeaderDataError)
            code = int(hdr['datatype'])
            try:
                dt = AnalyzeHeader._data_type_codes.dtype[code]
            except KeyError:
                rep.problem_level = 10
                rep.problem_msg = 'no valid datatype to fix bitpix'
                return hdr, rep
            bitpix = dt.itemsize * 8
            if bitpix == hdr['bitpix']:
                return hdr, rep
            rep.problem_level = 10
            rep.problem_msg = 'bitpix does not match datatype')
            if fix:
                hdr['bitpix'] = bitpix # inplace modification
                rep.fix_msg = 'setting bitpix to match datatype'
            return hdr, ret
    
    or the pixdims::
    
        def chk_pixdims(hdr, fix=True):
            rep = Report(hdr, HeaderDataError)
            if not np.any(hdr['pixdim'][1:4] < 0):
                return hdr, rep
            rep.problem_level = 40
            rep.problem_msg = 'pixdim[1,2,3] should be positive'
            if fix:
                hdr['pixdim'][1:4] = np.abs(hdr['pixdim'][1:4])
                rep.fix_msg = 'setting to abs of pixdim values'
            return hdr, rep

CLASSES
    builtins.object
        BatteryRunner
        Report
    
    class BatteryRunner(builtins.object)
     |  BatteryRunner(checks)
     |  
     |  Class to run set of checks
     |  
     |  Methods defined here:
     |  
     |  __init__(self, checks)
     |      Initialize instance from sequence of `checks`
     |      
     |      Parameters
     |      ----------
     |      checks : sequence
     |         sequence of checks, where checks are callables matching
     |         signature ``obj, rep = chk(obj, fix=False)``.  Checks are run
     |         in the order they are passed.
     |      
     |      Examples
     |      --------
     |      >>> def chk(obj, fix=False): # minimal check
     |      ...     return obj, Report()
     |      >>> btrun = BatteryRunner((chk,))
     |  
     |  __len__(self)
     |  
     |  check_fix(self, obj)
     |      Run checks, with fixes, on `obj` returning `obj`, reports
     |      
     |      Parameters
     |      ----------
     |      obj : anything
     |         object on which to run checks, fixes
     |      
     |      Returns
     |      -------
     |      obj : anything
     |         possibly modified or replaced `obj`, after fixes
     |      reports : sequence
     |         sequence of reports on checks, fixes
     |  
     |  check_only(self, obj)
     |      Run checks on `obj` returning reports
     |      
     |      Parameters
     |      ----------
     |      obj : anything
     |         object on which to run checks
     |      
     |      Returns
     |      -------
     |      reports : sequence
     |         sequence of report objects reporting on result of running
     |         checks (without fixes) on `obj`
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Report(builtins.object)
     |  Report(error=<class 'Exception'>, problem_level=0, problem_msg='', fix_msg='')
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      are two BatteryRunner-like objects equal?
     |      
     |      Parameters
     |      ----------
     |      other : object
     |         report-like object to test equality
     |      
     |      Examples
     |      --------
     |      >>> rep = Report(problem_level=10)
     |      >>> rep2 = Report(problem_level=10)
     |      >>> rep == rep2
     |      True
     |      >>> rep3 = Report(problem_level=20)
     |      >>> rep == rep3
     |      False
     |  
     |  __getstate__(self)
     |      State that defines object
     |      
     |      Returns
     |      -------
     |      tup : tuple
     |  
     |  __init__(self, error=<class 'Exception'>, problem_level=0, problem_msg='', fix_msg='')
     |      Initialize report with values
     |      
     |      Parameters
     |      ----------
     |      error : None or Exception
     |         Error to raise if raising error for this check.  If None,
     |         no error can be raised for this check (it was probably
     |         normal).
     |      problem_level : int
     |         level of problem.  From 0 (no problem) to 50 (severe
     |         problem).  If the report originates from a fix, then this
     |         is the level of the problem remaining after the fix.
     |         Default is 0
     |      problem_msg : string
     |         String describing problem detected. Default is ''
     |      fix_msg : string
     |         String describing any fix applied.  Default is ''.
     |      
     |      Examples
     |      --------
     |      >>> rep = Report()
     |      >>> rep.problem_level
     |      0
     |      >>> rep = Report(TypeError, 10)
     |      >>> rep.problem_level
     |      10
     |  
     |  __ne__(self, other)
     |      are two BatteryRunner-like objects not equal?
     |      
     |      See docstring for __eq__
     |  
     |  __str__(self)
     |      Printable string for object
     |  
     |  log_raise(self, logger, error_level=40)
     |      Log problem, raise error if problem >= `error_level`
     |      
     |      Parameters
     |      ----------
     |      logger : log
     |         log object, implementing ``log`` method
     |      error_level : int, optional
     |         If ``self.problem_level`` >= `error_level`, raise error
     |  
     |  write_raise(self, stream, error_level=40, log_level=30)
     |      Write report to `stream`
     |      
     |      Parameters
     |      ----------
     |      stream : file-like
     |         implementing ``write`` method
     |      error_level : int, optional
     |         level at which to raise error for problem detected in
     |         ``self``
     |      log_level : int, optional
     |         Such that if `log_level` is >= ``self.problem_level`` we
     |         write the report to `stream`, otherwise we write nothing.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  message
     |      formatted message string, including fix message if present
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/batteryrunners.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& bench &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function bench in module nibabel:

bench(label=None, verbose=1, extra_argv=None)
    Run benchmarks for nibabel using pytest
    
    The protocol mimics the ``numpy.testing.NoseTester.bench()``.
    Not all features are currently implemented.
    
    Parameters
    ----------
    label : None
        Unused.
    verbose: int, optional
        Verbosity value for test outputs. Positive values increase verbosity, and
        negative values decrease it. Default is 1.
    extra_argv : list, optional
        List with any extra arguments to pass to pytest.
    
    Returns
    -------
    code : ExitCode
        Returns the result of running the tests as a ``pytest.ExitCode`` enum

None
&&&&&&&&&&&&&&&&&&&&&&&&& brikhead &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.brikhead in nibabel:

NAME
    nibabel.brikhead - Class for reading AFNI BRIK/HEAD datasets

DESCRIPTION
    See https://afni.nimh.nih.gov/pub/dist/doc/program_help/README.attributes.html
    for information on what is required to have a valid BRIK/HEAD dataset.
    
    Unless otherwise noted, descriptions AFNI attributes in the code refer to this
    document.
    
    Notes
    -----
    
    In the AFNI HEAD file, the first two values of the attribute DATASET_RANK
    determine the shape of the data array stored in the corresponding BRIK file.
    The first value, DATASET_RANK[0], must be set to 3 denoting a 3D image. The
    second value, DATASET_RANK[1], determines how many "sub-bricks" (in AFNI
    parlance) / volumes there are along the fourth (traditionally, but not
    exclusively) time axis. Thus, DATASET_RANK[1] will (at least as far as I (RM)
    am aware) always be >= 1. This permits sub-brick indexing common in AFNI
    programs (e.g., example4d+orig'[0]').

CLASSES
    nibabel.arrayproxy.ArrayProxy(nibabel.arrayproxy.ArrayLike)
        AFNIArrayProxy
    nibabel.spatialimages.HeaderDataError(builtins.Exception)
        AFNIHeaderError
    nibabel.spatialimages.ImageDataError(builtins.Exception)
        AFNIImageError
    nibabel.spatialimages.SpatialHeader(nibabel.filebasedimages.FileBasedHeader, nibabel.spatialimages.SpatialProtocol)
        AFNIHeader
    nibabel.spatialimages.SpatialImage(nibabel.dataobj_images.DataobjImage)
        AFNIImage
    
    class AFNIArrayProxy(nibabel.arrayproxy.ArrayProxy)
     |  AFNIArrayProxy(file_like, header, *, mmap=True, keep_file_open=None)
     |  
     |  Proxy object for AFNI image array.
     |  
     |  Attributes
     |  ----------
     |  scaling : np.ndarray
     |      Scaling factor (one factor per volume/sub-brick) for data. Default is
     |      None
     |  
     |  Method resolution order:
     |      AFNIArrayProxy
     |      nibabel.arrayproxy.ArrayProxy
     |      nibabel.arrayproxy.ArrayLike
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, file_like, header, *, mmap=True, keep_file_open=None)
     |      Initialize AFNI array proxy
     |      
     |      Parameters
     |      ----------
     |      file_like : file-like object
     |          File-like object or filename. If file-like object, should implement
     |          at least ``read`` and ``seek``.
     |      header : ``AFNIHeader`` object
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading data.
     |          If False, do not try numpy ``memmap`` for data array.  If one of
     |          {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A `mmap` value of
     |          True gives the same behavior as ``mmap='c'``.  If `file_like`
     |          cannot be memory-mapped, ignore `mmap` value and read array from
     |          file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_like`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  scaling
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.arrayproxy.ArrayProxy:
     |  
     |  __array__(self, dtype=None)
     |      Read data from file and apply scaling, casting to ``dtype``
     |      
     |      If ``dtype`` is unspecified, the dtype of the returned array is the
     |      narrowest dtype that can represent the data without overflow.
     |      Generally, it is the wider of the dtypes of the slopes or intercepts.
     |      
     |      The types of the scale factors will generally be determined by the
     |      parameter size in the image header, and so should be consistent for a
     |      given image format, but may vary across formats.
     |      
     |      Parameters
     |      ----------
     |      dtype : numpy dtype specifier, optional
     |          A numpy dtype specifier specifying the type of the returned array.
     |      
     |      Returns
     |      -------
     |      array
     |          Scaled image data with type `dtype`.
     |  
     |  __del__(self)
     |      If this ``ArrayProxy`` was created with ``keep_file_open=True``,
     |      the open file object is closed if necessary.
     |  
     |  __getitem__(self, slicer)
     |  
     |  __getstate__(self)
     |      Returns the state of this ``ArrayProxy`` during pickling.
     |  
     |  __setstate__(self, state)
     |      Sets the state of this ``ArrayProxy`` during unpickling.
     |  
     |  copy(self) -> 'Self'
     |      Create a new ArrayProxy for the same file and parameters
     |      
     |      If the proxied file is an open file handle, the new ArrayProxy
     |      will share a lock with the old one.
     |  
     |  get_unscaled(self)
     |      Read data from file
     |      
     |      This is an optional part of the proxy API
     |  
     |  reshape(self, shape)
     |      Return an ArrayProxy with a new shape, without modifying data
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.arrayproxy.ArrayProxy:
     |  
     |  dtype
     |  
     |  inter
     |  
     |  is_proxy
     |  
     |  ndim
     |  
     |  offset
     |  
     |  shape
     |  
     |  slope
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.arrayproxy.ArrayLike:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.arrayproxy.ArrayLike:
     |  
     |  __annotations__ = {'shape': 'tuple[int, ...]'}
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class AFNIHeader(nibabel.spatialimages.SpatialHeader)
     |  AFNIHeader(info)
     |  
     |  Class for AFNI header
     |  
     |  Method resolution order:
     |      AFNIHeader
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, info)
     |      Initialize AFNI header object
     |      
     |      Parameters
     |      ----------
     |      info : dict
     |          Information from HEAD file as obtained by :func:`parse_AFNI_header`
     |      
     |      Examples
     |      --------
     |      >>> fname = os.path.join(datadir, 'example4d+orig.HEAD')
     |      >>> header = AFNIHeader(parse_AFNI_header(fname))
     |      >>> header.get_data_dtype().str
     |      '<i2'
     |      >>> header.get_zooms()
     |      (3.0, 3.0, 3.0, 3.0)
     |      >>> header.get_data_shape()
     |      (33, 41, 25, 3)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  copy(self)
     |      Copy object to independent representation
     |      
     |      The copy should not be affected by any changes to the original
     |      object.
     |  
     |  get_affine(self)
     |      Returns affine of dataset
     |      
     |      Examples
     |      --------
     |      >>> fname = os.path.join(datadir, 'example4d+orig.HEAD')
     |      >>> header = AFNIHeader(parse_AFNI_header(fname))
     |      >>> header.get_affine()
     |      array([[ -3.    ,  -0.    ,  -0.    ,  49.5   ],
     |             [ -0.    ,  -3.    ,  -0.    ,  82.312 ],
     |             [  0.    ,   0.    ,   3.    , -52.3511],
     |             [  0.    ,   0.    ,   0.    ,   1.    ]])
     |  
     |  get_data_offset(self)
     |      Data offset in BRIK file
     |      
     |      Offset is always 0.
     |  
     |  get_data_scaling(self)
     |      AFNI applies volume-specific data scaling
     |      
     |      Examples
     |      --------
     |      >>> fname = os.path.join(datadir, 'scaled+tlrc.HEAD')
     |      >>> header = AFNIHeader(parse_AFNI_header(fname))
     |      >>> header.get_data_scaling()
     |      array([3.883363e-08])
     |  
     |  get_slope_inter(self)
     |      Use `self.get_data_scaling()` instead
     |      
     |      Holdover because ``AFNIArrayProxy`` (inheriting from ``ArrayProxy``)
     |      requires this functionality so as to not error.
     |  
     |  get_space(self)
     |      Return label for anatomical space to which this dataset is aligned.
     |      
     |      Returns
     |      -------
     |      space : str
     |          AFNI "space" designation; one of [ORIG, ANAT, TLRC, MNI]
     |      
     |      Notes
     |      -----
     |      There appears to be documentation for these spaces at
     |      https://afni.nimh.nih.gov/pub/dist/atlases/elsedemo/AFNI_atlas_spaces.niml
     |  
     |  get_volume_labels(self)
     |      Returns volume labels
     |      
     |      Returns
     |      -------
     |      labels : list of str
     |          Labels for volumes along fourth dimension
     |      
     |      Examples
     |      --------
     |      >>> header = AFNIHeader(parse_AFNI_header(os.path.join(datadir, 'example4d+orig.HEAD')))
     |      >>> header.get_volume_labels()
     |      ['#0', '#1', '#2']
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_fileobj(fileobj) from typing._ProtocolMeta
     |  
     |  from_header(header=None) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |  
     |  data_from_fileobj(self, fileobj: 'io.IOBase') -> 'np.ndarray'
     |      Read binary image data from `fileobj`
     |  
     |  data_to_fileobj(self, data: 'npt.ArrayLike', fileobj: 'io.IOBase', rescale: 'bool' = True)
     |      Write array data `data` as binary to `fileobj`
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |          data to write
     |      fileobj : file-like object
     |          file-like object implementing 'write'
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. For this minimal header, `rescale` has no effect
     |  
     |  get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_best_affine = get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  get_data_shape(self) -> 'tuple[int, ...]'
     |  
     |  get_zooms(self) -> 'tuple[float, ...]'
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  set_data_shape(self, shape: 'Sequence[int]') -> 'None'
     |  
     |  set_zooms(self, zooms: 'Sequence[float]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __annotations__ = {'_dtype': 'np.dtype', '_shape': 'tuple[int, ...]', ...
     |  
     |  __hash__ = None
     |  
     |  data_layout = 'F'
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |  
     |  write_to(self, fileobj: 'io.IOBase') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class AFNIHeaderError(nibabel.spatialimages.HeaderDataError)
     |  Error when reading AFNI HEAD file
     |  
     |  Method resolution order:
     |      AFNIHeaderError
     |      nibabel.spatialimages.HeaderDataError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from nibabel.spatialimages.HeaderDataError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class AFNIImage(nibabel.spatialimages.SpatialImage)
     |  AFNIImage(dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |  
     |  AFNI Image file
     |  
     |  Can be loaded from either the BRIK or HEAD file (but MUST specify one!)
     |  
     |  Examples
     |  --------
     |  >>> import nibabel as nib
     |  >>> brik = nib.load(os.path.join(datadir, 'example4d+orig.BRIK.gz'))
     |  >>> brik.shape
     |  (33, 41, 25, 3)
     |  >>> brik.affine
     |  array([[ -3.    ,  -0.    ,  -0.    ,  49.5   ],
     |         [ -0.    ,  -3.    ,  -0.    ,  82.312 ],
     |         [  0.    ,   0.    ,   3.    , -52.3511],
     |         [  0.    ,   0.    ,   0.    ,   1.    ]])
     |  >>> head = load(os.path.join(datadir, 'example4d+orig.HEAD'))
     |  >>> np.array_equal(head.get_fdata(), brik.get_fdata())
     |  True
     |  
     |  Method resolution order:
     |      AFNIImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Class methods defined here:
     |  
     |  filespec_to_file_map(filespec) from builtins.type
     |      Make `file_map` from filename `filespec`
     |      
     |      AFNI BRIK files can be compressed, but HEAD files cannot - see
     |      afni.nimh.nih.gov/pub/dist/doc/program_help/README.compression.html.
     |      Thus, if you have AFNI files my_image.HEAD and my_image.BRIK.gz and you
     |      want to load the AFNI BRIK / HEAD pair, you can specify:
     |      
     |          * The HEAD filename - e.g., my_image.HEAD
     |          * The BRIK filename w/o compressed extension - e.g., my_image.BRIK
     |          * The full BRIK filename - e.g., my_image.BRIK.gz
     |      
     |      Parameters
     |      ----------
     |      filespec : str
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          dict with keys ``image`` and ``header`` where values are fileholder
     |          objects for the respective BRIK and HEAD files
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          If `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Creates an AFNIImage instance from `file_map`
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          dict with keys ``image, header`` and values being fileholder
     |          objects for the respective BRIK and HEAD files
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : {None, True, False}, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_like`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ImageArrayProxy = <class 'nibabel.brikhead.AFNIArrayProxy'>
     |      Proxy object for AFNI image array.
     |      
     |      Attributes
     |      ----------
     |      scaling : np.ndarray
     |          Scaling factor (one factor per volume/sub-brick) for data. Default is
     |          None
     |  
     |  
     |  __annotations__ = {'header': <class 'nibabel.brikhead.AFNIHeader'>}
     |  
     |  files_types = (('image', '.brik'), ('header', '.head'))
     |  
     |  header_class = <class 'nibabel.brikhead.AFNIHeader'>
     |      Class for AFNI header
     |  
     |  
     |  makeable = False
     |  
     |  rw = False
     |  
     |  valid_exts = ('.brik', '.head')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __init__(self, dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class AFNIImageError(nibabel.spatialimages.ImageDataError)
     |  Error when reading AFNI BRIK files
     |  
     |  Method resolution order:
     |      AFNIImageError
     |      nibabel.spatialimages.ImageDataError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from nibabel.spatialimages.ImageDataError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    parse_AFNI_header(fobj)
        Parses `fobj` to extract information from HEAD file
        
        Parameters
        ----------
        fobj : file-like object
            AFNI HEAD file object or filename. If file object, should
            implement at least ``read``
        
        Returns
        -------
        info : dict
            Dictionary containing AFNI-style key:value pairs from HEAD file
        
        Examples
        --------
        >>> fname = os.path.join(datadir, 'example4d+orig.HEAD')
        >>> info = parse_AFNI_header(fname)
        >>> print(info['BYTEORDER_STRING'])
        LSB_FIRST
        >>> print(info['BRICK_TYPES'])
        [1, 1, 1]

DATA
    DATA_OFFSET = 0
    NAME_RE = re.compile('name\\s*=\\s*(\\w+)\\s*\\n')
    TYPE_RE = re.compile('type\\s*=\\s*(string|integer|float)-attribute\\s...
    datadir = '/Users/santosg/miniconda3/lib/python3.9/site-packages/nibab...
    filepath = '/Users/santosg/miniconda3/lib/python3.9/site-packages/niba...
    space_codes = <nibabel.volumeutils.Recoder object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/brikhead.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& caret &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.caret in nibabel:

NAME
    nibabel.caret

DESCRIPTION
    # emacs: -*- mode: python-mode; py-indent-offset: 4; indent-tabs-mode: nil -*-
    # vi: set ft=python sts=4 ts=4 sw=4 et:
    ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
    #
    #   See COPYING file distributed along with the NiBabel package for the
    #   copyright and license terms.
    #
    ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##

CLASSES
    collections.abc.MutableMapping(collections.abc.Mapping)
        CaretMetaData(nibabel.xmlutils.XmlSerializable, collections.abc.MutableMapping)
    nibabel.xmlutils.XmlSerializable(builtins.object)
        CaretMetaData(nibabel.xmlutils.XmlSerializable, collections.abc.MutableMapping)
    
    class CaretMetaData(nibabel.xmlutils.XmlSerializable, collections.abc.MutableMapping)
     |  CaretMetaData(*args, **kwargs)
     |  
     |  A list of name-value pairs used in various Caret-based XML formats
     |  
     |  * Description - Provides a simple method for user-supplied metadata that
     |    associates names with values.
     |  * Attributes: [NA]
     |  * Child Elements
     |  
     |      * MD (0...N)
     |  
     |  * Text Content: [NA]
     |  
     |  MD elements are a single metadata entry consisting of a name and a value.
     |  
     |  Attributes
     |  ----------
     |  data : mapping of {name: value} pairs
     |  
     |  >>> md = CaretMetaData()
     |  >>> md['key'] = 'val'
     |  >>> md
     |  <CaretMetaData {'key': 'val'}>
     |  >>> dict(md)
     |  {'key': 'val'}
     |  >>> md.to_xml()
     |  b'<MetaData><MD><Name>key</Name><Value>val</Value></MD></MetaData>'
     |  
     |  Objects may be constructed like any ``dict``:
     |  
     |  >>> md = CaretMetaData(key='val')
     |  >>> md.to_xml()
     |  b'<MetaData><MD><Name>key</Name><Value>val</Value></MD></MetaData>'
     |  
     |  Method resolution order:
     |      CaretMetaData
     |      nibabel.xmlutils.XmlSerializable
     |      collections.abc.MutableMapping
     |      collections.abc.Mapping
     |      collections.abc.Collection
     |      collections.abc.Sized
     |      collections.abc.Iterable
     |      collections.abc.Container
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __delitem__(self, key)
     |      Delete metadata entry by name
     |      
     |      >>> md = CaretMetaData({'key': 'val'})
     |      >>> dict(md)
     |      {'key': 'val'}
     |      >>> del md['key']
     |      >>> dict(md)
     |      {}
     |  
     |  __getitem__(self, key)
     |      Get metadata entry by name
     |      
     |      >>> md = CaretMetaData({'key': 'val'})
     |      >>> md['key']
     |      'val'
     |  
     |  __init__(self, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self)
     |      Iterate over metadata entries
     |      
     |      >>> md = CaretMetaData({'key': 'val'})
     |      >>> for key in md:
     |      ...     print(key)
     |      key
     |  
     |  __len__(self)
     |      Get length of metadata list
     |      
     |      >>> md = CaretMetaData({'key': 'val'})
     |      >>> len(md)
     |      1
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setitem__(self, key, value)
     |      Set metadata entry by name
     |      
     |      >>> md = CaretMetaData({'key': 'val'})
     |      >>> dict(md)
     |      {'key': 'val'}
     |      >>> md['newkey'] = 'newval'
     |      >>> dict(md)
     |      {'key': 'val', 'newkey': 'newval'}
     |      >>> md['key'] = 'otherval'
     |      >>> dict(md)
     |      {'key': 'otherval', 'newkey': 'newval'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.xmlutils.XmlSerializable:
     |  
     |  to_xml(self, enc='utf-8', **kwargs) -> bytes
     |      Generate an XML bytestring with a given encoding.
     |      
     |      Parameters
     |      ----------
     |      enc : :class:`string`
     |          Encoding to use for the generated bytestring. Default: 'utf-8'
     |      \*\*kwargs : :class:`dict`
     |          Additional keyword arguments to :func:`xml.etree.ElementTree.tostring`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.xmlutils.XmlSerializable:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from collections.abc.MutableMapping:
     |  
     |  clear(self)
     |      D.clear() -> None.  Remove all items from D.
     |  
     |  pop(self, key, default=<object object at 0x10dcf0170>)
     |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
     |      If key is not found, d is returned if given, otherwise KeyError is raised.
     |  
     |  popitem(self)
     |      D.popitem() -> (k, v), remove and return some (key, value) pair
     |      as a 2-tuple; but raise KeyError if D is empty.
     |  
     |  setdefault(self, key, default=None)
     |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D
     |  
     |  update(self, other=(), /, **kwds)
     |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
     |      If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
     |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
     |      In either case, this is followed by: for k, v in F.items(): D[k] = v
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from collections.abc.Mapping:
     |  
     |  __contains__(self, key)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  get(self, key, default=None)
     |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.
     |  
     |  items(self)
     |      D.items() -> a set-like object providing a view on D's items
     |  
     |  keys(self)
     |      D.keys() -> a set-like object providing a view on D's keys
     |  
     |  values(self)
     |      D.values() -> an object providing a view on D's values
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from collections.abc.Mapping:
     |  
     |  __hash__ = None
     |  
     |  __reversed__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from collections.abc.Collection:
     |  
     |  __subclasshook__(C) from abc.ABCMeta
     |      Abstract classes can override this to customize issubclass().
     |      
     |      This is invoked early on by abc.ABCMeta.__subclasscheck__().
     |      It should return True, False or NotImplemented.  If it returns
     |      NotImplemented, the normal algorithm is used.  Otherwise, it
     |      overrides the normal algorithm (and the outcome is cached).
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from collections.abc.Iterable:
     |  
     |  __class_getitem__ = GenericAlias(...) from abc.ABCMeta
     |      Represent a PEP 585 generic type
     |      
     |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/caret.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& casting &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.casting in nibabel:

NAME
    nibabel.casting - Utilities for casting numpy values in various ways

DESCRIPTION
    Most routines work round some numpy oddities in floating point precision and
    casting.  Others work round numpy casting to and from python ints

CLASSES
    builtins.Exception(builtins.BaseException)
        CastingError
        FloatingError
    
    class CastingError(builtins.Exception)
     |  Method resolution order:
     |      CastingError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class FloatingError(builtins.Exception)
     |  Method resolution order:
     |      FloatingError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    able_int_type(values)
        Find the smallest integer numpy type to contain sequence `values`
        
        Prefers uint to int if minimum is >= 0
        
        Parameters
        ----------
        values : sequence
            sequence of integer values
        
        Returns
        -------
        itype : None or numpy type
            numpy integer type or None if no integer type holds all `values`
        
        Examples
        --------
        >>> able_int_type([0, 1]) == np.uint8
        True
        >>> able_int_type([-1, 1]) == np.int8
        True
    
    as_int(x, check=True)
        Return python integer representation of number
        
        as_int() is deprecated. Use int() instead.
        
        * deprecated from version: 5.2.0
        * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 7.0.0
        
        
        
        .. testsetup::
        
            >>> import pytest
            >>> import warnings
            >>> _suppress_warnings = pytest.deprecated_call()
            >>> _ = _suppress_warnings.__enter__()
        
        This is useful because the numpy int(val) mechanism is broken for large
        values in np.longdouble.
        
        It is also useful to work around a numpy 1.4.1 bug in conversion of uints
        to python ints.
        
        Parameters
        ----------
        x : object
            integer, unsigned integer or floating point value
        check : {True, False}
            If True, raise error for values that are not integers
        
        Returns
        -------
        i : int
            Python integer
        
        Examples
        --------
        >>> as_int(2.0)
        2
        >>> as_int(-2.0)
        -2
        >>> as_int(2.1) #doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
            ...
        FloatingError: Not an integer: 2.1
        >>> as_int(2.1, check=False)
        2
        
        
        .. testcleanup::
        
            >>> warnings.warn("Avoid error if no doctests to run...", DeprecationWarning)
            >>> _ = _suppress_warnings.__exit__(None, None, None)
    
    best_float()
        Floating point type with best precision
        
        This is nearly always np.longdouble, except on Windows, where np.longdouble
        is Intel80 storage, but with float64 precision for calculations.  In that
        case we return float64 on the basis it's the fastest and smallest at the
        highest precision.
        
        SPARC float128 also proved so slow that we prefer float64.
        
        Returns
        -------
        best_type : numpy type
            floating point type with highest precision
        
        Notes
        -----
        Needs to run without error for module import, because it is called in
        ``ok_floats`` below, and therefore in setting module global ``OK_FLOATS``.
    
    ceil_exact(val, flt_type)
        Return nearest exact integer >= `val` in float type `flt_type`
        
        Parameters
        ----------
        val : int
            We have to pass val as an int rather than the floating point type
            because large integers cast as floating point may be rounded by the
            casting process.
        flt_type : numpy type
            numpy float type.
        
        Returns
        -------
        ceil_val : object
            value of same floating point type as `val`, that is the nearest exact
            integer in this type such that `floor_val` >= `val`.  Thus if `val` is
            exact in `flt_type`, `ceil_val` == `val`.
        
        Examples
        --------
        Obviously 2 is within the range of representable integers for float32
        
        >>> ceil_exact(2, np.float32)
        2.0
        
        As is 2**24-1 (the number of significand digits is 23 + 1 implicit)
        
        >>> ceil_exact(2**24-1, np.float32) == 2**24-1
        True
        
        But 2**24+1 gives a number that float32 can't represent exactly
        
        >>> ceil_exact(2**24+1, np.float32) == 2**24+2
        True
        
        As for the numpy ceil function, negatives ceil towards inf
        
        >>> ceil_exact(-2**24-1, np.float32) == -2**24
        True
    
    float_to_int(arr, int_type, nan2zero=True, infmax=False)
        Convert floating point array `arr` to type `int_type`
        
        * Rounds numbers to nearest integer
        * Clips values to prevent overflows when casting
        * Converts NaN to 0 (for `nan2zero` == True)
        
        Casting floats to integers is delicate because the result is undefined
        and platform specific for float values outside the range of `int_type`.
        Define ``shared_min`` to be the minimum value that can be exactly
        represented in both the float type of `arr` and `int_type`. Define
        `shared_max` to be the equivalent maximum value.  To avoid undefined
        results we threshold `arr` at ``shared_min`` and ``shared_max``.
        
        Parameters
        ----------
        arr : array-like
            Array of floating point type
        int_type : object
            Numpy integer type
        nan2zero : {True, False, None}
            Whether to convert NaN value to zero.  Default is True.  If False, and
            NaNs are present, raise CastingError. If None, do not check for NaN
            values and pass through directly to the ``astype`` casting mechanism.
            In this last case, the resulting value is undefined.
        infmax : {False, True}
            If True, set np.inf values in `arr` to be `int_type` integer maximum
            value, -np.inf as `int_type` integer minimum.  If False, set +/- infs
            to be ``shared_min``, ``shared_max`` as defined above.  Therefore False
            gives faster conversion at the expense of infs that are further from
            infinity.
        
        Returns
        -------
        iarr : ndarray
            of type `int_type`
        
        Examples
        --------
        >>> float_to_int([np.nan, np.inf, -np.inf, 1.1, 6.6], np.int16)
        array([     0,  32767, -32768,      1,      7], dtype=int16)
        
        Notes
        -----
        Numpy relies on the C library to cast from float to int using the standard
        ``astype`` method of the array.
        
        Quoting from section F4 of the C99 standard:
        
            If the floating value is infinite or NaN or if the integral part of the
            floating value exceeds the range of the integer type, then the
            "invalid" floating-point exception is raised and the resulting value
            is unspecified.
        
        Hence we threshold at ``shared_min`` and ``shared_max`` to avoid casting to
        values that are undefined.
        
        See: https://en.wikipedia.org/wiki/C99 . There are links to the C99
        standard from that page.
    
    floor_exact(val, flt_type)
        Return nearest exact integer <= `val` in float type `flt_type`
        
        Parameters
        ----------
        val : int
            We have to pass val as an int rather than the floating point type
            because large integers cast as floating point may be rounded by the
            casting process.
        flt_type : numpy type
            numpy float type.
        
        Returns
        -------
        floor_val : object
            value of same floating point type as `val`, that is the nearest exact
            integer in this type such that `floor_val` <= `val`.  Thus if `val` is
            exact in `flt_type`, `floor_val` == `val`.
        
        Examples
        --------
        Obviously 2 is within the range of representable integers for float32
        
        >>> floor_exact(2, np.float32)
        2.0
        
        As is 2**24-1 (the number of significand digits is 23 + 1 implicit)
        
        >>> floor_exact(2**24-1, np.float32) == 2**24-1
        True
        
        But 2**24+1 gives a number that float32 can't represent exactly
        
        >>> floor_exact(2**24+1, np.float32) == 2**24
        True
        
        As for the numpy floor function, negatives floor towards -inf
        
        >>> floor_exact(-2**24-1, np.float32) == -2**24-2
        True
    
    floor_log2(x)
        floor of log2 of abs(`x`)
        
        Embarrassingly, from https://en.wikipedia.org/wiki/Binary_logarithm
        
        Parameters
        ----------
        x : int
        
        Returns
        -------
        L : None or int
            floor of base 2 log of `x`.  None if `x` == 0.
        
        Examples
        --------
        >>> floor_log2(2**9+1)
        9
        >>> floor_log2(-2**9+1)
        8
        >>> floor_log2(0.5)
        -1
        >>> floor_log2(0) is None
        True
    
    have_binary128()
        True if we have a binary128 IEEE longdouble
    
    int_abs(arr)
        Absolute values of array taking care of max negative int values
        
        Parameters
        ----------
        arr : array-like
        
        Returns
        -------
        abs_arr : array
            array the same shape as `arr` in which all negative numbers have been
            changed to positive numbers with the magnitude.
        
        Examples
        --------
        This kind of thing is confusing in base numpy:
        
        >>> import numpy as np
        >>> np.abs(np.int8(-128))
        -128
        
        ``int_abs`` fixes that:
        
        >>> int_abs(np.int8(-128))
        128
        >>> int_abs(np.array([-128, 127], dtype=np.int8))
        array([128, 127], dtype=uint8)
        >>> int_abs(np.array([-128, 127], dtype=np.float32))
        array([128., 127.], dtype=float32)
    
    int_to_float(val, flt_type)
        Convert integer `val` to floating point type `flt_type`
        
        int_to_float(..., dt) is deprecated. Use dt() instead.
        
        * deprecated from version: 5.2.0
        * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 7.0.0
        
        
        
        .. testsetup::
        
            >>> import pytest
            >>> import warnings
            >>> _suppress_warnings = pytest.deprecated_call()
            >>> _ = _suppress_warnings.__enter__()
        
        Why is this so complicated?
        
        At least in numpy <= 1.6.1, numpy longdoubles do not correctly convert to
        ints, and ints do not correctly convert to longdoubles.  Specifically, in
        both cases, the values seem to go through float64 conversion on the way, so
        to convert better, we need to split into float64s and sum up the result.
        
        Parameters
        ----------
        val : int
            Integer value
        flt_type : object
            numpy floating point type
        
        Returns
        -------
        f : numpy scalar
            of type `flt_type`
        
        Examples
        --------
        >>> int_to_float(1, np.float32)
        1.0
        
        
        .. testcleanup::
        
            >>> warnings.warn("Avoid error if no doctests to run...", DeprecationWarning)
            >>> _ = _suppress_warnings.__exit__(None, None, None)
    
    longdouble_lte_float64()
        Return True if longdouble appears to have the same precision as float64
    
    longdouble_precision_improved()
        True if longdouble precision increased since initial import
        
        This can happen on Windows compiled with MSVC.  It may be because libraries
        compiled with mingw (longdouble is Intel80) get linked to numpy compiled
        with MSVC (longdouble is Float64)
    
    ok_floats()
        Return floating point types sorted by precision
        
        Remove longdouble if it has no higher precision than float64
    
    on_powerpc()
        True if we are running on a Power PC platform
        
        Has to deal with older Macs and IBM POWER7 series among others
    
    shared_range(flt_type, int_type)
        Min and max in float type that are >=min, <=max in integer type
        
        This is not as easy as it sounds, because the float type may not be able to
        exactly represent the max or min integer values, so we have to find the
        next exactly representable floating point value to do the thresholding.
        
        Parameters
        ----------
        flt_type : dtype specifier
            A dtype specifier referring to a numpy floating point type.  For
            example, ``f4``, ``np.dtype('f4')``, ``np.float32`` are equivalent.
        int_type : dtype specifier
            A dtype specifier referring to a numpy integer type.  For example,
            ``i4``, ``np.dtype('i4')``, ``np.int32`` are equivalent
        
        Returns
        -------
        mn : object
            Number of type `flt_type` that is the minimum value in the range of
            `int_type`, such that ``mn.astype(int_type)`` >= min of `int_type`
        mx : object
            Number of type `flt_type` that is the maximum value in the range of
            `int_type`, such that ``mx.astype(int_type)`` <= max of `int_type`
        
        Examples
        --------
        >>> shared_range(np.float32, np.int32) == (-2147483648.0, 2147483520.0)
        True
        >>> shared_range('f4', 'i4') == (-2147483648.0, 2147483520.0)
        True
    
    type_info(np_type)
        Return dict with min, max, nexp, nmant, width for numpy type `np_type`
        
        Type can be integer in which case nexp and nmant are None.
        
        Parameters
        ----------
        np_type : numpy type specifier
            Any specifier for a numpy dtype
        
        Returns
        -------
        info : dict
            with fields ``min`` (minimum value), ``max`` (maximum value), ``nexp``
            (exponent width), ``nmant`` (significand precision not including
            implicit first digit), ``minexp`` (minimum exponent), ``maxexp``
            (maximum exponent), ``width`` (width in bytes). (``nexp``, ``nmant``,
            ``minexp``, ``maxexp``) are None for integer types. Both ``min`` and
            ``max`` are of type `np_type`.
        
        Raises
        ------
        FloatingError
            for floating point types we don't recognize
        
        Notes
        -----
        You might be thinking that ``np.finfo`` does this job, and it does, except
        for PPC long doubles (https://github.com/numpy/numpy/issues/2669) and
        float96 on Windows compiled with Mingw. This routine protects against such
        errors in ``np.finfo`` by only accepting values that we know are likely to
        be correct.
    
    ulp(val=1.0)
        Return gap between `val` and nearest representable number of same type
        
        This is the value of a unit in the last place (ULP), and is similar in
        meaning to the MATLAB eps function.
        
        Parameters
        ----------
        val : scalar, optional
            scalar value of any numpy type.  Default is 1.0 (float64)
        
        Returns
        -------
        ulp_val : scalar
            gap between `val` and nearest representable number of same type
        
        Notes
        -----
        The wikipedia article on machine epsilon points out that the term *epsilon*
        can be used in the sense of a unit in the last place (ULP), or as the
        maximum relative rounding error.  The MATLAB ``eps`` function uses the ULP
        meaning, but this function is ``ulp`` rather than ``eps`` to avoid
        confusion between different meanings of *eps*.

DATA
    OK_FLOATS = [<class 'numpy.float16'>, <class 'numpy.float32'>, <class ...
    TRUNC_UINT64 = False
    __annotations__ = {'_SHARED_RANGES': 'dict[tuple[type, type], tuple[np...
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    deprecate_with_version = <nibabel.deprecator.Deprecator object>
    sctypes = {'complex': [<class 'numpy.complex64'>, <class 'numpy.comple...
    sctypes_aliases = {<class 'numpy.float16'>, <class 'numpy.int8'>, <cla...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/casting.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& cifti2 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on package nibabel.cifti2 in nibabel:

NAME
    nibabel.cifti2 - CIFTI-2 format IO

DESCRIPTION
    .. currentmodule:: nibabel.cifti2
    
    .. autosummary::
       :toctree: ../generated
    
       cifti2
       cifti2_axes

PACKAGE CONTENTS
    cifti2
    cifti2_axes
    parse_cifti2
    tests (package)

DATA
    CIFTI_BRAIN_STRUCTURES = <nibabel.volumeutils.Recoder object>
    CIFTI_MODEL_TYPES = ('CIFTI_MODEL_TYPE_SURFACE', 'CIFTI_MODEL_TYPE_VOX...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/cifti2/__init__.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& concat_images &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function concat_images in module nibabel.funcs:

concat_images(images, check_affines=True, axis=None)
    Concatenate images in list to single image, along specified dimension
    
    Parameters
    ----------
    images : sequence
       sequence of ``SpatialImage`` or filenames of the same dimensionality\s
    check_affines : {True, False}, optional
       If True, then check that all the affines for `images` are nearly
       the same, raising a ``ValueError`` otherwise.  Default is True
    axis : None or int, optional
        If None, concatenates on a new dimension.  This requires all images to
        be the same shape.  If not None, concatenates on the specified
        dimension.  This requires all images to be the same shape, except on
        the specified dimension.
    
    Returns
    -------
    concat_img : ``SpatialImage``
       New image resulting from concatenating `images` across last
       dimension

None
&&&&&&&&&&&&&&&&&&&&&&&&& dataobj_images &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.dataobj_images in nibabel:

NAME
    nibabel.dataobj_images - File-based images that have data arrays

DESCRIPTION
    The class:`DataObjImage` class defines an image that extends the
    :class:`FileBasedImage` by adding an array-like object, named ``dataobj``.
    This can either be an actual numpy array, or an object that:
    
    * returns an array from ``numpy.asanyarray(obj)``;
    * has an attribute or property ``shape``.

CLASSES
    nibabel.filebasedimages.FileBasedImage(builtins.object)
        DataobjImage
    
    class DataobjImage(nibabel.filebasedimages.FileBasedImage)
     |  DataobjImage(dataobj: 'ArrayLike', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |  
     |  Template class for images that have dataobj data stores
     |  
     |  Method resolution order:
     |      DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, dataobj: 'ArrayLike', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |      Initialize dataobj image
     |      
     |      The datobj image is a combination of (dataobj, header), with optional
     |      metadata in `extra`, and filename / file-like objects contained in the
     |      `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns
     |         an array from ``np.asanyarray``.  It should have ``shape`` and
     |         ``ndim`` attributes or properties
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_file_map(file_map: 'FileMap', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'_data_cache': 'np.ndarray | None', '_fdata_cache':...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __getitem__(self, key) -> 'None'
     |      No slicing or dictionary interface for images
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  from_image(img: 'FileBasedImage') -> 'ImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``FileBasedImage`` instance
     |         In fact, an object with the API of ``FileBasedImage``.
     |      
     |      Returns
     |      -------
     |      img : ``FileBasedImage`` instance
     |         Image, of our own class
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  files_types = (('image', None),)
     |  
     |  header_class = <class 'nibabel.filebasedimages.FileBasedHeader'>
     |      Template class to implement header protocol
     |  
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  valid_exts = ()

DATA
    ArrayImgT = ~ArrayImgT
    FileMap = typing.Mapping[str, nibabel.fileholders.FileHolder]
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    deprecate_with_version = <nibabel.deprecator.Deprecator object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/dataobj_images.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& deprecated &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.deprecated in nibabel:

NAME
    nibabel.deprecated - Module to help with deprecating objects and classes

CLASSES
    builtins.UserWarning(builtins.Warning)
        VisibleDeprecationWarning
    builtins.object
        FutureWarningMixin
        ModuleProxy
    
    class FutureWarningMixin(builtins.object)
     |  FutureWarningMixin(*args: 'P.args', **kwargs: 'P.kwargs') -> 'None'
     |  
     |  Insert FutureWarning for object creation
     |  
     |  Examples
     |  --------
     |  >>> class C: pass
     |  >>> class D(FutureWarningMixin, C):
     |  ...     warn_message = "Please, don't use this class"
     |  
     |  Record the warning
     |  
     |  >>> with warnings.catch_warnings(record=True) as warns:
     |  ...     d = D()
     |  ...     warns[0].message.args[0]
     |  "Please, don't use this class"
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args: 'P.args', **kwargs: 'P.kwargs') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  warn_message = 'This class will be removed in future versions'
    
    class ModuleProxy(builtins.object)
     |  ModuleProxy(module_name: 'str') -> 'None'
     |  
     |  Proxy for module that may not yet have been imported
     |  
     |  Parameters
     |  ----------
     |  module_name : str
     |      Full module name e.g. ``nibabel.minc``
     |  
     |  Examples
     |  --------
     |  
     |  ::
     |      arr = np.arange(24).reshape((2, 3, 4))
     |      nifti1 = ModuleProxy('nibabel.nifti1')
     |      nifti1_image = nifti1.Nifti1Image(arr, np.eye(4))
     |  
     |  So, the ``nifti1`` object is a proxy that will import the required module
     |  when you do attribute access and return the attributes of the imported
     |  module.
     |  
     |  Methods defined here:
     |  
     |  __getattr__(self, key: 'str') -> 'ty.Any'
     |  
     |  __init__(self, module_name: 'str') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class VisibleDeprecationWarning(builtins.UserWarning)
     |  Deprecation warning that will be shown by default
     |  
     |  Python >= 2.7 does not show standard DeprecationWarnings by default:
     |  
     |  http://docs.python.org/dev/whatsnew/2.7.html#the-future-for-python-2-x
     |  
     |  Use this class for cases where we do want to show deprecations by default.
     |  
     |  Method resolution order:
     |      VisibleDeprecationWarning
     |      builtins.UserWarning
     |      builtins.Warning
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.UserWarning:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.UserWarning:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    alert_future_error(msg: 'str', version: 'str', *, warning_class: 'type[Warning]' = <class 'FutureWarning'>, error_class: 'type[Exception]' = <class 'RuntimeError'>, warning_rec: 'str' = '', error_rec: 'str' = '', stacklevel: 'int' = 2) -> 'None'
        Warn or error with appropriate messages for changing functionality.
        
        Parameters
        ----------
        msg : str
            Description of the condition that led to the alert
        version : str
            NiBabel version at which the warning will become an error
        warning_class : subclass of Warning, optional
            Warning class to emit before version
        error_class : subclass of Exception, optional
            Error class to emit after version
        warning_rec : str, optional
            Guidance for suppressing the warning and avoiding the future error
        error_rec: str, optional
            Guidance for resolving the error
        stacklevel: int, optional
            Warnings stacklevel to provide; note that this will be incremented by
            1, so provide the stacklevel you would provide directly to warnings.warn()

DATA
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    deprecate_with_version = <nibabel.deprecator.Deprecator object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/deprecated.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& deprecator &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.deprecator in nibabel:

NAME
    nibabel.deprecator - Class for recording and reporting deprecations

CLASSES
    builtins.RuntimeError(builtins.Exception)
        ExpiredDeprecationError
    builtins.object
        Deprecator
    
    class Deprecator(builtins.object)
     |  Deprecator(version_comparator: 'ty.Callable[[str], int]', warn_class: 'type[Warning]' = <class 'DeprecationWarning'>, error_class: 'type[Exception]' = <class 'nibabel.deprecator.ExpiredDeprecationError'>) -> 'None'
     |  
     |  Class to make decorator marking function or method as deprecated
     |  
     |  The decorated function / method will:
     |  
     |  * Raise the given `warning_class` warning when the function / method gets
     |    called, up to (and including) version `until` (if specified);
     |  * Raise the given `error_class` error when the function / method gets
     |    called, when the package version is greater than version `until` (if
     |    specified).
     |  
     |  Parameters
     |  ----------
     |  version_comparator : callable
     |      Callable accepting string as argument, and return 1 if string
     |      represents a higher version than encoded in the `version_comparator`, 0
     |      if the version is equal, and -1 if the version is lower.  For example,
     |      the `version_comparator` may compare the input version string to the
     |      current package version string.
     |  warn_class : class, optional
     |      Class of warning to generate for deprecation.
     |  error_class : class, optional
     |      Class of error to generate when `version_comparator` returns 1 for a
     |      given argument of ``until`` in the ``__call__`` method (see below).
     |  
     |  Methods defined here:
     |  
     |  __call__(self, message: 'str', since: 'str' = '', until: 'str' = '', warn_class: 'type[Warning] | None' = None, error_class: 'type[Exception] | None' = None) -> 'ty.Callable[[ty.Callable[P, T]], ty.Callable[P, T]]'
     |      Return decorator function function for deprecation warning / error
     |      
     |      Parameters
     |      ----------
     |      message : str
     |          Message explaining deprecation, giving possible alternatives.
     |      since : str, optional
     |          Released version at which object was first deprecated.
     |      until : str, optional
     |          Last released version at which this function will still raise a
     |          deprecation warning.  Versions higher than this will raise an
     |          error.
     |      warn_class : None or class, optional
     |          Class of warning to generate for deprecation (overrides instance
     |          default).
     |      error_class : None or class, optional
     |          Class of error to generate when `version_comparator` returns 1 for a
     |          given argument of ``until`` (overrides class default).
     |      
     |      Returns
     |      -------
     |      deprecator : func
     |          Function returning a decorator.
     |  
     |  __init__(self, version_comparator: 'ty.Callable[[str], int]', warn_class: 'type[Warning]' = <class 'DeprecationWarning'>, error_class: 'type[Exception]' = <class 'nibabel.deprecator.ExpiredDeprecationError'>) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  is_bad_version(self, version_str: 'str') -> 'bool'
     |      Return True if `version_str` is too high
     |      
     |      Tests `version_str` with ``self.version_comparator``
     |      
     |      Parameters
     |      ----------
     |      version_str : str
     |          String giving version to test
     |      
     |      Returns
     |      -------
     |      is_bad : bool
     |          True if `version_str` is for version below that expected by
     |          ``self.version_comparator``, False otherwise.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ExpiredDeprecationError(builtins.RuntimeError)
     |  Error for expired deprecation
     |  
     |  Error raised when a called function or method has passed out of its
     |  deprecation period.
     |  
     |  Method resolution order:
     |      ExpiredDeprecationError
     |      builtins.RuntimeError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.RuntimeError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.RuntimeError:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

DATA
    TESTCLEANUP = '\n\n.. testcleanup::\n\n    >>> warnings.warn("Avoid......
    TESTSETUP = '\n\n.. testsetup::\n\n    >>> import pytest\n    >>> ...l...
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/deprecator.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& ecat &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.ecat in nibabel:

NAME
    nibabel.ecat - Read ECAT format images

DESCRIPTION
    An ECAT format image consists of:
    
    * a *main header*;
    * at least one *matrix list* (mlist);
    
    ECAT thinks of memory locations in terms of *blocks*.  One block is 512
    bytes.  Thus block 1 starts at 0 bytes, block 2 at 512 bytes, and so on.
    
    The matrix list is an array with one row per frame in the data.
    
    Columns in the matrix list are:
    
    * 0: Matrix identifier (frame number)
    * 1: matrix data start block number (subheader followed by image data)
    * 2: Last block number of matrix (image) data
    * 3: Matrix status
    
        * 1: hxists - rw
        * 2: exists - ro
        * 3: matrix deleted
    
    There is one sub-header for each image frame (or matrix in the terminology
    above).  A sub-header can also be called an *image header*.  The sub-header is
    one block (512 bytes), and the frame (image) data follows.
    
    There is very little documentation of the ECAT format, and many of the comments
    in this code come from a combination of trial and error and wild speculation.
    
    XMedcon can read and write ECAT 6 format, and read ECAT 7 format: see
    http://xmedcon.sourceforge.net and the ECAT files in the source of XMedCon,
    currently ``libs/tpc/*ecat*`` and ``source/m-ecat*``.  Unfortunately XMedCon is
    GPL and some of the header files are adapted from CTI files (called CTI code
    below).  It's not clear what the licenses are for these files.

CLASSES
    builtins.object
        EcatImageArrayProxy
        EcatSubHeader
    nibabel.spatialimages.SpatialHeader(nibabel.filebasedimages.FileBasedHeader, nibabel.spatialimages.SpatialProtocol)
        EcatHeader(nibabel.wrapstruct.WrapStruct, nibabel.spatialimages.SpatialHeader)
    nibabel.spatialimages.SpatialImage(nibabel.dataobj_images.DataobjImage)
        EcatImage
    nibabel.wrapstruct.WrapStruct(builtins.object)
        EcatHeader(nibabel.wrapstruct.WrapStruct, nibabel.spatialimages.SpatialHeader)
    
    class EcatHeader(nibabel.wrapstruct.WrapStruct, nibabel.spatialimages.SpatialHeader)
     |  EcatHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Class for basic Ecat PET header
     |  
     |  Sub-parts of standard Ecat File
     |  
     |  * main header
     |  * matrix list
     |    which lists the information for each frame collected (can have 1 to many
     |    frames)
     |  * subheaders specific to each frame with possibly-variable sized data
     |    blocks
     |  
     |  This just reads the main Ecat Header, it does not load the data or read the
     |  mlist or any sub headers
     |  
     |  Method resolution order:
     |      EcatHeader
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize Ecat header from bytes object
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, bytes} optional
     |          binary block to set into header, By default, None in which case we
     |          insert default empty header block
     |      endianness : {None, '<', '>', other endian code}, optional
     |          endian code of binary block, If None, guess endianness
     |          from the data
     |      check : {True, False}, optional
     |          Whether to check and fix header for errors.  No checks currently
     |          implemented, so value has no effect.
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data from header
     |  
     |  get_filetype(self)
     |      Type of ECAT Matrix File from code stored in header
     |  
     |  get_patient_orient(self)
     |      gets orientation of patient based on code stored
     |      in header, not always reliable
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Return header data for empty header with given endianness
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess endian from MAGIC NUMBER value of header data
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  template_dtype = dtype([('magic_number', 'S14'), ('original_filen...'S...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_from_fileobj(self, fileobj: 'io.IOBase') -> 'np.ndarray'
     |      Read binary image data from `fileobj`
     |  
     |  data_to_fileobj(self, data: 'npt.ArrayLike', fileobj: 'io.IOBase', rescale: 'bool' = True)
     |      Write array data `data` as binary to `fileobj`
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |          data to write
     |      fileobj : file-like object
     |          file-like object implementing 'write'
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. For this minimal header, `rescale` has no effect
     |  
     |  get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_best_affine = get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_data_shape(self) -> 'tuple[int, ...]'
     |  
     |  get_zooms(self) -> 'tuple[float, ...]'
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  set_data_shape(self, shape: 'Sequence[int]') -> 'None'
     |  
     |  set_zooms(self, zooms: 'Sequence[float]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  from_header(header: 'SpatialProtocol | FileBasedHeader | ty.Mapping | None' = None) -> 'SpatialHdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __annotations__ = {'_dtype': 'np.dtype', '_shape': 'tuple[int, ...]', ...
     |  
     |  data_layout = 'F'
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class EcatImage(nibabel.spatialimages.SpatialImage)
     |  EcatImage(dataobj, affine, header, subheader, mlist, extra=None, file_map=None)
     |  
     |  Class returns a list of Ecat images, with one image(hdr/data) per frame
     |  
     |  Method resolution order:
     |      EcatImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, dataobj, affine, header, subheader, mlist, extra=None, file_map=None)
     |      Initialize Image
     |      
     |      The image is a combination of
     |      (array, affine matrix, header, subheader, mlist)
     |      with optional meta data in `extra`, and filename / file-like objects
     |      contained in the `file_map`.
     |      
     |      Parameters
     |      ----------
     |      dataobj : array-like
     |          image data
     |      affine : None or (4,4) array-like
     |          homogeneous affine giving relationship between voxel coords and
     |          world coords.
     |      header : None or header instance
     |          meta data for this image format
     |      subheader : None or subheader instance
     |          meta data for each sub-image for frame in the image
     |      mlist : None or array
     |          Matrix list array giving offset and order of data in file
     |      extra : None or mapping, optional
     |          metadata associated with this image that cannot be
     |          stored in header or subheader
     |      file_map : mapping, optional
     |          mapping giving file information for this image format
     |      
     |      Examples
     |      --------
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> nibabel_dir = os.path.dirname(nib.__file__)
     |      >>> from nibabel import ecat
     |      >>> ecat_file = os.path.join(nibabel_dir,'tests','data','tinypet.v')
     |      >>> img = ecat.load(ecat_file)
     |      >>> frame0 = img.get_frame(0)
     |      >>> frame0.shape == (10, 10, 3)
     |      True
     |      >>> data4d = img.get_fdata()
     |      >>> data4d.shape == (10, 10, 3, 1)
     |      True
     |  
     |  get_data_dtype(self, frame)
     |  
     |  get_frame(self, frame, orientation=None)
     |      Get full volume for a time frame
     |      
     |      :param frame: Time frame index from where to fetch data
     |      :param orientation: None (default), 'neurological' or 'radiological'
     |      :rtype: Numpy array containing (possibly oriented) raw data
     |  
     |  get_frame_affine(self, frame)
     |      returns 4X4 affine
     |  
     |  get_mlist(self)
     |      get access to the mlist
     |  
     |  get_subheaders(self)
     |      get access to subheaders
     |  
     |  to_file_map(self, file_map=None)
     |      Write ECAT7 image to `file_map` or contained ``self.file_map``
     |      
     |      The format consist of:
     |      
     |      - A main header (512L) with dictionary entries in the form
     |          [numAvail, nextDir, previousDir, numUsed]
     |      - For every frame (3D volume in 4D data)
     |        - A subheader (size = frame_offset)
     |        - Frame data (3D volume)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      class method to create image from mapping
     |      specified in file_map
     |  
     |  from_image(img) from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  load(filespec) from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  affine
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ImageArrayProxy = <class 'nibabel.ecat.EcatImageArrayProxy'>
     |      Ecat implementation of array proxy protocol
     |      
     |      The array proxy allows us to freeze the passed fileobj and
     |      header such that it returns the expected data array.
     |  
     |  
     |  __annotations__ = {'_subheader': <class 'nibabel.ecat.EcatSubHeader'>,...
     |  
     |  files_types = (('image', '.v'), ('header', '.v'))
     |  
     |  header_class = <class 'nibabel.ecat.EcatHeader'>
     |      Class for basic Ecat PET header
     |      
     |      Sub-parts of standard Ecat File
     |      
     |      * main header
     |      * matrix list
     |        which lists the information for each frame collected (can have 1 to many
     |        frames)
     |      * subheaders specific to each frame with possibly-variable sized data
     |        blocks
     |      
     |      This just reads the main Ecat Header, it does not load the data or read the
     |      mlist or any sub headers
     |  
     |  
     |  subheader_class = <class 'nibabel.ecat.EcatSubHeader'>
     |  
     |  valid_exts = ('.v',)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  makeable = True
     |  
     |  rw = True
    
    class EcatImageArrayProxy(builtins.object)
     |  EcatImageArrayProxy(subheader)
     |  
     |  Ecat implementation of array proxy protocol
     |  
     |  The array proxy allows us to freeze the passed fileobj and
     |  header such that it returns the expected data array.
     |  
     |  Methods defined here:
     |  
     |  __array__(self, dtype=None)
     |      Read of data from file
     |      
     |      This reads ALL FRAMES into one array, can be memory expensive.
     |      
     |      If you want to read only some slices, use the slicing syntax
     |      (``__getitem__``) below, or ``subheader.data_from_fileobj(frame)``
     |      
     |      Parameters
     |      ----------
     |      dtype : numpy dtype specifier, optional
     |          A numpy dtype specifier specifying the type of the returned array.
     |      
     |      Returns
     |      -------
     |      array
     |          Scaled image data with type `dtype`.
     |  
     |  __getitem__(self, sliceobj)
     |      Return slice `sliceobj` from ECAT data, optimizing if possible
     |  
     |  __init__(self, subheader)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  is_proxy
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EcatSubHeader(builtins.object)
     |  EcatSubHeader(hdr, mlist, fileobj)
     |  
     |  Methods defined here:
     |  
     |  __init__(self, hdr, mlist, fileobj)
     |      parses the subheaders in the ecat (.v) file
     |      there is one subheader for each frame in the ecat file
     |      
     |      Parameters
     |      ----------
     |      hdr : EcatHeader
     |          ECAT main header
     |      mlist : array shape (N, 4)
     |          Matrix list
     |      fileobj : ECAT file <filename>.v  fileholder or file object
     |                with read, seek methods
     |  
     |  data_from_fileobj(self, frame=0, orientation=None)
     |      Read scaled data from file for a given frame
     |      
     |      :param frame: Time frame index from where to fetch data
     |      :param orientation: None (default), 'neurological' or 'radiological'
     |      :rtype: Numpy array containing (possibly oriented) raw data
     |      
     |      .. seealso:: raw_data_from_fileobj
     |  
     |  get_frame_affine(self, frame=0)
     |      returns best affine for given frame of data
     |  
     |  get_nframes(self)
     |      returns number of frames
     |  
     |  get_shape(self, frame=0)
     |      returns shape of given frame
     |  
     |  get_zooms(self, frame=0)
     |      returns zooms  ...pixdims
     |  
     |  raw_data_from_fileobj(self, frame=0, orientation=None)
     |      Get raw data from file object.
     |      
     |      :param frame: Time frame index from where to fetch data
     |      :param orientation: None (default), 'neurological' or 'radiological'
     |      :rtype: Numpy array containing (possibly oriented) raw data
     |      
     |      .. seealso:: data_from_fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    get_frame_order(mlist)
        Returns the order of the frames stored in the file
        Sometimes Frames are not stored in the file in
        chronological order, this can be used to extract frames
        in correct order
        
        Returns
        -------
        id_dict: dict mapping frame number -> [mlist_row, mlist_id]
        
        (where mlist id is value in the first column of the mlist matrix )
        
        Examples
        --------
        >>> import os
        >>> import nibabel as nib
        >>> nibabel_dir = os.path.dirname(nib.__file__)
        >>> from nibabel import ecat
        >>> ecat_file = os.path.join(nibabel_dir,'tests','data','tinypet.v')
        >>> img = ecat.load(ecat_file)
        >>> mlist = img.get_mlist()
        >>> get_frame_order(mlist)
        {0: [0, 16842758]}
    
    get_series_framenumbers(mlist)
        Returns framenumber of data as it was collected,
        as part of a series; not just the order of how it was
        stored in this or across other files
        
        For example, if the data is split between multiple files
        this should give you the true location of this frame as
        collected in the series
        (Frames are numbered starting at ONE (1) not Zero)
        
        Returns
        -------
        frame_dict: dict mapping order_stored -> frame in series
                where frame in series counts from 1; [1,2,3,4...]
        
        Examples
        --------
        >>> import os
        >>> import nibabel as nib
        >>> nibabel_dir = os.path.dirname(nib.__file__)
        >>> from nibabel import ecat
        >>> ecat_file = os.path.join(nibabel_dir,'tests','data','tinypet.v')
        >>> img = ecat.load(ecat_file)
        >>> mlist = img.get_mlist()
        >>> get_series_framenumbers(mlist)
        {0: 1}
    
    load(filespec) method of builtins.type instance
        Class method to create image from filename `filename`
        
        Parameters
        ----------
        filename : str
            Filename of image to load
        mmap : {True, False, 'c', 'r'}, optional, keyword only
            `mmap` controls the use of numpy memory mapping for reading image
            array data.  If False, do not try numpy ``memmap`` for data array.
            If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
            `mmap` value of True gives the same behavior as ``mmap='c'``.  If
            image data file cannot be memory-mapped, ignore `mmap` value and
            read array from file.
        keep_file_open : { None, True, False }, optional, keyword only
            `keep_file_open` controls whether a new file handle is created
            every time the image is accessed, or a single file handle is
            created and used for the lifetime of this ``ArrayProxy``. If
            ``True``, a single file handle is created and used. If ``False``,
            a new file handle is created every time the image is accessed.
            The default value (``None``) will result in the value of
            ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
        
        Returns
        -------
        img : DataobjImage instance
    
    read_mlist(fileobj, endianness)
        read (nframes, 4) matrix list array from `fileobj`
        
        Parameters
        ----------
        fileobj : file-like
            an open file-like object implementing ``seek`` and ``read``
        
        Returns
        -------
        mlist : (nframes, 4) ndarray
            matrix list is an array with ``nframes`` rows and columns:
        
            * 0: Matrix identifier (frame number)
            * 1: matrix data start block number (subheader followed by image data)
            * 2: Last block number of matrix (image) data
            * 3: Matrix status
        
                * 1: hxists - rw
                * 2: exists - ro
                * 3: matrix deleted
        
        Notes
        -----
        A block is 512 bytes.
        
        ``block_no`` in the code below is 1-based.  block 1 is the main header,
        and the mlist blocks start at block number 2.
        
        The 512 bytes in an mlist block contain 32 rows of the int32 (nframes,
        4) mlist matrix.
        
        The first row of these 32 looks like a special row.  The 4 values appear
        to be (respectively):
        
        * not sure - maybe negative number of mlist rows (out of 31) that are
          blank and not used in this block.  Called `nfree` but unused in CTI
          code;
        * block_no - of next set of mlist entries or 2 if no more entries. We also
          allow 1 or 0 to signal no more entries;
        * <no idea>.  Called `prvblk` in CTI code, so maybe previous block no;
        * n_rows - number of mlist rows in this block (between ?0 and 31) (called
          `nused` in CTI code).
    
    read_subheaders(fileobj, mlist, endianness)
        Retrieve all subheaders and return list of subheader recarrays
        
        Parameters
        ----------
        fileobj : file-like
            implementing ``read`` and ``seek``
        mlist : (nframes, 4) ndarray
            Columns are:
            * 0 - Matrix identifier.
            * 1 - subheader block number
            * 2 - Last block number of matrix data block.
            * 3 - Matrix status
        endianness : {'<', '>'}
            little / big endian code
        
        Returns
        -------
        subheaders : list
            List of subheader structured arrays

DATA
    BLOCK_SIZE = 512
    data_type_codes = <nibabel.volumeutils.Recoder object>
    file_type_codes = {0: 'ECAT7_UNKNOWN', 1: 'ECAT7_2DSCAN', 2: 'ECAT7_IM...
    ft_defs = ((0, 'ECAT7_UNKNOWN'), (1, 'ECAT7_2DSCAN'), (2, 'ECAT7_IMAGE...
    hdr_dtype = dtype([('magic_number', 'S14'), ('original_filen...'S32'),...
    main_header_dtd = [('magic_number', '14S'), ('original_filename', '32S...
    native_code = '<'
    patient_orient_codes = {0: 'ECAT7_Feet_First_Prone', 1: 'ECAT7_Head_Fi...
    patient_orient_defs = ((0, 'ECAT7_Feet_First_Prone'), (1, 'ECAT7_Head_...
    patient_orient_neurological = [1, 3, 5, 7]
    patient_orient_radiological = [0, 2, 4, 6]
    subhdr_dtype = dtype([('data_type', '<u2'), ('num_dimensions', ...ws',...
    subheader_dtd = [('data_type', <class 'numpy.uint16'>), ('num_dimensio...
    swapped_code = '>'

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/ecat.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& eulerangles &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.eulerangles in nibabel:

NAME
    nibabel.eulerangles - Module implementing Euler angle rotations and their conversions

DESCRIPTION
    See:
    
    * https://en.wikipedia.org/wiki/Rotation_matrix
    * https://en.wikipedia.org/wiki/Euler_angles
    * http://mathworld.wolfram.com/EulerAngles.html
    
    See also: *Representing Attitude with Euler Angles and Quaternions: A
    Reference* (2006) by James Diebel. A cached PDF link last found here:
    
    http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.5134
    
    Euler's rotation theorem tells us that any rotation in 3D can be
    described by 3 angles.  Let's call the 3 angles the *Euler angle vector*
    and call the angles in the vector :math:`alpha`, :math:`beta` and
    :math:`gamma`.  The vector is [ :math:`alpha`,
    :math:`beta`. :math:`gamma` ] and, in this description, the order of the
    parameters specifies the order in which the rotations occur (so the
    rotation corresponding to :math:`alpha` is applied first).
    
    In order to specify the meaning of an *Euler angle vector* we need to
    specify the axes around which each of the rotations corresponding to
    :math:`alpha`, :math:`beta` and :math:`gamma` will occur.
    
    There are therefore three axes for the rotations :math:`alpha`,
    :math:`beta` and :math:`gamma`; let's call them :math:`i` :math:`j`,
    :math:`k`.
    
    Let us express the rotation :math:`alpha` around axis `i` as a 3 by 3
    rotation matrix `A`.  Similarly :math:`beta` around `j` becomes 3 x 3
    matrix `B` and :math:`gamma` around `k` becomes matrix `G`.  Then the
    whole rotation expressed by the Euler angle vector [ :math:`alpha`,
    :math:`beta`. :math:`gamma` ], `R` is given by::
    
       R = np.dot(G, np.dot(B, A))
    
    See http://mathworld.wolfram.com/EulerAngles.html
    
    The order :math:`G B A` expresses the fact that the rotations are
    performed in the order of the vector (:math:`alpha` around axis `i` =
    `A` first).
    
    To convert a given Euler angle vector to a meaningful rotation, and a
    rotation matrix, we need to define:
    
    * the axes `i`, `j`, `k`
    * whether a rotation matrix should be applied on the left of a vector to
      be transformed (vectors are column vectors) or on the right (vectors
      are row vectors).
    * whether the rotations move the axes as they are applied (intrinsic
      rotations) - compared the situation where the axes stay fixed and the
      vectors move within the axis frame (extrinsic)
    * the handedness of the coordinate system
    
    See: https://en.wikipedia.org/wiki/Rotation_matrix#Ambiguities
    
    We are using the following conventions:
    
    * axes `i`, `j`, `k` are the `z`, `y`, and `x` axes respectively.  Thus
      an Euler angle vector [ :math:`alpha`, :math:`beta`. :math:`gamma` ]
      in our convention implies a :math:`alpha` radian rotation around the
      `z` axis, followed by a :math:`beta` rotation around the `y` axis,
      followed by a :math:`gamma` rotation around the `x` axis.
    * the rotation matrix applies on the left, to column vectors on the
      right, so if `R` is the rotation matrix, and `v` is a 3 x N matrix
      with N column vectors, the transformed vector set `vdash` is given by
      ``vdash = np.dot(R, v)``.
    * extrinsic rotations - the axes are fixed, and do not move with the
      rotations.
    * a right-handed coordinate system
    
    The convention of rotation around ``z``, followed by rotation around
    ``y``, followed by rotation around ``x``, is known (confusingly) as
    "xyz", pitch-roll-yaw, Cardan angles, or Tait-Bryan angles.

FUNCTIONS
    angle_axis2euler(theta, vector, is_normalized=False)
        Convert angle, axis pair to Euler angles
        
        Parameters
        ----------
        theta : scalar
           angle of rotation
        vector : 3 element sequence
           vector specifying axis for rotation.
        is_normalized : bool, optional
           True if vector is already normalized (has norm of 1).  Default
           False
        
        Returns
        -------
        z : scalar
        y : scalar
        x : scalar
           Rotations in radians around z, y, x axes, respectively
        
        Examples
        --------
        >>> z, y, x = angle_axis2euler(0, [1, 0, 0])
        >>> np.allclose((z, y, x), 0)
        True
        
        Notes
        -----
        It's possible to reduce the amount of calculation a little, by
        combining parts of the ``angle_axis2mat`` and ``mat2euler``
        functions, but the reduction in computation is small, and the code
        repetition is large.
    
    euler2angle_axis(z=0, y=0, x=0)
        Return angle, axis corresponding to these Euler angles
        
        Uses the z, then y, then x convention above
        
        Parameters
        ----------
        z : scalar
           Rotation angle in radians around z-axis (performed first)
        y : scalar
           Rotation angle in radians around y-axis
        x : scalar
           Rotation angle in radians around x-axis (performed last)
        
        Returns
        -------
        theta : scalar
           angle of rotation
        vector : array shape (3,)
           axis around which rotation occurs
        
        Examples
        --------
        >>> theta, vec = euler2angle_axis(0, 1.5, 0)
        >>> print(theta)
        1.5
        >>> np.allclose(vec, [0, 1, 0])
        True
    
    euler2mat(z=0, y=0, x=0)
        Return matrix for rotations around z, y and x axes
        
        Uses the z, then y, then x convention above
        
        Parameters
        ----------
        z : scalar
           Rotation angle in radians around z-axis (performed first)
        y : scalar
           Rotation angle in radians around y-axis
        x : scalar
           Rotation angle in radians around x-axis (performed last)
        
        Returns
        -------
        M : array shape (3,3)
           Rotation matrix giving same rotation as for given angles
        
        Examples
        --------
        >>> zrot = 1.3 # radians
        >>> yrot = -0.1
        >>> xrot = 0.2
        >>> M = euler2mat(zrot, yrot, xrot)
        >>> M.shape == (3, 3)
        True
        
        The output rotation matrix is equal to the composition of the
        individual rotations
        
        >>> M1 = euler2mat(zrot)
        >>> M2 = euler2mat(0, yrot)
        >>> M3 = euler2mat(0, 0, xrot)
        >>> composed_M = np.dot(M3, np.dot(M2, M1))
        >>> np.allclose(M, composed_M)
        True
        
        You can specify rotations by named arguments
        
        >>> np.all(M3 == euler2mat(x=xrot))
        True
        
        When applying M to a vector, the vector should column vector to the
        right of M.  If the right hand side is a 2D array rather than a
        vector, then each column of the 2D array represents a vector.
        
        >>> vec = np.array([1, 0, 0]).reshape((3,1))
        >>> v2 = np.dot(M, vec)
        >>> vecs = np.array([[1, 0, 0],[0, 1, 0]]).T # giving 3x2 array
        >>> vecs2 = np.dot(M, vecs)
        
        Rotations are counter-clockwise.
        
        >>> zred = np.dot(euler2mat(z=np.pi/2), np.eye(3))
        >>> np.allclose(zred, [[0, -1, 0],[1, 0, 0], [0, 0, 1]])
        True
        >>> yred = np.dot(euler2mat(y=np.pi/2), np.eye(3))
        >>> np.allclose(yred, [[0, 0, 1],[0, 1, 0], [-1, 0, 0]])
        True
        >>> xred = np.dot(euler2mat(x=np.pi/2), np.eye(3))
        >>> np.allclose(xred, [[1, 0, 0],[0, 0, -1], [0, 1, 0]])
        True
        
        Notes
        -----
        The direction of rotation is given by the right-hand rule (orient
        the thumb of the right hand along the axis around which the rotation
        occurs, with the end of the thumb at the positive end of the axis;
        curl your fingers; the direction your fingers curl is the direction
        of rotation).  Therefore, the rotations are counterclockwise if
        looking along the axis of rotation from positive to negative.
    
    euler2quat(z=0, y=0, x=0)
        Return quaternion corresponding to these Euler angles
        
        Uses the z, then y, then x convention above
        
        Parameters
        ----------
        z : scalar
           Rotation angle in radians around z-axis (performed first)
        y : scalar
           Rotation angle in radians around y-axis
        x : scalar
           Rotation angle in radians around x-axis (performed last)
        
        Returns
        -------
        quat : array shape (4,)
           Quaternion in w, x, y z (real, then vector) format
        
        Notes
        -----
        We can derive this formula in Sympy using:
        
        1. Formula giving quaternion corresponding to rotation of theta radians
           about arbitrary axis:
           http://mathworld.wolfram.com/EulerParameters.html
        2. Generated formulae from 1.) for quaternions corresponding to
           theta radians rotations about ``x, y, z`` axes
        3. Apply quaternion multiplication formula -
           https://en.wikipedia.org/wiki/Quaternions#Hamilton_product - to
           formulae from 2.) to give formula for combined rotations.
    
    mat2euler(M, cy_thresh=None)
        Discover Euler angle vector from 3x3 matrix
        
        Uses the conventions above.
        
        Parameters
        ----------
        M : array-like, shape (3,3)
        cy_thresh : None or scalar, optional
           threshold below which to give up on straightforward arctan for
           estimating x rotation.  If None (default), estimate from
           precision of input.
        
        Returns
        -------
        z : scalar
        y : scalar
        x : scalar
           Rotations in radians around z, y, x axes, respectively
        
        Notes
        -----
        If there was no numerical error, the routine could be derived using
        Sympy expression for z then y then x rotation matrix, which is::
        
          [                       cos(y)*cos(z),                       -cos(y)*sin(z),         sin(y)],
          [cos(x)*sin(z) + cos(z)*sin(x)*sin(y), cos(x)*cos(z) - sin(x)*sin(y)*sin(z), -cos(y)*sin(x)],
          [sin(x)*sin(z) - cos(x)*cos(z)*sin(y), cos(z)*sin(x) + cos(x)*sin(y)*sin(z),  cos(x)*cos(y)]
        
        with the obvious derivations for z, y, and x
        
           z = atan2(-r12, r11)
           y = asin(r13)
           x = atan2(-r23, r33)
        
        Problems arise when cos(y) is close to zero, because both of::
        
           z = atan2(cos(y)*sin(z), cos(y)*cos(z))
           x = atan2(cos(y)*sin(x), cos(x)*cos(y))
        
        will be close to atan2(0, 0), and highly unstable.
        
        The ``cy`` fix for numerical instability below is from: *Graphics
        Gems IV*, Paul Heckbert (editor), Academic Press, 1994, ISBN:
        0123361559.  Specifically it comes from EulerAngles.c by Ken
        Shoemake, and deals with the case where cos(y) is close to zero:
        
        See: http://www.graphicsgems.org/
        
        The code appears to be licensed (from the website) as "can be used
        without restrictions".
    
    quat2euler(q)
        Return Euler angles corresponding to quaternion `q`
        
        Parameters
        ----------
        q : 4 element sequence
           w, x, y, z of quaternion
        
        Returns
        -------
        z : scalar
           Rotation angle in radians around z-axis (performed first)
        y : scalar
           Rotation angle in radians around y-axis
        x : scalar
           Rotation angle in radians around x-axis (performed last)
        
        Notes
        -----
        It's possible to reduce the amount of calculation a little, by
        combining parts of the ``quat2mat`` and ``mat2euler`` functions, but
        the reduction in computation is small, and the code repetition is
        large.
    
    reduce(...)
        reduce(function, sequence[, initial]) -> value
        
        Apply a function of two arguments cumulatively to the items of a sequence,
        from left to right, so as to reduce the sequence to a single value.
        For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
        ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
        of the sequence in the calculation, and serves as a default when the
        sequence is empty.

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/eulerangles.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& externals &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on package nibabel.externals in nibabel:

NAME
    nibabel.externals - # init for externals package

PACKAGE CONTENTS
    conftest
    netcdf
    oset
    tests (package)

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/externals/__init__.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& filebasedimages &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.filebasedimages in nibabel:

NAME
    nibabel.filebasedimages - Common interface for any image format--volume or surface, binary or xml

CLASSES
    builtins.Exception(builtins.BaseException)
        ImageFileError
    builtins.object
        FileBasedHeader
        FileBasedImage
            SerializableImage
    
    class FileBasedHeader(builtins.object)
     |  Template class to implement header protocol
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |  
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |  
     |  copy(self: 'HdrT') -> 'HdrT'
     |      Copy object to independent representation
     |      
     |      The copy should not be affected by any changes to the original
     |      object.
     |  
     |  write_to(self, fileobj: 'io.IOBase') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_fileobj(fileobj: 'io.IOBase') -> 'HdrT' from builtins.type
     |  
     |  from_header(header: 'FileBasedHeader | ty.Mapping | None' = None) -> 'HdrT' from builtins.type
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FileBasedImage(builtins.object)
     |  FileBasedImage(header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |  
     |  Abstract image class with interface for loading/saving images from disk.
     |  
     |  The class doesn't define any image properties.
     |  
     |  It has:
     |  
     |  attributes:
     |  
     |     * extra
     |  
     |  properties:
     |  
     |     * header
     |  
     |  methods:
     |  
     |     * to_filename(fname) - writes data to filename(s) derived from
     |       ``fname``, where the derivation may differ between formats.
     |     * to_file_map() - save image to files with which the image is already
     |       associated.
     |  
     |  classmethods:
     |  
     |     * from_filename(fname) - make instance by loading from filename
     |     * from_file_map(fmap) - make instance from file map
     |     * instance_to_filename(img, fname) - save ``img`` instance to
     |       filename ``fname``.
     |  
     |  It also has a ``header`` - some standard set of meta-data that is specific
     |  to the image format, and ``extra`` - a dictionary container for any other
     |  metadata.
     |  
     |  You cannot slice an image, and trying to slice an image generates an
     |  informative TypeError.
     |  
     |  **There are several ways of writing data**
     |  
     |  There is the usual way, which is the default::
     |  
     |      img.to_filename(fname)
     |  
     |  and that is, to take the data encapsulated by the image and cast it to
     |  the datatype the header expects, setting any available header scaling
     |  into the header to help the data match.
     |  
     |  You can load the data into an image from file with::
     |  
     |     img.from_filename(fname)
     |  
     |  The image stores its associated files in its ``file_map`` attribute.  In
     |  order to just save an image, for which you know there is an associated
     |  filename, or other storage, you can do::
     |  
     |     img.to_file_map()
     |  
     |  **Files interface**
     |  
     |  The image has an attribute ``file_map``.  This is a mapping, that has keys
     |  corresponding to the file types that an image needs for storage.  For
     |  example, the Analyze data format needs an ``image`` and a ``header``
     |  file type for storage:
     |  
     |     >>> import numpy as np
     |     >>> import nibabel as nib
     |     >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |     >>> img = nib.AnalyzeImage(data, np.eye(4))
     |     >>> sorted(img.file_map)
     |     ['header', 'image']
     |  
     |  The values of ``file_map`` are not in fact files but objects with
     |  attributes ``filename``, ``fileobj`` and ``pos``.
     |  
     |  The reason for this interface, is that the contents of files has to
     |  contain enough information so that an existing image instance can save
     |  itself back to the files pointed to in ``file_map``.  When a file holder
     |  holds active file-like objects, then these may be affected by the
     |  initial file read; in this case, the file-like objects need to
     |  carry the position at which a write (with ``to_file_map``) should place the
     |  data.  The ``file_map`` contents should therefore be such, that this will
     |  work.
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, key) -> 'None'
     |      No slicing or dictionary interface for images
     |  
     |  __init__(self, header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |      Initialize image
     |      
     |      The image is a combination of (header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  from_file_map(file_map: 'FileMap') -> 'ImgT' from builtins.type
     |  
     |  from_filename(filename: 'FileSpec') -> 'ImgT' from builtins.type
     |  
     |  from_image(img: 'FileBasedImage') -> 'ImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``FileBasedImage`` instance
     |         In fact, an object with the API of ``FileBasedImage``.
     |      
     |      Returns
     |      -------
     |      img : ``FileBasedImage`` instance
     |         Image, of our own class
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  load = from_filename(filename: 'FileSpec') -> 'ImgT' from builtins.type
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'_compressed_suffixes': 'tuple[str, ...]', '_meta_s...
     |  
     |  files_types = (('image', None),)
     |  
     |  header_class = <class 'nibabel.filebasedimages.FileBasedHeader'>
     |      Template class to implement header protocol
     |  
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  valid_exts = ()
    
    class ImageFileError(builtins.Exception)
     |  Method resolution order:
     |      ImageFileError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class SerializableImage(FileBasedImage)
     |  SerializableImage(header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |  
     |  Abstract image class for (de)serializing images to/from byte streams/strings.
     |  
     |  The class doesn't define any image properties.
     |  
     |  It has:
     |  
     |  methods:
     |  
     |     * to_bytes() - serialize image to byte string
     |  
     |  classmethods:
     |  
     |     * from_bytes(bytestring) - make instance by deserializing a byte string
     |     * from_url(url) - make instance by fetching and deserializing a URL
     |  
     |  Loading from byte strings should provide round-trip equivalence:
     |  
     |  .. code:: python
     |  
     |      img_a = klass.from_bytes(bstr)
     |      img_b = klass.from_bytes(img_a.to_bytes())
     |  
     |      np.allclose(img_a.get_fdata(), img_b.get_fdata())
     |      np.allclose(img_a.affine, img_b.affine)
     |  
     |  Further, for images that are single files on disk, the following methods of loading
     |  the image must be equivalent:
     |  
     |  .. code:: python
     |  
     |      img = klass.from_filename(fname)
     |  
     |      with open(fname, 'rb') as fobj:
     |          img = klass.from_bytes(fobj.read())
     |  
     |  And the following methods of saving a file must be equivalent:
     |  
     |  .. code:: python
     |  
     |      img.to_filename(fname)
     |  
     |      with open(fname, 'wb') as fobj:
     |          fobj.write(img.to_bytes())
     |  
     |  Images that consist of separate header and data files (e.g., Analyze
     |  images) currently do not support this interface.
     |  For multi-file images, ``to_bytes()`` and ``from_bytes()`` must be
     |  overridden, and any encoding details should be documented.
     |  
     |  Method resolution order:
     |      SerializableImage
     |      FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  to_bytes(self, **kwargs) -> 'bytes'
     |      Return a ``bytes`` object with the contents of the file that would
     |      be written if the image were saved.
     |      
     |      Parameters
     |      ----------
     |      \*\*kwargs : keyword arguments
     |          Keyword arguments that may be passed to ``img.to_file_map()``
     |      
     |      Returns
     |      -------
     |      bytes
     |          Serialized image
     |  
     |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
     |      Save image to writable IO stream
     |      
     |      Parameters
     |      ----------
     |      io_obj : IOBase object
     |          Writable stream
     |      \*\*kwargs : keyword arguments
     |          Keyword arguments that may be passed to ``img.to_file_map()``
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
     |      Construct image from a byte string
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      bytestring : bytes
     |          Byte string containing the on-disk representation of an image
     |  
     |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
     |      Load image from readable IO stream
     |      
     |      Convert to BytesIO to enable seeking, if input stream is not seekable
     |      
     |      Parameters
     |      ----------
     |      io_obj : IOBase object
     |          Readable stream
     |  
     |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
     |      Retrieve and load an image from a URL
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      url : str or urllib.request.Request object
     |          URL of file to retrieve
     |      timeout : float, optional
     |          Time (in seconds) to wait for a response
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from FileBasedImage:
     |  
     |  __getitem__(self, key) -> 'None'
     |      No slicing or dictionary interface for images
     |  
     |  __init__(self, header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |      Initialize image
     |      
     |      The image is a combination of (header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  from_file_map(file_map: 'FileMap') -> 'ImgT' from builtins.type
     |  
     |  from_filename(filename: 'FileSpec') -> 'ImgT' from builtins.type
     |  
     |  from_image(img: 'FileBasedImage') -> 'ImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``FileBasedImage`` instance
     |         In fact, an object with the API of ``FileBasedImage``.
     |      
     |      Returns
     |      -------
     |      img : ``FileBasedImage`` instance
     |         Image, of our own class
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  load = from_filename(filename: 'FileSpec') -> 'ImgT' from builtins.type
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from FileBasedImage:
     |  
     |  __annotations__ = {'_compressed_suffixes': 'tuple[str, ...]', '_meta_s...
     |  
     |  files_types = (('image', None),)
     |  
     |  header_class = <class 'nibabel.filebasedimages.FileBasedHeader'>
     |      Template class to implement header protocol
     |  
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  valid_exts = ()

DATA
    COMPRESSION_ERRORS = (<class 'OSError'>, <class 'gzip.BadGzipFile'>, <...
    FileMap = typing.Mapping[str, nibabel.fileholders.FileHolder]
    FileSniff = typing.Tuple[bytes, str]
    HdrT = ~HdrT
    ImgT = ~ImgT
    StreamImgT = ~StreamImgT
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/filebasedimages.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& fileholders &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.fileholders in nibabel:

NAME
    nibabel.fileholders - Fileholder class

CLASSES
    builtins.Exception(builtins.BaseException)
        FileHolderError
    builtins.object
        FileHolder
    
    class FileHolder(builtins.object)
     |  FileHolder(filename: 'str | None' = None, fileobj: 'io.IOBase | None' = None, pos: 'int' = 0)
     |  
     |  class to contain filename, fileobj and file position
     |  
     |  Methods defined here:
     |  
     |  __init__(self, filename: 'str | None' = None, fileobj: 'io.IOBase | None' = None, pos: 'int' = 0)
     |      Initialize FileHolder instance
     |      
     |      Parameters
     |      ----------
     |      filename : str, optional
     |         filename.  Default is None
     |      fileobj : file-like object, optional
     |         Should implement at least 'seek' (for the purposes for this
     |         class).  Default is None
     |      pos : int, optional
     |         position in filename or fileobject at which to start reading
     |         or writing data; defaults to 0
     |  
     |  get_prepare_fileobj(self, *args, **kwargs) -> 'ImageOpener'
     |      Return fileobj if present, or return fileobj from filename
     |      
     |      Set position to that given in self.pos
     |      
     |      Parameters
     |      ----------
     |      *args : tuple
     |         positional arguments to file open.  Ignored if there is a
     |         defined ``self.fileobj``.  These might include the mode, such
     |         as 'rb'
     |      **kwargs : dict
     |         named arguments to file open.  Ignored if there is a
     |         defined ``self.fileobj``
     |      
     |      Returns
     |      -------
     |      fileobj : file-like object
     |         object has position set (via ``fileobj.seek()``) to
     |         ``self.pos``
     |  
     |  same_file_as(self, other: 'FileHolder') -> 'bool'
     |      Test if `self` refers to same files / fileobj as `other`
     |      
     |      Parameters
     |      ----------
     |      other : object
     |          object with `filename` and `fileobj` attributes
     |      
     |      Returns
     |      -------
     |      tf : bool
     |          True if `other` has the same filename (or both have None) and the
     |          same fileobj (or both have None
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  file_like
     |      Return ``self.fileobj`` if not None, otherwise ``self.filename``
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __slotnames__ = []
    
    class FileHolderError(builtins.Exception)
     |  Method resolution order:
     |      FileHolderError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    copy_file_map(file_map: 'FileMap') -> 'FileMap'
        Copy mapping of fileholders given by `file_map`
        
        Parameters
        ----------
        file_map : mapping
           mapping of ``FileHolder`` instances
        
        Returns
        -------
        fm_copy : dict
           Copy of `file_map`, using shallow copy of ``FileHolder``\s

DATA
    FileMap = typing.Mapping[str, nibabel.fileholders.FileHolder]
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/fileholders.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& filename_parser &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.filename_parser in nibabel:

NAME
    nibabel.filename_parser - Create filename pairs, triplets etc, with expected extensions

CLASSES
    builtins.Exception(builtins.BaseException)
        TypesFilenamesError
    
    class TypesFilenamesError(builtins.Exception)
     |  Method resolution order:
     |      TypesFilenamesError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    parse_filename(filename: 'FileSpec', types_exts: 'ty.Sequence[ExtensionSpec]', trailing_suffixes: 'ty.Sequence[str]', match_case: 'bool' = False) -> 'tuple[str, str, str | None, str | None]'
        Split filename into fileroot, extension, trailing suffix; guess type.
        
        Parameters
        ----------
        filename : str or os.PathLike
           filename in which to search for type extensions
        types_exts : sequence of sequences
           sequence of (name, extension) str sequences defining type to
           extension mapping.
        trailing_suffixes : sequence of strings
            suffixes that should be ignored when looking for
            extensions
        match_case : bool, optional
           If True, match case of extensions and trailing suffixes when
           searching in `filename`, otherwise do case-insensitive match.
        
        Returns
        -------
        pth : str
           path with any matching extensions or trailing suffixes removed
        ext : str
           If there were any matching extensions, in `types_exts` return
           that; otherwise return extension derived from
           ``os.path.splitext``.
        trailing : str
           If there were any matching `trailing_suffixes` return that
           matching suffix, otherwise ''
        guessed_type : str
           If we found a matching extension in `types_exts` return the
           corresponding ``type``
        
        Examples
        --------
        >>> types_exts = (('t1', 'ext1'),('t2', 'ext2'))
        >>> parse_filename('/path/fname.funny', types_exts, ())
        ('/path/fname', '.funny', None, None)
        >>> parse_filename('/path/fnameext2', types_exts, ())
        ('/path/fname', 'ext2', None, 't2')
        >>> parse_filename('/path/fnameext2', types_exts, ('.gz',))
        ('/path/fname', 'ext2', None, 't2')
        >>> parse_filename('/path/fnameext2.gz', types_exts, ('.gz',))
        ('/path/fname', 'ext2', '.gz', 't2')
    
    splitext_addext(filename: 'FileSpec', addexts: 'ty.Sequence[str]' = ('.gz', '.bz2', '.zst'), match_case: 'bool' = False) -> 'tuple[str, str, str]'
        Split ``/pth/fname.ext.gz`` into ``/pth/fname, .ext, .gz``
        
        where ``.gz`` may be any of passed `addext` trailing suffixes.
        
        Parameters
        ----------
        filename : str or os.PathLike
           filename that may end in any or none of `addexts`
        match_case : bool, optional
           If True, match case of `addexts` and `filename`, otherwise do
           case-insensitive match.
        
        Returns
        -------
        froot : str
           Root of filename - e.g. ``/pth/fname`` in example above
        ext : str
           Extension, where extension is not in `addexts` - e.g. ``.ext`` in
           example above
        addext : str
           Any suffixes appearing in `addext` occurring at end of filename
        
        Examples
        --------
        >>> splitext_addext('fname.ext.gz')
        ('fname', '.ext', '.gz')
        >>> splitext_addext('fname.ext')
        ('fname', '.ext', '')
        >>> splitext_addext('fname.ext.foo', ('.foo', '.bar'))
        ('fname', '.ext', '.foo')
    
    types_filenames(template_fname: 'FileSpec', types_exts: 'ty.Sequence[ExtensionSpec]', trailing_suffixes: 'ty.Sequence[str]' = ('.gz', '.bz2'), enforce_extensions: 'bool' = True, match_case: 'bool' = False) -> 'dict[str, str]'
        Return filenames with standard extensions from template name
        
        The typical case is returning image and header filenames for an
        Analyze image, that expects an 'image' file type with extension ``.img``,
        and a 'header' file type, with extension ``.hdr``.
        
        Parameters
        ----------
        template_fname : str or os.PathLike
           template filename from which to construct output dict of
           filenames, with given `types_exts` type to extension mapping.  If
           ``self.enforce_extensions`` is True, then filename must have one
           of the defined extensions from the types list.  If
           ``self.enforce_extensions`` is False, then the other filenames
           are guessed at by adding extensions to the base filename.
           Ignored suffixes (from `trailing_suffixes`) append themselves to
           the end of all the filenames.
        types_exts : sequence of sequences
           sequence of (name, extension) str sequences defining type to
           extension mapping.
        trailing_suffixes : sequence of strings, optional
            suffixes that should be ignored when looking for
            extensions - default is ``('.gz', '.bz2')``
        enforce_extensions : {True, False}, optional
            If True, raise an error when attempting to set value to
            type which has the wrong extension
        match_case : bool, optional
           If True, match case of extensions and trailing suffixes when
           searching in `template_fname`, otherwise do case-insensitive
           match.
        
        Returns
        -------
        types_fnames : dict
           dict with types as keys, and generated filenames as values.  The
           types are given by the first elements of the tuples in
           `types_exts`.
        
        Examples
        --------
        >>> types_exts = (('t1','.ext1'),('t2', '.ext2'))
        >>> tfns = types_filenames('/path/test.ext1', types_exts)
        >>> tfns == {'t1': '/path/test.ext1', 't2': '/path/test.ext2'}
        True
        
        Bare file roots without extensions get them added
        
        >>> tfns = types_filenames('/path/test', types_exts)
        >>> tfns == {'t1': '/path/test.ext1', 't2': '/path/test.ext2'}
        True
        
        With enforce_extensions == False, allow first type to have any
        extension.
        
        >>> tfns = types_filenames('/path/test.funny', types_exts,
        ...                        enforce_extensions=False)
        >>> tfns == {'t1': '/path/test.funny', 't2': '/path/test.ext2'}
        True

DATA
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/filename_parser.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& fileslice &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.fileslice in nibabel:

NAME
    nibabel.fileslice - Utilities for getting array slices out of file-like objects

FUNCTIONS
    calc_slicedefs(sliceobj, in_shape, itemsize, offset, order, heuristic=<function threshold_heuristic at 0x10ea271f0>)
        Return parameters for slicing array with `sliceobj` given memory layout
        
        Calculate the best combination of skips / (read + discard) to use for
        reading the data from disk / memory, then generate corresponding
        `segments`, the disk offsets and read lengths to read the memory.  If we
        have chosen some (read + discard) optimization, then we need to discard the
        surplus values from the read array using `post_slicers`, a slicing tuple
        that takes the array as read from a file-like object, and returns the array
        we want.
        
        Parameters
        ----------
        sliceobj : object
            something that can be used to slice an array as in ``arr[sliceobj]``
        in_shape : sequence
            shape of underlying array to be sliced
        itemsize : int
            element size in array (in bytes)
        offset : int
            offset of array data in underlying file or memory buffer
        order : {'C', 'F'}
            memory layout of underlying array
        heuristic : callable, optional
            function taking slice object, dim_len, stride length as arguments,
            returning one of 'full', 'contiguous', None.  See
            :func:`optimize_slicer` and :func:`threshold_heuristic`
        
        Returns
        -------
        segments : list
            list of 2 element lists where lists are (offset, length), giving
            absolute memory offset in bytes and number of bytes to read
        read_shape : tuple
            shape with which to interpret memory as read from `segments`.
            Interpreting the memory read from `segments` with this shape, and a
            dtype, gives an intermediate array - call this ``R``
        post_slicers : tuple
            Any new slicing to be applied to the array ``R`` after reading via
            `segments` and reshaping via `read_shape`.  Slices are in terms of
            `read_shape`.  If empty, no new slicing to apply
    
    canonical_slicers(sliceobj, shape, check_inds=True)
        Return canonical version of `sliceobj` for array shape `shape`
        
        `sliceobj` is a slicer for an array ``A`` implied by `shape`.
        
        * Expand `sliceobj` with ``slice(None)`` to add any missing (implied) axes
          in `sliceobj`
        * Find any slicers in `sliceobj` that do a full axis slice and replace by
          ``slice(None)``
        * Replace any floating point values for slicing with integers
        * Replace negative integer slice values with equivalent positive integers.
        
        Does not handle fancy indexing (indexing with arrays or array-like indices)
        
        Parameters
        ----------
        sliceobj : object
            something that can be used to slice an array as in ``arr[sliceobj]``
        shape : sequence
            shape of array that will be indexed by `sliceobj`
        check_inds : {True, False}, optional
            Whether to check if integer indices are out of bounds
        
        Returns
        -------
        can_slicers : tuple
            version of `sliceobj` for which Ellipses have been expanded, missing
            (implied) dimensions have been appended, and slice objects equivalent
            to ``slice(None)`` have been replaced by ``slice(None)``, integer axes
            have been checked, and negative indices set to positive equivalent
    
    fileslice(fileobj, sliceobj, shape, dtype, offset=0, order='C', heuristic=<function threshold_heuristic at 0x10ea271f0>, lock=None)
        Slice array in `fileobj` using `sliceobj` slicer and array definitions
        
        `fileobj` contains the contiguous binary data for an array ``A`` of shape,
        dtype, memory layout `shape`, `dtype`, `order`, with the binary data
        starting at file offset `offset`.
        
        Our job is to return the sliced array ``A[sliceobj]`` in the most efficient
        way in terms of memory and time.
        
        Sometimes it will be quicker to read memory that we will later throw away,
        to save time we might lose doing short seeks on `fileobj`.  Call these
        alternatives: (read + discard); and skip.  This routine guesses when to
        (read+discard) or skip using the callable `heuristic`, with a default using
        a hard threshold for the memory gap large enough to prefer a skip.
        
        Parameters
        ----------
        fileobj : file-like object
            file-like object, opened for reading in binary mode. Implements
            ``read`` and ``seek``.
        sliceobj : object
            something that can be used to slice an array as in ``arr[sliceobj]``.
        shape : sequence
            shape of full array inside `fileobj`.
        dtype : dtype specifier
            dtype of array inside `fileobj`, or input to ``numpy.dtype`` to specify
            array dtype.
        offset : int, optional
            offset of array data within `fileobj`
        order : {'C', 'F'}, optional
            memory layout of array in `fileobj`.
        heuristic : callable, optional
            function taking slice object, axis length, stride length as arguments,
            returning one of 'full', 'contiguous', None.  See
            :func:`optimize_slicer` and see :func:`threshold_heuristic` for an
            example.
        lock : {None, threading.Lock, lock-like} optional
            If provided, used to ensure that paired calls to ``seek`` and ``read``
            cannot be interrupted by another thread accessing the same ``fileobj``.
            Each thread which accesses the same file via ``read_segments`` must
            share a lock in order to ensure that the file access is thread-safe.
            A lock does not need to be provided for single-threaded access. The
            default value (``None``) results in a lock-like object  (a
            ``_NullLock``) which does not do anything.
        
        Returns
        -------
        sliced_arr : array
            Array in `fileobj` as sliced with `sliceobj`
    
    fill_slicer(slicer, in_len)
        Return slice object with Nones filled out to match `in_len`
        
        Also fixes too large stop / start values according to slice() slicing
        rules.
        
        The returned slicer can have a None as `slicer.stop` if `slicer.step` is
        negative and the input `slicer.stop` is None. This is because we can't
        represent the ``stop`` as an integer, because -1 has a different meaning.
        
        Parameters
        ----------
        slicer : slice object
        in_len : int
            length of axis on which `slicer` will be applied
        
        Returns
        -------
        can_slicer : slice object
            slice with start, stop, step set to explicit values, with the exception
            of ``stop`` for negative step, which is None for the case of slicing
            down through the first element
    
    is_fancy(sliceobj)
        Returns True if sliceobj is attempting fancy indexing
        
        Parameters
        ----------
        sliceobj : object
            something that can be used to slice an array as in ``arr[sliceobj]``
        
        Returns
        -------
        tf: bool
            True if sliceobj represents fancy indexing, False for basic indexing
    
    optimize_read_slicers(sliceobj, in_shape, itemsize, heuristic)
        Calculates slices to read from disk, and apply after reading
        
        Parameters
        ----------
        sliceobj : object
            something that can be used to slice an array as in ``arr[sliceobj]``.
            Can be assumed to be canonical in the sense of ``canonical_slicers``
        in_shape : sequence
            shape of underlying array to be sliced.  Array for `in_shape` assumed
            to be already in 'F' order. Reorder shape / sliceobj for slicing a 'C'
            array before passing to this function.
        itemsize : int
            element size in array (bytes)
        heuristic : callable
            function taking slice object, axis length, and stride length as
            arguments, returning one of 'full', 'contiguous', None.  See
            :func:`optimize_slicer`; see :func:`threshold_heuristic` for an
            example.
        
        Returns
        -------
        read_slicers : tuple
            `sliceobj` maybe rephrased to fill out dimensions that are better read
            from disk and later trimmed to their original size with `post_slicers`.
            `read_slicers` implies a block of memory to be read from disk. The
            actual disk positions come from `slicers2segments` run over
            `read_slicers`. Includes any ``newaxis`` dimensions in `sliceobj`
        post_slicers : tuple
            Any new slicing to be applied to the read array after reading.  The
            `post_slicers` discard any memory that we read to save time, but that
            we don't need for the slice.  Include any ``newaxis`` dimension added
            by `sliceobj`
    
    optimize_slicer(slicer, dim_len, all_full, is_slowest, stride, heuristic=<function threshold_heuristic at 0x10ea271f0>)
        Return maybe modified slice and post-slice slicing for `slicer`
        
        Parameters
        ----------
        slicer : slice object or int
        dim_len : int
            length of axis along which to slice
        all_full : bool
            Whether dimensions up until now have been full (all elements)
        is_slowest : bool
            Whether this dimension is the slowest changing in memory / on disk
        stride : int
            size of one step along this axis
        heuristic : callable, optional
            function taking slice object, dim_len, stride length as arguments,
            returning one of 'full', 'contiguous', None. See
            :func:`threshold_heuristic` for an example.
        
        Returns
        -------
        to_read : slice object or int
            maybe modified slice based on `slicer` expressing what data should be
            read from an underlying file or buffer. `to_read` must always have
            positive ``step`` (because we don't want to go backwards in the buffer
            / file)
        post_slice : slice object
            slice to be applied after array has been read.  Applies any
            transformations in `slicer` that have not been applied in `to_read`. If
            axis will be dropped by `to_read` slicing, so no slicing would make
            sense, return string ``dropped``
        
        Notes
        -----
        This is the heart of the algorithm for making segments from slice objects.
        
        A contiguous slice is a slice with ``slice.step in (1, -1)``
        
        A full slice is a continuous slice returning all elements.
        
        The main question we have to ask is whether we should transform `to_read`,
        `post_slice` to prefer a full read and partial slice.  We only do this in
        the case of all_full==True.  In this case we might benefit from reading a
        continuous chunk of data even if the slice is not continuous, or reading
        all the data even if the slice is not full. Apply a heuristic `heuristic`
        to decide whether to do this, and adapt `to_read` and `post_slice` slice
        accordingly.
        
        Otherwise (apart from constraint to be positive) return `to_read` unaltered
        and `post_slice` as ``slice(None)``
    
    predict_shape(sliceobj, in_shape)
        Predict shape of array from slicing array shape `shape` with `sliceobj`
        
        Parameters
        ----------
        sliceobj : object
            something that can be used to slice an array as in ``arr[sliceobj]``
        in_shape : sequence
            shape of array that could be sliced by `sliceobj`
        
        Returns
        -------
        out_shape : tuple
            predicted shape arising from slicing array shape `in_shape` with
            `sliceobj`
    
    read_segments(fileobj, segments, n_bytes, lock=None)
        Read `n_bytes` byte data implied by `segments` from `fileobj`
        
        Parameters
        ----------
        fileobj : file-like object
            Implements `seek` and `read`
        segments : sequence
            list of 2 sequences where sequences are (offset, length), giving
            absolute file offset in bytes and number of bytes to read
        n_bytes : int
            total number of bytes that will be read
        lock : {None, threading.Lock, lock-like} optional
            If provided, used to ensure that paired calls to ``seek`` and ``read``
            cannot be interrupted by another thread accessing the same ``fileobj``.
            Each thread which accesses the same file via ``read_segments`` must
            share a lock in order to ensure that the file access is thread-safe.
            A lock does not need to be provided for single-threaded access. The
            default value (``None``) results in a lock-like object  (a
            ``_NullLock``) which does not do anything.
        
        Returns
        -------
        buffer : buffer object
            object implementing buffer protocol, such as byte string or ndarray or
            mmap or ctypes ``c_char_array``
    
    reduce(...)
        reduce(function, sequence[, initial]) -> value
        
        Apply a function of two arguments cumulatively to the items of a sequence,
        from left to right, so as to reduce the sequence to a single value.
        For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
        ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
        of the sequence in the calculation, and serves as a default when the
        sequence is empty.
    
    slice2len(slicer, in_len)
        Output length after slicing original length `in_len` with `slicer`
        Parameters
        ----------
        slicer : slice object
        in_len : int
        
        Returns
        -------
        out_len : int
            Length after slicing
        
        Notes
        -----
        Returns same as ``len(np.arange(in_len)[slicer])``
    
    slice2outax(ndim, sliceobj)
        Matching output axes for input array ndim `ndim` and slice `sliceobj`
        
        Parameters
        ----------
        ndim : int
            number of axes in input array
        sliceobj : object
            something that can be used to slice an array as in ``arr[sliceobj]``
        
        Returns
        -------
        out_ax_inds : tuple
            Say ``A` is a (pretend) input array of `ndim` dimensions. Say ``B =
            A[sliceobj]``.  `out_ax_inds` has one value per axis in ``A`` giving
            corresponding axis in ``B``.
    
    slicers2segments(read_slicers, in_shape, offset, itemsize)
        Get segments from `read_slicers` given `in_shape` and memory steps
        
        Parameters
        ----------
        read_slicers : object
            something that can be used to slice an array as in ``arr[sliceobj]``
            Slice objects can by be assumed canonical as in ``canonical_slicers``,
            and positive as in ``_positive_slice``
        in_shape : sequence
            shape of underlying array on disk before reading
        offset : int
            offset of array data in underlying file or memory buffer
        itemsize : int
            element size in array (in bytes)
        
        Returns
        -------
        segments : list
            list of 2 element lists where lists are [offset, length], giving
            absolute memory offset in bytes and number of bytes to read
    
    strided_scalar(shape, scalar=0.0)
        Return array shape `shape` where all entries point to value `scalar`
        
        Parameters
        ----------
        shape : sequence
            Shape of output array.
        scalar : scalar
            Scalar value with which to fill array.
        
        Returns
        -------
        strided_arr : array
            Array of shape `shape` for which all values == `scalar`, built by
            setting all strides of `strided_arr` to 0, so the scalar is broadcast
            out to the full array `shape`. `strided_arr` is flagged as not
            `writeable`.
        
            The array is set read-only to avoid a numpy error when broadcasting -
            see https://github.com/numpy/numpy/issues/6491
    
    threshold_heuristic(slicer, dim_len, stride, skip_thresh=256)
        Whether to force full axis read or contiguous read of stepped slice
        
        Allows :func:`fileslice` to sometimes read memory that it will throw away
        in order to get maximum speed.  In other words, trade memory for fewer disk
        reads.
        
        Parameters
        ----------
        slicer : slice object, or int
            If slice, can be assumed to be full as in ``fill_slicer``
        dim_len : int
            length of axis being sliced
        stride : int
            memory distance between elements on this axis
        skip_thresh : int, optional
            Memory gap threshold in bytes above which to prefer skipping memory
            rather than reading it and later discarding.
        
        Returns
        -------
        action : {'full', 'contiguous', None}
            Gives the suggested optimization for reading the data
        
            * 'full' - read whole axis
            * 'contiguous' - read all elements between start and stop
            * None - read only memory needed for output
        
        Notes
        -----
        Let's say we are in the middle of reading a file at the start of some
        memory length $B$ bytes.  We don't need the memory, and we are considering
        whether to read it anyway (then throw it away) (READ) or stop reading, skip
        $B$ bytes and restart reading from there (SKIP).
        
        After trying some more fancy algorithms, a hard threshold (`skip_thresh`)
        for the maximum skip distance seemed to work well, as measured by times on
        ``nibabel.benchmarks.bench_fileslice``

DATA
    SKIP_THRESH = 256

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/fileslice.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& flip_axis &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function flip_axis in module nibabel.orientations:

flip_axis(arr, axis=0)
    Flip contents of `axis` in array `arr`
    
    flip_axis is deprecated. Please use numpy.flip instead.
    
    * deprecated from version: 3.2
    * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0

None
&&&&&&&&&&&&&&&&&&&&&&&&& four_to_three &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function four_to_three in module nibabel.funcs:

four_to_three(img)
    Create 3D images from 4D image by slicing over last axis
    
    Parameters
    ----------
    img :  image
       4D image instance of some class with methods ``get_data``,
       ``header`` and ``affine``, and a class constructor
       allowing klass(data, affine, header)
    
    Returns
    -------
    imgs : list
       list of 3D images

None
&&&&&&&&&&&&&&&&&&&&&&&&& freesurfer &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on package nibabel.freesurfer in nibabel:

NAME
    nibabel.freesurfer - Reading functions for freesurfer files

PACKAGE CONTENTS
    io
    mghformat
    tests (package)

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/freesurfer/__init__.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& funcs &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.funcs in nibabel:

NAME
    nibabel.funcs - Processor functions for images

FUNCTIONS
    as_closest_canonical(img, enforce_diag=False)
        Return `img` with data reordered to be closest to canonical
        
        Canonical order is the ordering of the output axes.
        
        Parameters
        ----------
        img : ``spatialimage``
        enforce_diag : {False, True}, optional
           If True, before transforming image, check if the resulting image
           affine will be close to diagonal, and if not, raise an error
        
        Returns
        -------
        canonical_img : ``spatialimage``
           Version of `img` where the underlying array may have been
           reordered and / or flipped so that axes 0,1,2 are those axes in
           the input data that are, respectively, closest to the output axis
           orientation.  We modify the affine accordingly.  If `img` is
           already has the correct data ordering, we just return `img`
           unmodified.
    
    concat_images(images, check_affines=True, axis=None)
        Concatenate images in list to single image, along specified dimension
        
        Parameters
        ----------
        images : sequence
           sequence of ``SpatialImage`` or filenames of the same dimensionality\s
        check_affines : {True, False}, optional
           If True, then check that all the affines for `images` are nearly
           the same, raising a ``ValueError`` otherwise.  Default is True
        axis : None or int, optional
            If None, concatenates on a new dimension.  This requires all images to
            be the same shape.  If not None, concatenates on the specified
            dimension.  This requires all images to be the same shape, except on
            the specified dimension.
        
        Returns
        -------
        concat_img : ``SpatialImage``
           New image resulting from concatenating `images` across last
           dimension
    
    four_to_three(img)
        Create 3D images from 4D image by slicing over last axis
        
        Parameters
        ----------
        img :  image
           4D image instance of some class with methods ``get_data``,
           ``header`` and ``affine``, and a class constructor
           allowing klass(data, affine, header)
        
        Returns
        -------
        imgs : list
           list of 3D images
    
    squeeze_image(img)
        Return image, remove axes length 1 at end of image shape
        
        For example, an image may have shape (10,20,30,1,1).  In this case
        squeeze will result in an image with shape (10,20,30).  See doctests
        for further description of behavior.
        
        Parameters
        ----------
        img : ``SpatialImage``
        
        Returns
        -------
        squeezed_img : ``SpatialImage``
           Copy of img, such that data, and data shape have been squeezed,
           for dimensions > 3rd, and at the end of the shape list
        
        Examples
        --------
        >>> import nibabel as nf
        >>> shape = (10,20,30,1,1)
        >>> data = np.arange(np.prod(shape), dtype='int32').reshape(shape)
        >>> affine = np.eye(4)
        >>> img = nf.Nifti1Image(data, affine)
        >>> img.shape == (10, 20, 30, 1, 1)
        True
        >>> img2 = squeeze_image(img)
        >>> img2.shape == (10, 20, 30)
        True
        
        If the data are 3D then last dimensions of 1 are ignored
        
        >>> shape = (10,1,1)
        >>> data = np.arange(np.prod(shape), dtype='int32').reshape(shape)
        >>> img = nf.ni1.Nifti1Image(data, affine)
        >>> img.shape == (10, 1, 1)
        True
        >>> img2 = squeeze_image(img)
        >>> img2.shape == (10, 1, 1)
        True
        
        Only *final* dimensions of 1 are squeezed
        
        >>> shape = (1, 1, 5, 1, 2, 1, 1)
        >>> data = data.reshape(shape)
        >>> img = nf.ni1.Nifti1Image(data, affine)
        >>> img.shape == (1, 1, 5, 1, 2, 1, 1)
        True
        >>> img2 = squeeze_image(img)
        >>> img2.shape == (1, 1, 5, 1, 2)
        True

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/funcs.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& get_info &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function get_info in module nibabel:

get_info()

None
&&&&&&&&&&&&&&&&&&&&&&&&& gifti &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on package nibabel.gifti in nibabel:

NAME
    nibabel.gifti - GIfTI format IO

DESCRIPTION
    .. currentmodule:: nibabel.gifti
    
    .. autosummary::
       :toctree: ../generated
    
       gifti

PACKAGE CONTENTS
    gifti
    parse_gifti_fast
    tests (package)
    util

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/gifti/__init__.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& imageclasses &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.imageclasses in nibabel:

NAME
    nibabel.imageclasses - Define supported image classes and names

FUNCTIONS
    spatial_axes_first(img: 'DataobjImage') -> 'bool'
        True if spatial image axes for `img` always precede other axes
        
        Parameters
        ----------
        img : object
            Image object implementing at least ``shape`` attribute.
        
        Returns
        -------
        spatial_axes_first : bool
            True if image only has spatial axes (number of axes < 4) or image type
            known to have spatial axes preceding other axes.

DATA
    KNOWN_SPATIAL_FIRST = (<class 'nibabel.nifti1.Nifti1Pair'>, <class 'ni...
    __annotations__ = {'KNOWN_SPATIAL_FIRST': 'tuple[type[FileBasedImage],...
    all_image_classes = [<class 'nibabel.nifti1.Nifti1Pair'>, <class 'niba...
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/imageclasses.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& imageglobals &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.imageglobals in nibabel:

NAME
    nibabel.imageglobals - Defaults for images and headers

DESCRIPTION
    error_level is the problem level (see BatteryRunners) at which an error will be
    raised, by the batteryrunners ``log_raise`` method.  Thus a level of 0 will
    result in an error for any problem at all, and a level of 50 will mean no errors
    will be raised (unless someone's put some strange problem_level > 50 code in).
    
    ``logger`` is the default logger (python log instance)
    
    To set the log level (log message appears for problem of level >= log level),
    use e.g. ``logger.level = 40``.
    
    As for most loggers, if ``logger.level == 0`` then a default log level is used -
    use ``logger.getEffectiveLevel()`` to see what that default is.
    
    Use ``logger.level = 1`` to see all messages.

CLASSES
    builtins.object
        ErrorLevel
        LoggingOutputSuppressor
    
    class ErrorLevel(builtins.object)
     |  ErrorLevel(level)
     |  
     |  Context manager to set log error level
     |  
     |  Methods defined here:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc, value, tb)
     |  
     |  __init__(self, level)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LoggingOutputSuppressor(builtins.object)
     |  Context manager to prevent global logger from printing
     |  
     |  Methods defined here:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc, value, tb)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    error_level = 40
    logger = <Logger nibabel.global (WARNING)>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/imageglobals.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& imagestats &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.imagestats in nibabel:

NAME
    nibabel.imagestats - Functions for computing image statistics

FUNCTIONS
    count_nonzero_voxels(img)
        Count number of non-zero voxels
        
        Parameters
        ----------
        img : ``SpatialImage``
            All voxels of the mask should be of value 1, background should have value 0.
        
        Returns
        -------
        count : int
            Number of non-zero voxels
    
    mask_volume(img)
        Compute volume of mask image.
        
        Equivalent to "fslstats /path/file.nii -V"
        
        Parameters
        ----------
        img : ``SpatialImage``
            All voxels of the mask should be of value 1, background should have value 0.
        
        
        Returns
        -------
        volume : float
            Volume of mask expressed in mm3.
        
        Examples
        --------
        >>> import numpy as np
        >>> import nibabel as nb
        >>> mask_data = np.zeros((20, 20, 20), dtype='u1')
        >>> mask_data[5:15, 5:15, 5:15] = 1
        >>> nb.imagestats.mask_volume(nb.Nifti1Image(mask_data, np.eye(4)))
        1000.0

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/imagestats.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& info &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.info in nibabel:

NAME
    nibabel.info - Define static nibabel metadata for nibabel

DESCRIPTION
    The long description parameter is used in the nibabel top-level docstring,
    and in building the docs.
    We exec this file in several places, so it cannot import nibabel or use
    relative imports.

DATA
    long_description = '\nRead and write access to common neuroimaging fi....

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/info.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& io_orientation &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function io_orientation in module nibabel.orientations:

io_orientation(affine, tol=None)
    Orientation of input axes in terms of output axes for `affine`
    
    Valid for an affine transformation from ``p`` dimensions to ``q``
    dimensions (``affine.shape == (q + 1, p + 1)``).
    
    The calculated orientations can be used to transform associated
    arrays to best match the output orientations. If ``p`` > ``q``, then
    some of the output axes should be considered dropped in this
    orientation.
    
    Parameters
    ----------
    affine : (q+1, p+1) ndarray-like
       Transformation affine from ``p`` inputs to ``q`` outputs.  Usually this
       will be a shape (4,4) matrix, transforming 3 inputs to 3 outputs, but
       the code also handles the more general case
    tol : {None, float}, optional
       threshold below which SVD values of the affine are considered zero. If
       `tol` is None, and ``S`` is an array with singular values for `affine`,
       and ``eps`` is the epsilon value for datatype of ``S``, then `tol` set
       to ``S.max() * max((q, p)) * eps``
    
    Returns
    -------
    orientations : (p, 2) ndarray
       one row per input axis, where the first value in each row is the closest
       corresponding output axis. The second value in each row is 1 if the
       input axis is in the same direction as the corresponding output axis and
       -1 if it is in the opposite direction.  If a row is [np.nan, np.nan],
       which can happen when p > q, then this row should be considered dropped.

None
&&&&&&&&&&&&&&&&&&&&&&&&& is_proxy &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function is_proxy in module nibabel.arrayproxy:

is_proxy(obj)
    Return True if `obj` is an array proxy

None
&&&&&&&&&&&&&&&&&&&&&&&&& load &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function load in module nibabel.loadsave:

load(filename: 'FileSpec', **kwargs) -> 'FileBasedImage'
    Load file given filename, guessing at file type
    
    Parameters
    ----------
    filename : str or os.PathLike
       specification of file to load
    \*\*kwargs : keyword arguments
        Keyword arguments to format-specific load
    
    Returns
    -------
    img : ``SpatialImage``
       Image of guessed type

None
&&&&&&&&&&&&&&&&&&&&&&&&& loadsave &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.loadsave in nibabel:

NAME
    nibabel.loadsave - Utilities to load and save image objects

FUNCTIONS
    guessed_image_type(filename)
        Guess image type from file `filename`
        
        guessed_image_type deprecated.
        
        * deprecated from version: 3.2
        * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
    
    load(filename: 'FileSpec', **kwargs) -> 'FileBasedImage'
        Load file given filename, guessing at file type
        
        Parameters
        ----------
        filename : str or os.PathLike
           specification of file to load
        \*\*kwargs : keyword arguments
            Keyword arguments to format-specific load
        
        Returns
        -------
        img : ``SpatialImage``
           Image of guessed type
    
    read_img_data(img, prefer='scaled')
        Read data from image associated with files
        
        read_img_data deprecated. Please use ``img.dataobj.get_unscaled()`` instead.
        
        * deprecated from version: 3.2
        * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
    
    save(img: 'FileBasedImage', filename: 'FileSpec', **kwargs) -> 'None'
        Save an image to file adapting format to `filename`
        
        Parameters
        ----------
        img : ``SpatialImage``
           image to save
        filename : str or os.PathLike
           filename (often implying filenames) to which to save `img`.
        \*\*kwargs : keyword arguments
            Keyword arguments to format-specific save
        
        Returns
        -------
        None

DATA
    all_image_classes = [<class 'nibabel.nifti1.Nifti1Pair'>, <class 'niba...
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    deprecate_with_version = <nibabel.deprecator.Deprecator object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/loadsave.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& minc1 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.minc1 in nibabel:

NAME
    nibabel.minc1 - Read MINC1 format images

CLASSES
    builtins.Exception(builtins.BaseException)
        MincError
    builtins.object
        Minc1File
        MincImageArrayProxy
    nibabel.spatialimages.SpatialHeader(nibabel.filebasedimages.FileBasedHeader, nibabel.spatialimages.SpatialProtocol)
        MincHeader
            Minc1Header
    nibabel.spatialimages.SpatialImage(nibabel.dataobj_images.DataobjImage)
        Minc1Image
    
    class Minc1File(builtins.object)
     |  Minc1File(mincfile)
     |  
     |  Class to wrap MINC1 format opened netcdf object
     |  
     |  Although it has some of the same methods as a ``Header``, we use
     |  this only when reading a MINC file, to pull out useful header
     |  information, and for the method of reading the data out
     |  
     |  Methods defined here:
     |  
     |  __init__(self, mincfile)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_affine(self)
     |  
     |  get_data_dtype(self)
     |  
     |  get_data_shape(self)
     |  
     |  get_scaled_data(self, sliceobj=())
     |      Return scaled data for slice definition `sliceobj`
     |      
     |      Parameters
     |      ----------
     |      sliceobj : tuple, optional
     |          slice definition. If not specified, return whole array
     |      
     |      Returns
     |      -------
     |      scaled_arr : array
     |          array from minc file with scaling applied
     |  
     |  get_zooms(self)
     |      Get real-world sizes of voxels
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Minc1Header(MincHeader)
     |  Minc1Header(data_dtype: 'npt.DTypeLike' = <class 'numpy.float32'>, shape: 'Sequence[int]' = (0,), zooms: 'Sequence[float] | None' = None)
     |  
     |  Method resolution order:
     |      Minc1Header
     |      MincHeader
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from MincHeader:
     |  
     |  data_from_fileobj(self, fileobj)
     |      See Header class for an implementation we can't use
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      See Header class for an implementation we can't use
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from MincHeader:
     |  
     |  data_layout = 'C'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |  
     |  __init__(self, data_dtype: 'npt.DTypeLike' = <class 'numpy.float32'>, shape: 'Sequence[int]' = (0,), zooms: 'Sequence[float] | None' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  copy(self: 'SpatialHdrT') -> 'SpatialHdrT'
     |      Copy object to independent representation
     |      
     |      The copy should not be affected by any changes to the original
     |      object.
     |  
     |  get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_best_affine = get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  get_data_shape(self) -> 'tuple[int, ...]'
     |  
     |  get_zooms(self) -> 'tuple[float, ...]'
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  set_data_shape(self, shape: 'Sequence[int]') -> 'None'
     |  
     |  set_zooms(self, zooms: 'Sequence[float]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  from_header(header: 'SpatialProtocol | FileBasedHeader | ty.Mapping | None' = None) -> 'SpatialHdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __annotations__ = {'_dtype': 'np.dtype', '_shape': 'tuple[int, ...]', ...
     |  
     |  __hash__ = None
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |  
     |  write_to(self, fileobj: 'io.IOBase') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  from_fileobj(fileobj: 'io.IOBase') -> 'HdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Minc1Image(nibabel.spatialimages.SpatialImage)
     |  Minc1Image(dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |  
     |  Class for MINC1 format images
     |  
     |  The MINC1 image class uses the default header type, rather than a specific
     |  MINC header type - and reads the relevant information from the MINC file on
     |  load.
     |  
     |  Method resolution order:
     |      Minc1Image
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Class methods defined here:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ImageArrayProxy = <class 'nibabel.minc1.MincImageArrayProxy'>
     |      MINC implementation of array proxy protocol
     |      
     |      The array proxy allows us to freeze the passed fileobj and
     |      header such that it returns the expected data array.
     |  
     |  
     |  __annotations__ = {'_compressed_suffixes': 'tuple[str, ...]', '_meta_s...
     |  
     |  files_types = (('image', '.mnc'),)
     |  
     |  header_class = <class 'nibabel.minc1.Minc1Header'>
     |  
     |  makeable = True
     |  
     |  rw = False
     |  
     |  valid_exts = ('.mnc',)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __init__(self, dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class MincError(builtins.Exception)
     |  Error when reading MINC files
     |  
     |  Method resolution order:
     |      MincError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class MincHeader(nibabel.spatialimages.SpatialHeader)
     |  MincHeader(data_dtype: 'npt.DTypeLike' = <class 'numpy.float32'>, shape: 'Sequence[int]' = (0,), zooms: 'Sequence[float] | None' = None)
     |  
     |  Class to contain header for MINC formats
     |  
     |  Method resolution order:
     |      MincHeader
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  data_from_fileobj(self, fileobj)
     |      See Header class for an implementation we can't use
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      See Header class for an implementation we can't use
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  data_layout = 'C'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |  
     |  __init__(self, data_dtype: 'npt.DTypeLike' = <class 'numpy.float32'>, shape: 'Sequence[int]' = (0,), zooms: 'Sequence[float] | None' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  copy(self: 'SpatialHdrT') -> 'SpatialHdrT'
     |      Copy object to independent representation
     |      
     |      The copy should not be affected by any changes to the original
     |      object.
     |  
     |  get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_best_affine = get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  get_data_shape(self) -> 'tuple[int, ...]'
     |  
     |  get_zooms(self) -> 'tuple[float, ...]'
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  set_data_shape(self, shape: 'Sequence[int]') -> 'None'
     |  
     |  set_zooms(self, zooms: 'Sequence[float]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  from_header(header: 'SpatialProtocol | FileBasedHeader | ty.Mapping | None' = None) -> 'SpatialHdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __annotations__ = {'_dtype': 'np.dtype', '_shape': 'tuple[int, ...]', ...
     |  
     |  __hash__ = None
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |  
     |  write_to(self, fileobj: 'io.IOBase') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  from_fileobj(fileobj: 'io.IOBase') -> 'HdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class MincImageArrayProxy(builtins.object)
     |  MincImageArrayProxy(minc_file)
     |  
     |  MINC implementation of array proxy protocol
     |  
     |  The array proxy allows us to freeze the passed fileobj and
     |  header such that it returns the expected data array.
     |  
     |  Methods defined here:
     |  
     |  __array__(self, dtype=None)
     |      Read data from file and apply scaling, casting to ``dtype``
     |      
     |      If ``dtype`` is unspecified, the dtype is automatically determined.
     |      
     |      Parameters
     |      ----------
     |      dtype : numpy dtype specifier, optional
     |          A numpy dtype specifier specifying the type of the returned array.
     |      
     |      Returns
     |      -------
     |      array
     |          Scaled image data with type `dtype`.
     |  
     |  __getitem__(self, sliceobj)
     |      Read slice `sliceobj` of data from file
     |  
     |  __init__(self, minc_file)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  is_proxy
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/minc1.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& minc2 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.minc2 in nibabel:

NAME
    nibabel.minc2 - Preliminary MINC2 support

DESCRIPTION
    Use with care; I haven't tested this against a wide range of MINC files.
    
    If you have a file that isn't read correctly, please send an example.
    
    Test reading with something like::
    
        import nibabel as nib
        img = nib.load('my_funny.mnc')
        data = img.get_fdata()
        print(data.mean())
        print(data.max())
        print(data.min())
    
    and compare against command line output of::
    
        mincstats my_funny.mnc

CLASSES
    builtins.object
        Hdf5Bunch
    nibabel.minc1.Minc1File(builtins.object)
        Minc2File
    nibabel.minc1.Minc1Image(nibabel.spatialimages.SpatialImage)
        Minc2Image
    nibabel.minc1.MincHeader(nibabel.spatialimages.SpatialHeader)
        Minc2Header
    
    class Hdf5Bunch(builtins.object)
     |  Hdf5Bunch(var)
     |  
     |  Make object for accessing attributes of variable
     |  
     |  Methods defined here:
     |  
     |  __init__(self, var)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Minc2File(nibabel.minc1.Minc1File)
     |  Minc2File(mincfile)
     |  
     |  Class to wrap MINC2 format file
     |  
     |  Although it has some of the same methods as a ``Header``, we use
     |  this only when reading a MINC2 file, to pull out useful header
     |  information, and for the method of reading the data out
     |  
     |  Method resolution order:
     |      Minc2File
     |      nibabel.minc1.Minc1File
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, mincfile)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_data_dtype(self)
     |  
     |  get_data_shape(self)
     |  
     |  get_scaled_data(self, sliceobj=())
     |      Return scaled data for slice definition `sliceobj`
     |      
     |      Parameters
     |      ----------
     |      sliceobj : tuple, optional
     |          slice definition. If not specified, return whole array
     |      
     |      Returns
     |      -------
     |      scaled_arr : array
     |          array from minc file with scaling applied
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.minc1.Minc1File:
     |  
     |  get_affine(self)
     |  
     |  get_zooms(self)
     |      Get real-world sizes of voxels
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.minc1.Minc1File:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Minc2Header(nibabel.minc1.MincHeader)
     |  Minc2Header(data_dtype: 'npt.DTypeLike' = <class 'numpy.float32'>, shape: 'Sequence[int]' = (0,), zooms: 'Sequence[float] | None' = None)
     |  
     |  Method resolution order:
     |      Minc2Header
     |      nibabel.minc1.MincHeader
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.minc1.MincHeader:
     |  
     |  data_from_fileobj(self, fileobj)
     |      See Header class for an implementation we can't use
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      See Header class for an implementation we can't use
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.minc1.MincHeader:
     |  
     |  data_layout = 'C'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |  
     |  __init__(self, data_dtype: 'npt.DTypeLike' = <class 'numpy.float32'>, shape: 'Sequence[int]' = (0,), zooms: 'Sequence[float] | None' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  copy(self: 'SpatialHdrT') -> 'SpatialHdrT'
     |      Copy object to independent representation
     |      
     |      The copy should not be affected by any changes to the original
     |      object.
     |  
     |  get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_best_affine = get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  get_data_shape(self) -> 'tuple[int, ...]'
     |  
     |  get_zooms(self) -> 'tuple[float, ...]'
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  set_data_shape(self, shape: 'Sequence[int]') -> 'None'
     |  
     |  set_zooms(self, zooms: 'Sequence[float]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  from_header(header: 'SpatialProtocol | FileBasedHeader | ty.Mapping | None' = None) -> 'SpatialHdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __annotations__ = {'_dtype': 'np.dtype', '_shape': 'tuple[int, ...]', ...
     |  
     |  __hash__ = None
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |  
     |  write_to(self, fileobj: 'io.IOBase') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  from_fileobj(fileobj: 'io.IOBase') -> 'HdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Minc2Image(nibabel.minc1.Minc1Image)
     |  Minc2Image(dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |  
     |  Class for MINC2 images
     |  
     |  The MINC2 image class uses the default header type, rather than a
     |  specific MINC header type - and reads the relevant information from
     |  the MINC file on load.
     |  
     |  Method resolution order:
     |      Minc2Image
     |      nibabel.minc1.Minc1Image
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Class methods defined here:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'header': <class 'nibabel.minc2.Minc2Header'>}
     |  
     |  header_class = <class 'nibabel.minc2.Minc2Header'>
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.minc1.Minc1Image:
     |  
     |  ImageArrayProxy = <class 'nibabel.minc1.MincImageArrayProxy'>
     |      MINC implementation of array proxy protocol
     |      
     |      The array proxy allows us to freeze the passed fileobj and
     |      header such that it returns the expected data array.
     |  
     |  
     |  files_types = (('image', '.mnc'),)
     |  
     |  makeable = True
     |  
     |  rw = False
     |  
     |  valid_exts = ('.mnc',)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __init__(self, dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/minc2.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& mriutils &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.mriutils in nibabel:

NAME
    nibabel.mriutils - Utilities for calculations related to MRI

FUNCTIONS
    calculate_dwell_time(water_fat_shift, echo_train_length, field_strength)
        Calculate the dwell time
        
        Parameters
        ----------
        water_fat_shift : float
            The water fat shift of the recording, in pixels.
        echo_train_length : int
            The echo train length of the imaging sequence.
        field_strength : float
            Strength of the magnet in Tesla, e.g. 3.0 for a 3T magnet recording.
        
        Returns
        -------
        dwell_time : float
            The dwell time in seconds.
        
        Raises
        ------
        MRIError
            if values are out of range

DATA
    __all__ = ['calculate_dwell_time']

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/mriutils.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& ni1 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.nifti1 in nibabel:

NAME
    nibabel.nifti1 - Read / write access to NIfTI1 image format

DESCRIPTION
    NIfTI1 format defined at http://nifti.nimh.nih.gov/nifti-1/

CLASSES
    builtins.list(builtins.object)
        Nifti1Extensions
    builtins.object
        Nifti1Extension
            Nifti1DicomExtension
    nibabel.analyze.AnalyzeImage(nibabel.spatialimages.SpatialImage)
        Nifti1Pair
            Nifti1Image(Nifti1Pair, nibabel.filebasedimages.SerializableImage)
    nibabel.spm99analyze.SpmAnalyzeHeader(nibabel.analyze.AnalyzeHeader)
        Nifti1Header
            Nifti1PairHeader
    
    class Nifti1DicomExtension(Nifti1Extension)
     |  Nifti1DicomExtension(code, content, parent_hdr=None)
     |  
     |  NIfTI1 DICOM header extension
     |  
     |  This class is a thin wrapper around pydicom to read a binary DICOM
     |  byte string. If pydicom is available, content is exposed as a Dicom Dataset.
     |  Otherwise, this silently falls back to the standard NiftiExtension class
     |  and content is the raw bytestring loaded directly from the nifti file
     |  header.
     |  
     |  Method resolution order:
     |      Nifti1DicomExtension
     |      Nifti1Extension
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, code, content, parent_hdr=None)
     |      Parameters
     |      ----------
     |      code : int or str
     |        Canonical extension code as defined in the NIfTI standard, given
     |        either as integer or corresponding label
     |        (see :data:`~nibabel.nifti1.extension_codes`)
     |      content : bytes or pydicom Dataset or None
     |        Extension content - either a bytestring as read from the NIfTI file
     |        header or an existing pydicom Dataset. If a bystestring, the content
     |        is converted into a Dataset on initialization. If None, a new empty
     |        Dataset is created.
     |      parent_hdr : :class:`~nibabel.nifti1.Nifti1Header`, optional
     |        If a dicom extension belongs to an existing
     |        :class:`~nibabel.nifti1.Nifti1Header`, it may be provided here to
     |        ensure that the DICOM dataset is written with correctly corresponding
     |        endianness; otherwise it is assumed the dataset is little endian.
     |      
     |      Notes
     |      -----
     |      
     |      code should always be 2 for DICOM.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Extension:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  get_code(self)
     |      Return the canonical extension type code.
     |  
     |  get_content(self)
     |      Return the extension content in its runtime representation.
     |  
     |  get_sizeondisk(self)
     |      Return the size of the extension in the NIfTI file.
     |  
     |  write_to(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Nifti1Extension:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti1Extension:
     |  
     |  __hash__ = None
    
    class Nifti1Extension(builtins.object)
     |  Nifti1Extension(code, content)
     |  
     |  Baseclass for NIfTI1 header extensions.
     |  
     |  This class is sufficient to handle very simple text-based extensions, such
     |  as `comment`. More sophisticated extensions should/will be supported by
     |  dedicated subclasses.
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, code, content)
     |      Parameters
     |      ----------
     |      code : int or str
     |        Canonical extension code as defined in the NIfTI standard, given
     |        either as integer or corresponding label
     |        (see :data:`~nibabel.nifti1.extension_codes`)
     |      content : str
     |        Extension content as read from the NIfTI file header. This content is
     |        converted into a runtime representation.
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  get_code(self)
     |      Return the canonical extension type code.
     |  
     |  get_content(self)
     |      Return the extension content in its runtime representation.
     |  
     |  get_sizeondisk(self)
     |      Return the size of the extension in the NIfTI file.
     |  
     |  write_to(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class Nifti1Extensions(builtins.list)
     |  Nifti1Extensions(iterable=(), /)
     |  
     |  Simple extension collection, implemented as a list-subclass.
     |  
     |  Method resolution order:
     |      Nifti1Extensions
     |      builtins.list
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  count(self, ecode)
     |      Returns the number of extensions matching a given *ecode*.
     |      
     |      Parameters
     |      ----------
     |      code : int | str
     |          The ecode can be specified either literal or as numerical value.
     |  
     |  get_codes(self)
     |      Return a list of the extension code of all available extensions
     |  
     |  get_sizeondisk(self)
     |      Return the size of the complete header extensions in the NIfTI file.
     |  
     |  write_to(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_fileobj(fileobj, size, byteswap) from builtins.type
     |      Read header extensions from a fileobj
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |          We begin reading the extensions at the current file position
     |      size : int
     |          Number of bytes to read. If negative, fileobj will be read till its
     |          end.
     |      byteswap : boolean
     |          Flag if byteswapping the read data is required.
     |      
     |      Returns
     |      -------
     |      An extension list. This list might be empty in case not extensions
     |      were present in fileobj.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.list:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iadd__(self, value, /)
     |      Implement self+=value.
     |  
     |  __imul__(self, value, /)
     |      Implement self*=value.
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __reversed__(self, /)
     |      Return a reverse iterator over the list.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  __setitem__(self, key, value, /)
     |      Set self[key] to value.
     |  
     |  __sizeof__(self, /)
     |      Return the size of the list in memory, in bytes.
     |  
     |  append(self, object, /)
     |      Append object to the end of the list.
     |  
     |  clear(self, /)
     |      Remove all items from list.
     |  
     |  copy(self, /)
     |      Return a shallow copy of the list.
     |  
     |  extend(self, iterable, /)
     |      Extend list by appending elements from the iterable.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  insert(self, index, object, /)
     |      Insert object before index.
     |  
     |  pop(self, index=-1, /)
     |      Remove and return item at index (default last).
     |      
     |      Raises IndexError if list is empty or index is out of range.
     |  
     |  remove(self, value, /)
     |      Remove first occurrence of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  reverse(self, /)
     |      Reverse *IN PLACE*.
     |  
     |  sort(self, /, *, key=None, reverse=False)
     |      Sort the list in ascending order and return None.
     |      
     |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
     |      order of two equal elements is maintained).
     |      
     |      If a key function is given, apply it once to each list item and sort them,
     |      ascending or descending, according to their function values.
     |      
     |      The reverse flag can be set to sort in descending order.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.list:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.list:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from builtins.list:
     |  
     |  __hash__ = None
    
    class Nifti1Header(nibabel.spm99analyze.SpmAnalyzeHeader)
     |  Nifti1Header(binaryblock=None, endianness=None, check=True, extensions=())
     |  
     |  Class for NIfTI1 header
     |  
     |  The NIfTI1 header has many more coded fields than the simpler Analyze
     |  variants.  NIfTI1 headers also have extensions.
     |  
     |  Nifti allows the header to be a separate file, as part of a nifti image /
     |  header pair, or to precede the data in a single file.  The object needs to
     |  know which type it is, in order to manage the voxel offset pointing to the
     |  data, extension reading, and writing the correct magic string.
     |  
     |  This class handles the header-preceding-data case.
     |  
     |  Method resolution order:
     |      Nifti1Header
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True, extensions=())
     |      Initialize header from binary data block and extensions
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  copy(self)
     |      Return copy of header
     |      
     |      Take reference to extensions as well as copy of header contents
     |  
     |  get_best_affine(self)
     |      Select best of available transforms
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |  
     |  get_dim_info(self)
     |      Gets NIfTI MRI slice etc dimension information
     |      
     |      Returns
     |      -------
     |      freq : {None,0,1,2}
     |         Which data array axis is frequency encode direction
     |      phase : {None,0,1,2}
     |         Which data array axis is phase encode direction
     |      slice : {None,0,1,2}
     |         Which data array axis is slice encode direction
     |      
     |      where ``data array`` is the array returned by ``get_data``
     |      
     |      Because NIfTI1 files are natively Fortran indexed:
     |        0 is fastest changing in file
     |        1 is medium changing in file
     |        2 is slowest changing in file
     |      
     |      ``None`` means the axis appears not to be specified.
     |      
     |      Examples
     |      --------
     |      See set_dim_info function
     |  
     |  get_intent(self, code_repr='label')
     |      Get intent code, parameters and name
     |      
     |      Parameters
     |      ----------
     |      code_repr : string
     |         string giving output form of intent code representation.
     |         Default is 'label'; use 'code' for integer representation.
     |      
     |      Returns
     |      -------
     |      code : string or integer
     |          intent code, or string describing code
     |      parameters : tuple
     |          parameters for the intent
     |      name : string
     |          intent name
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.get_intent('code')
     |      (3, (10.0,), 'some score')
     |  
     |  get_n_slices(self)
     |      Return the number of slices
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |  
     |  get_qform_quaternion(self)
     |      Compute quaternion from b, c, d of quaternion
     |      
     |      Fills a value by assuming this is a unit quaternion
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |  
     |  get_slice_duration(self)
     |      Get slice duration
     |      
     |      Returns
     |      -------
     |      slice_duration : float
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_slice_duration(0.3)
     |      >>> print("%0.1f" % hdr.get_slice_duration())
     |      0.3
     |      
     |      Notes
     |      -----
     |      The NIfTI1 spec appears to require the slice dimension to be
     |      defined for slice_duration to have meaning.
     |  
     |  get_slice_times(self)
     |      Get slice times from slice timing information
     |      
     |      Returns
     |      -------
     |      slice_times : tuple
     |          Times of acquisition of slices, where 0 is the beginning of
     |          the acquisition, ordered by position in file.  nifti allows
     |          slices at the top and bottom of the volume to be excluded from
     |          the standard slice timing specification, and calls these
     |          "padding slices".  We give padding slices ``None`` as a time
     |          of acquisition
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape((1, 1, 7))
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
     |      >>> slice_times = hdr.get_slice_times()
     |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
     |      True
     |  
     |  get_slope_inter(self)
     |      Get data scaling (slope) and DC offset (intercept) from header data
     |      
     |      Returns
     |      -------
     |      slope : None or float
     |         scaling (slope).  None if there is no valid scaling from these
     |         fields
     |      inter : None or float
     |         offset (intercept). None if there is no valid scaling or if offset
     |         is not finite.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = 1
     |      >>> hdr['scl_inter'] = 1
     |      >>> hdr.get_slope_inter()
     |      (1.0, 1.0)
     |      >>> hdr['scl_inter'] = np.inf
     |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      HeaderDataError: Valid slope but invalid intercept inf
     |  
     |  get_xyzt_units(self)
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> hdr.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> hdr.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> hdr.set_data_dtype('int64')
     |      >>> hdr.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data  # noqa
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Nifti1 images can have up to seven dimensions. For FreeSurfer-variant
     |      Nifti surface files, the first dimension is assumed to correspond to
     |      vertices/nodes on a surface, and dimensions two and three are
     |      constrained to have depth of 1. Dimensions 4-7 are constrained only by
     |      type bounds.
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |      
     |      The Nifti1 `standard header`_ allows for the following "point set"
     |      definition of a surface, not currently implemented in nibabel.
     |      
     |      ::
     |      
     |        To signify that the vector value at each voxel is really a
     |        spatial coordinate (e.g., the vertices or nodes of a surface mesh):
     |          - dataset must have a 5th dimension
     |          - intent_code must be NIFTI_INTENT_POINTSET
     |          - dim[0] = 5
     |          - dim[1] = number of points
     |          - dim[2] = dim[3] = dim[4] = 1
     |          - dim[5] must be the dimensionality of space (e.g., 3 => 3D space).
     |          - intent_name may describe the object these points come from
     |            (e.g., "pial", "gray/white" , "EEG", "MEG").
     |      
     |      .. _issue 100: https://github.com/nipy/nibabel/issues/100
     |      .. _issue 309: https://github.com/nipy/nibabel/issues/309
     |      .. _save77:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82
     |      .. _save50:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56
     |      .. _load_nifti.m:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89
     |      .. _standard header: http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
     |  
     |  set_dim_info(self, freq=None, phase=None, slice=None)
     |      Sets nifti MRI slice etc dimension information
     |      
     |      Parameters
     |      ----------
     |      freq : {None, 0, 1, 2}
     |          axis of data array referring to frequency encoding
     |      phase : {None, 0, 1, 2}
     |          axis of data array referring to phase encoding
     |      slice : {None, 0, 1, 2}
     |          axis of data array referring to slice encoding
     |      
     |      ``None`` means the axis is not specified.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(1, 2, 0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info()
     |      >>> hdr.get_dim_info()
     |      (None, None, None)
     |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, None, 0)
     |      
     |      Notes
     |      -----
     |      This is stored in one byte in the header
     |  
     |  set_intent(self, code, params=(), name='', allow_unknown=False)
     |      Set the intent code, parameters and name
     |      
     |      If parameters are not specified, assumed to be all zero. Each
     |      intent code has a set number of parameters associated. If you
     |      specify any parameters, then it will need to be the correct number
     |      (e.g the "f test" intent requires 2).  However, parameters can
     |      also be set in the file data, so we also allow not setting any
     |      parameters (empty parameter tuple).
     |      
     |      Parameters
     |      ----------
     |      code : integer or string
     |          code specifying nifti intent
     |      params : list, tuple of scalars
     |          parameters relating to intent (see intent_codes)
     |          defaults to ().  Unspecified parameters are set to 0.0
     |      name : string
     |          intent name (description). Defaults to ''
     |      allow_unknown : {False, True}, optional
     |          Allow unknown integer intent codes. If False (the default),
     |          a KeyError is raised on attempts to set the intent
     |          to an unknown code.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent(0)  # no intent
     |      >>> hdr.set_intent('z score')
     |      >>> hdr.get_intent()
     |      ('z score', (), '')
     |      >>> hdr.get_intent('code')
     |      (5, (), '')
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.set_intent('f test', (2, 10), name='another score')
     |      >>> hdr.get_intent()
     |      ('f test', (2.0, 10.0), 'another score')
     |      >>> hdr.set_intent('f test')
     |      >>> hdr.get_intent()
     |      ('f test', (0.0, 0.0), '')
     |      >>> hdr.set_intent(9999, allow_unknown=True) # unknown code
     |      >>> hdr.get_intent()
     |      ('unknown code 9999', (), '')
     |  
     |  set_qform(self, affine, code=None, strip_shears=True)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      
     |      Notes
     |      -----
     |      The qform transform only encodes translations, rotations and
     |      zooms. If there are shear components to the `affine` transform, and
     |      `strip_shears` is True (the default), the written qform gives the
     |      closest approximation where the rotation matrix is orthogonal. This is
     |      to allow quaternion representation. The orthogonal representation
     |      enforces orthogonal axes.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['qform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_qform() == affine)
     |      False
     |      >>> hdr.set_qform(affine)
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> int(hdr['qform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_qform(affine, code='talairach')
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code=None)
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code='scanner')
     |      >>> int(hdr['qform_code'])
     |      1
     |      >>> hdr.set_qform(None)
     |      >>> int(hdr['qform_code'])
     |      0
     |  
     |  set_sform(self, affine, code=None)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['sform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_sform() == affine)
     |      False
     |      >>> hdr.set_sform(affine)
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |      >>> int(hdr['sform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_sform(affine, code='talairach')
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code=None)
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code='scanner')
     |      >>> int(hdr['sform_code'])
     |      1
     |      >>> hdr.set_sform(None)
     |      >>> int(hdr['sform_code'])
     |      0
     |  
     |  set_slice_duration(self, duration)
     |      Set slice duration
     |      
     |      Parameters
     |      ----------
     |      duration : scalar
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      See ``get_slice_duration``
     |  
     |  set_slice_times(self, slice_times)
     |      Set slice times into *hdr*
     |      
     |      Parameters
     |      ----------
     |      slice_times : tuple
     |          tuple of slice times, one value per slice
     |          tuple can include None to indicate no slice time for that slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape([1, 1, 7])
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
     |      >>> hdr.set_slice_times(times)
     |      >>> hdr.get_value_label('slice_code')
     |      'alternating decreasing'
     |      >>> int(hdr['slice_start'])
     |      1
     |      >>> int(hdr['slice_end'])
     |      5
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
     |      set `slope`, `inter` automatically on write.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
     |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
     |         HeaderDataError
     |      inter : None or float, optional
     |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
     |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
     |         HeaderDataError
     |  
     |  set_xyzt_units(self, xyz=None, t=None)
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Extend Analyze header copy by copying extensions from other Nifti
     |      types.
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  exts_klass = <class 'nibabel.nifti1.Nifti1Extensions'>
     |      Simple extension collection, implemented as a list-subclass.
     |  
     |  
     |  has_data_intercept = True
     |  
     |  has_data_slope = True
     |  
     |  is_single = True
     |  
     |  pair_magic = b'ni1'
     |  
     |  pair_vox_offset = 0
     |  
     |  quaternion_threshold = 3.5762786865234375e-07
     |  
     |  single_magic = b'n+1'
     |  
     |  single_vox_offset = 352
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Nifti1Image(Nifti1Pair, nibabel.filebasedimages.SerializableImage)
     |  Nifti1Image(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for single file NIfTI1 format image
     |  
     |  Method resolution order:
     |      Nifti1Image
     |      Nifti1Pair
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.SerializableImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  update_header(self)
     |      Harmonize header with image data and affine
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  files_types = (('image', '.nii'),)
     |  
     |  header_class = <class 'nibabel.nifti1.Nifti1Header'>
     |      Class for NIfTI1 header
     |      
     |      The NIfTI1 header has many more coded fields than the simpler Analyze
     |      variants.  NIfTI1 headers also have extensions.
     |      
     |      Nifti allows the header to be a separate file, as part of a nifti image /
     |      header pair, or to precede the data in a single file.  The object needs to
     |      know which type it is, in order to manage the voxel offset pointing to the
     |      data, extension reading, and writing the correct magic string.
     |      
     |      This class handles the header-preceding-data case.
     |  
     |  
     |  valid_exts = ('.nii',)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Pair:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |      
     |      Notes
     |      -----
     |      
     |      If both a `header` and an `affine` are specified, and the `affine` does
     |      not match the affine that is in the `header`, the `affine` will be used,
     |      but the ``sform_code`` and ``qform_code`` fields in the header will be
     |      re-initialised to their default values. This is performed on the basis
     |      that, if you are changing the affine, you are likely to be changing the
     |      space to which the affine is pointing.  The :meth:`set_sform` and
     |      :meth:`set_qform` methods can be used to update the codes after an image
     |      has been created - see those methods, and the :ref:`manual
     |      <default-sform-qform-codes>` for more details.
     |  
     |  as_reoriented(self, ornt)
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |  
     |  get_data_dtype(self, finalize=False)
     |      Get numpy dtype for data
     |      
     |      If ``set_data_dtype()`` has been called with an alias
     |      and ``finalize`` is ``False``, return the alias.
     |      If ``finalize`` is ``True``, determine the appropriate dtype
     |      from the image data object and set the final dtype in the
     |      header before returning it.
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_qform
     |      get_sform
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_sform
     |      get_qform
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code, dtype, type or alias
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      The following aliases are defined to allow for flexible specification:
     |      
     |        * ``'mask'`` - Alias for ``uint8``
     |        * ``'compat'`` - The nearest Analyze-compatible datatype
     |          (``uint8``, ``int16``, ``int32``, ``float32``)
     |        * ``'smallest'`` - The smallest Analyze-compatible integer
     |          (``uint8``, ``int16``, ``int32``)
     |      
     |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
     |      with a ``finalize=True`` flag. Until then, these aliases are not
     |      written to the header and will not persist to new images.
     |      
     |      Examples
     |      --------
     |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
     |      
     |      >>> img = Nifti1Image(ints, np.eye(4))
     |      >>> img.set_data_dtype(np.uint8)
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('mask')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('compat')
     |      >>> img.get_data_dtype()
     |      'compat'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('<i4')
     |      >>> img.get_data_dtype()
     |      dtype('<i4')
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype()
     |      'smallest'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('uint8')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      
     |      Note that floating point values will not be coerced to ``int``
     |      
     |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> img = Nifti1Image(floats, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype(finalize=True)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Cannot automatically cast array (of type float32) to an integer
     |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
     |      
     |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
     |      >>> img = Nifti1Image(arr, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> img.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> img.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> img.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> img.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> img.set_data_dtype('int64')
     |      >>> img.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform. Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_qform
     |      set_sform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_qform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> img.get_qform(coded=True)
     |      (None, 0)
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_qform(aff2, 'talairach')
     |      >>> qaff, code = img.get_qform(coded=True)
     |      >>> np.all(qaff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  set_sform(self, affine, code=None, **kwargs)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform.  Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_sform
     |      set_qform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_sform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> saff
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> int(code)
     |      2
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_sform(aff2, 'talairach')
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> np.all(saff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |      dtype : dtype-like, optional
     |         The on-disk data type to coerce the data array.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti1Pair:
     |  
     |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  makeable = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.SerializableImage:
     |  
     |  to_bytes(self, **kwargs) -> 'bytes'
     |      Return a ``bytes`` object with the contents of the file that would
     |      be written if the image were saved.
     |      
     |      Parameters
     |      ----------
     |      \*\*kwargs : keyword arguments
     |          Keyword arguments that may be passed to ``img.to_file_map()``
     |      
     |      Returns
     |      -------
     |      bytes
     |          Serialized image
     |  
     |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
     |      Save image to writable IO stream
     |      
     |      Parameters
     |      ----------
     |      io_obj : IOBase object
     |          Writable stream
     |      \*\*kwargs : keyword arguments
     |          Keyword arguments that may be passed to ``img.to_file_map()``
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.SerializableImage:
     |  
     |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
     |      Construct image from a byte string
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      bytestring : bytes
     |          Byte string containing the on-disk representation of an image
     |  
     |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
     |      Load image from readable IO stream
     |      
     |      Convert to BytesIO to enable seeking, if input stream is not seekable
     |      
     |      Parameters
     |      ----------
     |      io_obj : IOBase object
     |          Readable stream
     |  
     |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
     |      Retrieve and load an image from a URL
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      url : str or urllib.request.Request object
     |          URL of file to retrieve
     |      timeout : float, optional
     |          Time (in seconds) to wait for a response
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Nifti1Pair(nibabel.analyze.AnalyzeImage)
     |  Nifti1Pair(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for NIfTI1 format image, header pair
     |  
     |  Method resolution order:
     |      Nifti1Pair
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |      
     |      Notes
     |      -----
     |      
     |      If both a `header` and an `affine` are specified, and the `affine` does
     |      not match the affine that is in the `header`, the `affine` will be used,
     |      but the ``sform_code`` and ``qform_code`` fields in the header will be
     |      re-initialised to their default values. This is performed on the basis
     |      that, if you are changing the affine, you are likely to be changing the
     |      space to which the affine is pointing.  The :meth:`set_sform` and
     |      :meth:`set_qform` methods can be used to update the codes after an image
     |      has been created - see those methods, and the :ref:`manual
     |      <default-sform-qform-codes>` for more details.
     |  
     |  as_reoriented(self, ornt)
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |  
     |  get_data_dtype(self, finalize=False)
     |      Get numpy dtype for data
     |      
     |      If ``set_data_dtype()`` has been called with an alias
     |      and ``finalize`` is ``False``, return the alias.
     |      If ``finalize`` is ``True``, determine the appropriate dtype
     |      from the image data object and set the final dtype in the
     |      header before returning it.
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_qform
     |      get_sform
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_sform
     |      get_qform
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code, dtype, type or alias
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      The following aliases are defined to allow for flexible specification:
     |      
     |        * ``'mask'`` - Alias for ``uint8``
     |        * ``'compat'`` - The nearest Analyze-compatible datatype
     |          (``uint8``, ``int16``, ``int32``, ``float32``)
     |        * ``'smallest'`` - The smallest Analyze-compatible integer
     |          (``uint8``, ``int16``, ``int32``)
     |      
     |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
     |      with a ``finalize=True`` flag. Until then, these aliases are not
     |      written to the header and will not persist to new images.
     |      
     |      Examples
     |      --------
     |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
     |      
     |      >>> img = Nifti1Image(ints, np.eye(4))
     |      >>> img.set_data_dtype(np.uint8)
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('mask')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('compat')
     |      >>> img.get_data_dtype()
     |      'compat'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('<i4')
     |      >>> img.get_data_dtype()
     |      dtype('<i4')
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype()
     |      'smallest'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('uint8')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      
     |      Note that floating point values will not be coerced to ``int``
     |      
     |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> img = Nifti1Image(floats, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype(finalize=True)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Cannot automatically cast array (of type float32) to an integer
     |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
     |      
     |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
     |      >>> img = Nifti1Image(arr, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> img.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> img.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> img.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> img.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> img.set_data_dtype('int64')
     |      >>> img.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform. Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_qform
     |      set_sform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_qform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> img.get_qform(coded=True)
     |      (None, 0)
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_qform(aff2, 'talairach')
     |      >>> qaff, code = img.get_qform(coded=True)
     |      >>> np.all(qaff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  set_sform(self, affine, code=None, **kwargs)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform.  Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_sform
     |      set_qform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_sform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> saff
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> int(code)
     |      2
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_sform(aff2, 'talairach')
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> np.all(saff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |      dtype : dtype-like, optional
     |         The on-disk data type to coerce the data array.
     |  
     |  update_header(self)
     |      Harmonize header with image data and affine
     |      
     |      See AnalyzeImage.update_header for more examples
     |      
     |      Examples
     |      --------
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = Nifti1Image(data, affine)
     |      >>> hdr = img.header
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
     |  
     |  header_class = <class 'nibabel.nifti1.Nifti1PairHeader'>
     |      Class for NIfTI1 pair header
     |  
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'))
     |  
     |  makeable = True
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Nifti1PairHeader(Nifti1Header)
     |  Nifti1PairHeader(binaryblock=None, endianness=None, check=True, extensions=())
     |  
     |  Class for NIfTI1 pair header
     |  
     |  Method resolution order:
     |      Nifti1PairHeader
     |      Nifti1Header
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  is_single = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Header:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True, extensions=())
     |      Initialize header from binary data block and extensions
     |  
     |  copy(self)
     |      Return copy of header
     |      
     |      Take reference to extensions as well as copy of header contents
     |  
     |  get_best_affine(self)
     |      Select best of available transforms
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |  
     |  get_dim_info(self)
     |      Gets NIfTI MRI slice etc dimension information
     |      
     |      Returns
     |      -------
     |      freq : {None,0,1,2}
     |         Which data array axis is frequency encode direction
     |      phase : {None,0,1,2}
     |         Which data array axis is phase encode direction
     |      slice : {None,0,1,2}
     |         Which data array axis is slice encode direction
     |      
     |      where ``data array`` is the array returned by ``get_data``
     |      
     |      Because NIfTI1 files are natively Fortran indexed:
     |        0 is fastest changing in file
     |        1 is medium changing in file
     |        2 is slowest changing in file
     |      
     |      ``None`` means the axis appears not to be specified.
     |      
     |      Examples
     |      --------
     |      See set_dim_info function
     |  
     |  get_intent(self, code_repr='label')
     |      Get intent code, parameters and name
     |      
     |      Parameters
     |      ----------
     |      code_repr : string
     |         string giving output form of intent code representation.
     |         Default is 'label'; use 'code' for integer representation.
     |      
     |      Returns
     |      -------
     |      code : string or integer
     |          intent code, or string describing code
     |      parameters : tuple
     |          parameters for the intent
     |      name : string
     |          intent name
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.get_intent('code')
     |      (3, (10.0,), 'some score')
     |  
     |  get_n_slices(self)
     |      Return the number of slices
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |  
     |  get_qform_quaternion(self)
     |      Compute quaternion from b, c, d of quaternion
     |      
     |      Fills a value by assuming this is a unit quaternion
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |  
     |  get_slice_duration(self)
     |      Get slice duration
     |      
     |      Returns
     |      -------
     |      slice_duration : float
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_slice_duration(0.3)
     |      >>> print("%0.1f" % hdr.get_slice_duration())
     |      0.3
     |      
     |      Notes
     |      -----
     |      The NIfTI1 spec appears to require the slice dimension to be
     |      defined for slice_duration to have meaning.
     |  
     |  get_slice_times(self)
     |      Get slice times from slice timing information
     |      
     |      Returns
     |      -------
     |      slice_times : tuple
     |          Times of acquisition of slices, where 0 is the beginning of
     |          the acquisition, ordered by position in file.  nifti allows
     |          slices at the top and bottom of the volume to be excluded from
     |          the standard slice timing specification, and calls these
     |          "padding slices".  We give padding slices ``None`` as a time
     |          of acquisition
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape((1, 1, 7))
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
     |      >>> slice_times = hdr.get_slice_times()
     |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
     |      True
     |  
     |  get_slope_inter(self)
     |      Get data scaling (slope) and DC offset (intercept) from header data
     |      
     |      Returns
     |      -------
     |      slope : None or float
     |         scaling (slope).  None if there is no valid scaling from these
     |         fields
     |      inter : None or float
     |         offset (intercept). None if there is no valid scaling or if offset
     |         is not finite.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = 1
     |      >>> hdr['scl_inter'] = 1
     |      >>> hdr.get_slope_inter()
     |      (1.0, 1.0)
     |      >>> hdr['scl_inter'] = np.inf
     |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      HeaderDataError: Valid slope but invalid intercept inf
     |  
     |  get_xyzt_units(self)
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> hdr.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> hdr.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> hdr.set_data_dtype('int64')
     |      >>> hdr.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data  # noqa
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Nifti1 images can have up to seven dimensions. For FreeSurfer-variant
     |      Nifti surface files, the first dimension is assumed to correspond to
     |      vertices/nodes on a surface, and dimensions two and three are
     |      constrained to have depth of 1. Dimensions 4-7 are constrained only by
     |      type bounds.
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |      
     |      The Nifti1 `standard header`_ allows for the following "point set"
     |      definition of a surface, not currently implemented in nibabel.
     |      
     |      ::
     |      
     |        To signify that the vector value at each voxel is really a
     |        spatial coordinate (e.g., the vertices or nodes of a surface mesh):
     |          - dataset must have a 5th dimension
     |          - intent_code must be NIFTI_INTENT_POINTSET
     |          - dim[0] = 5
     |          - dim[1] = number of points
     |          - dim[2] = dim[3] = dim[4] = 1
     |          - dim[5] must be the dimensionality of space (e.g., 3 => 3D space).
     |          - intent_name may describe the object these points come from
     |            (e.g., "pial", "gray/white" , "EEG", "MEG").
     |      
     |      .. _issue 100: https://github.com/nipy/nibabel/issues/100
     |      .. _issue 309: https://github.com/nipy/nibabel/issues/309
     |      .. _save77:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82
     |      .. _save50:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56
     |      .. _load_nifti.m:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89
     |      .. _standard header: http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
     |  
     |  set_dim_info(self, freq=None, phase=None, slice=None)
     |      Sets nifti MRI slice etc dimension information
     |      
     |      Parameters
     |      ----------
     |      freq : {None, 0, 1, 2}
     |          axis of data array referring to frequency encoding
     |      phase : {None, 0, 1, 2}
     |          axis of data array referring to phase encoding
     |      slice : {None, 0, 1, 2}
     |          axis of data array referring to slice encoding
     |      
     |      ``None`` means the axis is not specified.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(1, 2, 0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info()
     |      >>> hdr.get_dim_info()
     |      (None, None, None)
     |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, None, 0)
     |      
     |      Notes
     |      -----
     |      This is stored in one byte in the header
     |  
     |  set_intent(self, code, params=(), name='', allow_unknown=False)
     |      Set the intent code, parameters and name
     |      
     |      If parameters are not specified, assumed to be all zero. Each
     |      intent code has a set number of parameters associated. If you
     |      specify any parameters, then it will need to be the correct number
     |      (e.g the "f test" intent requires 2).  However, parameters can
     |      also be set in the file data, so we also allow not setting any
     |      parameters (empty parameter tuple).
     |      
     |      Parameters
     |      ----------
     |      code : integer or string
     |          code specifying nifti intent
     |      params : list, tuple of scalars
     |          parameters relating to intent (see intent_codes)
     |          defaults to ().  Unspecified parameters are set to 0.0
     |      name : string
     |          intent name (description). Defaults to ''
     |      allow_unknown : {False, True}, optional
     |          Allow unknown integer intent codes. If False (the default),
     |          a KeyError is raised on attempts to set the intent
     |          to an unknown code.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent(0)  # no intent
     |      >>> hdr.set_intent('z score')
     |      >>> hdr.get_intent()
     |      ('z score', (), '')
     |      >>> hdr.get_intent('code')
     |      (5, (), '')
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.set_intent('f test', (2, 10), name='another score')
     |      >>> hdr.get_intent()
     |      ('f test', (2.0, 10.0), 'another score')
     |      >>> hdr.set_intent('f test')
     |      >>> hdr.get_intent()
     |      ('f test', (0.0, 0.0), '')
     |      >>> hdr.set_intent(9999, allow_unknown=True) # unknown code
     |      >>> hdr.get_intent()
     |      ('unknown code 9999', (), '')
     |  
     |  set_qform(self, affine, code=None, strip_shears=True)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      
     |      Notes
     |      -----
     |      The qform transform only encodes translations, rotations and
     |      zooms. If there are shear components to the `affine` transform, and
     |      `strip_shears` is True (the default), the written qform gives the
     |      closest approximation where the rotation matrix is orthogonal. This is
     |      to allow quaternion representation. The orthogonal representation
     |      enforces orthogonal axes.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['qform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_qform() == affine)
     |      False
     |      >>> hdr.set_qform(affine)
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> int(hdr['qform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_qform(affine, code='talairach')
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code=None)
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code='scanner')
     |      >>> int(hdr['qform_code'])
     |      1
     |      >>> hdr.set_qform(None)
     |      >>> int(hdr['qform_code'])
     |      0
     |  
     |  set_sform(self, affine, code=None)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['sform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_sform() == affine)
     |      False
     |      >>> hdr.set_sform(affine)
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |      >>> int(hdr['sform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_sform(affine, code='talairach')
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code=None)
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code='scanner')
     |      >>> int(hdr['sform_code'])
     |      1
     |      >>> hdr.set_sform(None)
     |      >>> int(hdr['sform_code'])
     |      0
     |  
     |  set_slice_duration(self, duration)
     |      Set slice duration
     |      
     |      Parameters
     |      ----------
     |      duration : scalar
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      See ``get_slice_duration``
     |  
     |  set_slice_times(self, slice_times)
     |      Set slice times into *hdr*
     |      
     |      Parameters
     |      ----------
     |      slice_times : tuple
     |          tuple of slice times, one value per slice
     |          tuple can include None to indicate no slice time for that slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape([1, 1, 7])
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
     |      >>> hdr.set_slice_times(times)
     |      >>> hdr.get_value_label('slice_code')
     |      'alternating decreasing'
     |      >>> int(hdr['slice_start'])
     |      1
     |      >>> int(hdr['slice_end'])
     |      5
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
     |      set `slope`, `inter` automatically on write.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
     |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
     |         HeaderDataError
     |      inter : None or float, optional
     |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
     |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
     |         HeaderDataError
     |  
     |  set_xyzt_units(self, xyz=None, t=None)
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Nifti1Header:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Extend Analyze header copy by copying extensions from other Nifti
     |      types.
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti1Header:
     |  
     |  exts_klass = <class 'nibabel.nifti1.Nifti1Extensions'>
     |      Simple extension collection, implemented as a list-subclass.
     |  
     |  
     |  has_data_intercept = True
     |  
     |  has_data_slope = True
     |  
     |  pair_magic = b'ni1'
     |  
     |  pair_vox_offset = 0
     |  
     |  quaternion_threshold = 3.5762786865234375e-07
     |  
     |  single_magic = b'n+1'
     |  
     |  single_vox_offset = 352
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta

FUNCTIONS
    load(filename)
        Load NIfTI1 single or pair from `filename`
        
        Parameters
        ----------
        filename : str
            filename of image to be loaded
        
        Returns
        -------
        img : Nifti1Image or Nifti1Pair
            NIfTI1 single or pair image instance
        
        Raises
        ------
        ImageFileError
            if `filename` doesn't look like NIfTI1;
        OSError
            if `filename` does not exist.
    
    save(img, filename)
        Save NIfTI1 single or pair to `filename`
        
        Parameters
        ----------
        filename : str
            filename to which to save image

DATA
    __annotations__ = {}
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    data_type_codes = <nibabel.volumeutils.Recoder object>
    endian_codes = <nibabel.volumeutils.Recoder object>
    extension_codes = <nibabel.volumeutils.Recoder object>
    have_dicom = True
    header_dtd = [('sizeof_hdr', 'i4'), ('data_type', 'S10'), ('db_name', ...
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (4,...
    intent_codes = <nibabel.volumeutils.Recoder object>
    slice_order_codes = <nibabel.volumeutils.Recoder object>
    unit_codes = <nibabel.volumeutils.Recoder object>
    xform_codes = <nibabel.volumeutils.Recoder object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/nifti1.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& nifti1 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.nifti1 in nibabel:

NAME
    nibabel.nifti1 - Read / write access to NIfTI1 image format

DESCRIPTION
    NIfTI1 format defined at http://nifti.nimh.nih.gov/nifti-1/

CLASSES
    builtins.list(builtins.object)
        Nifti1Extensions
    builtins.object
        Nifti1Extension
            Nifti1DicomExtension
    nibabel.analyze.AnalyzeImage(nibabel.spatialimages.SpatialImage)
        Nifti1Pair
            Nifti1Image(Nifti1Pair, nibabel.filebasedimages.SerializableImage)
    nibabel.spm99analyze.SpmAnalyzeHeader(nibabel.analyze.AnalyzeHeader)
        Nifti1Header
            Nifti1PairHeader
    
    class Nifti1DicomExtension(Nifti1Extension)
     |  Nifti1DicomExtension(code, content, parent_hdr=None)
     |  
     |  NIfTI1 DICOM header extension
     |  
     |  This class is a thin wrapper around pydicom to read a binary DICOM
     |  byte string. If pydicom is available, content is exposed as a Dicom Dataset.
     |  Otherwise, this silently falls back to the standard NiftiExtension class
     |  and content is the raw bytestring loaded directly from the nifti file
     |  header.
     |  
     |  Method resolution order:
     |      Nifti1DicomExtension
     |      Nifti1Extension
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, code, content, parent_hdr=None)
     |      Parameters
     |      ----------
     |      code : int or str
     |        Canonical extension code as defined in the NIfTI standard, given
     |        either as integer or corresponding label
     |        (see :data:`~nibabel.nifti1.extension_codes`)
     |      content : bytes or pydicom Dataset or None
     |        Extension content - either a bytestring as read from the NIfTI file
     |        header or an existing pydicom Dataset. If a bystestring, the content
     |        is converted into a Dataset on initialization. If None, a new empty
     |        Dataset is created.
     |      parent_hdr : :class:`~nibabel.nifti1.Nifti1Header`, optional
     |        If a dicom extension belongs to an existing
     |        :class:`~nibabel.nifti1.Nifti1Header`, it may be provided here to
     |        ensure that the DICOM dataset is written with correctly corresponding
     |        endianness; otherwise it is assumed the dataset is little endian.
     |      
     |      Notes
     |      -----
     |      
     |      code should always be 2 for DICOM.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Extension:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  get_code(self)
     |      Return the canonical extension type code.
     |  
     |  get_content(self)
     |      Return the extension content in its runtime representation.
     |  
     |  get_sizeondisk(self)
     |      Return the size of the extension in the NIfTI file.
     |  
     |  write_to(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Nifti1Extension:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti1Extension:
     |  
     |  __hash__ = None
    
    class Nifti1Extension(builtins.object)
     |  Nifti1Extension(code, content)
     |  
     |  Baseclass for NIfTI1 header extensions.
     |  
     |  This class is sufficient to handle very simple text-based extensions, such
     |  as `comment`. More sophisticated extensions should/will be supported by
     |  dedicated subclasses.
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, code, content)
     |      Parameters
     |      ----------
     |      code : int or str
     |        Canonical extension code as defined in the NIfTI standard, given
     |        either as integer or corresponding label
     |        (see :data:`~nibabel.nifti1.extension_codes`)
     |      content : str
     |        Extension content as read from the NIfTI file header. This content is
     |        converted into a runtime representation.
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  get_code(self)
     |      Return the canonical extension type code.
     |  
     |  get_content(self)
     |      Return the extension content in its runtime representation.
     |  
     |  get_sizeondisk(self)
     |      Return the size of the extension in the NIfTI file.
     |  
     |  write_to(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class Nifti1Extensions(builtins.list)
     |  Nifti1Extensions(iterable=(), /)
     |  
     |  Simple extension collection, implemented as a list-subclass.
     |  
     |  Method resolution order:
     |      Nifti1Extensions
     |      builtins.list
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  count(self, ecode)
     |      Returns the number of extensions matching a given *ecode*.
     |      
     |      Parameters
     |      ----------
     |      code : int | str
     |          The ecode can be specified either literal or as numerical value.
     |  
     |  get_codes(self)
     |      Return a list of the extension code of all available extensions
     |  
     |  get_sizeondisk(self)
     |      Return the size of the complete header extensions in the NIfTI file.
     |  
     |  write_to(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_fileobj(fileobj, size, byteswap) from builtins.type
     |      Read header extensions from a fileobj
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |          We begin reading the extensions at the current file position
     |      size : int
     |          Number of bytes to read. If negative, fileobj will be read till its
     |          end.
     |      byteswap : boolean
     |          Flag if byteswapping the read data is required.
     |      
     |      Returns
     |      -------
     |      An extension list. This list might be empty in case not extensions
     |      were present in fileobj.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.list:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iadd__(self, value, /)
     |      Implement self+=value.
     |  
     |  __imul__(self, value, /)
     |      Implement self*=value.
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __reversed__(self, /)
     |      Return a reverse iterator over the list.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  __setitem__(self, key, value, /)
     |      Set self[key] to value.
     |  
     |  __sizeof__(self, /)
     |      Return the size of the list in memory, in bytes.
     |  
     |  append(self, object, /)
     |      Append object to the end of the list.
     |  
     |  clear(self, /)
     |      Remove all items from list.
     |  
     |  copy(self, /)
     |      Return a shallow copy of the list.
     |  
     |  extend(self, iterable, /)
     |      Extend list by appending elements from the iterable.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  insert(self, index, object, /)
     |      Insert object before index.
     |  
     |  pop(self, index=-1, /)
     |      Remove and return item at index (default last).
     |      
     |      Raises IndexError if list is empty or index is out of range.
     |  
     |  remove(self, value, /)
     |      Remove first occurrence of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  reverse(self, /)
     |      Reverse *IN PLACE*.
     |  
     |  sort(self, /, *, key=None, reverse=False)
     |      Sort the list in ascending order and return None.
     |      
     |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
     |      order of two equal elements is maintained).
     |      
     |      If a key function is given, apply it once to each list item and sort them,
     |      ascending or descending, according to their function values.
     |      
     |      The reverse flag can be set to sort in descending order.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.list:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.list:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from builtins.list:
     |  
     |  __hash__ = None
    
    class Nifti1Header(nibabel.spm99analyze.SpmAnalyzeHeader)
     |  Nifti1Header(binaryblock=None, endianness=None, check=True, extensions=())
     |  
     |  Class for NIfTI1 header
     |  
     |  The NIfTI1 header has many more coded fields than the simpler Analyze
     |  variants.  NIfTI1 headers also have extensions.
     |  
     |  Nifti allows the header to be a separate file, as part of a nifti image /
     |  header pair, or to precede the data in a single file.  The object needs to
     |  know which type it is, in order to manage the voxel offset pointing to the
     |  data, extension reading, and writing the correct magic string.
     |  
     |  This class handles the header-preceding-data case.
     |  
     |  Method resolution order:
     |      Nifti1Header
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True, extensions=())
     |      Initialize header from binary data block and extensions
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  copy(self)
     |      Return copy of header
     |      
     |      Take reference to extensions as well as copy of header contents
     |  
     |  get_best_affine(self)
     |      Select best of available transforms
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |  
     |  get_dim_info(self)
     |      Gets NIfTI MRI slice etc dimension information
     |      
     |      Returns
     |      -------
     |      freq : {None,0,1,2}
     |         Which data array axis is frequency encode direction
     |      phase : {None,0,1,2}
     |         Which data array axis is phase encode direction
     |      slice : {None,0,1,2}
     |         Which data array axis is slice encode direction
     |      
     |      where ``data array`` is the array returned by ``get_data``
     |      
     |      Because NIfTI1 files are natively Fortran indexed:
     |        0 is fastest changing in file
     |        1 is medium changing in file
     |        2 is slowest changing in file
     |      
     |      ``None`` means the axis appears not to be specified.
     |      
     |      Examples
     |      --------
     |      See set_dim_info function
     |  
     |  get_intent(self, code_repr='label')
     |      Get intent code, parameters and name
     |      
     |      Parameters
     |      ----------
     |      code_repr : string
     |         string giving output form of intent code representation.
     |         Default is 'label'; use 'code' for integer representation.
     |      
     |      Returns
     |      -------
     |      code : string or integer
     |          intent code, or string describing code
     |      parameters : tuple
     |          parameters for the intent
     |      name : string
     |          intent name
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.get_intent('code')
     |      (3, (10.0,), 'some score')
     |  
     |  get_n_slices(self)
     |      Return the number of slices
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |  
     |  get_qform_quaternion(self)
     |      Compute quaternion from b, c, d of quaternion
     |      
     |      Fills a value by assuming this is a unit quaternion
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |  
     |  get_slice_duration(self)
     |      Get slice duration
     |      
     |      Returns
     |      -------
     |      slice_duration : float
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_slice_duration(0.3)
     |      >>> print("%0.1f" % hdr.get_slice_duration())
     |      0.3
     |      
     |      Notes
     |      -----
     |      The NIfTI1 spec appears to require the slice dimension to be
     |      defined for slice_duration to have meaning.
     |  
     |  get_slice_times(self)
     |      Get slice times from slice timing information
     |      
     |      Returns
     |      -------
     |      slice_times : tuple
     |          Times of acquisition of slices, where 0 is the beginning of
     |          the acquisition, ordered by position in file.  nifti allows
     |          slices at the top and bottom of the volume to be excluded from
     |          the standard slice timing specification, and calls these
     |          "padding slices".  We give padding slices ``None`` as a time
     |          of acquisition
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape((1, 1, 7))
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
     |      >>> slice_times = hdr.get_slice_times()
     |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
     |      True
     |  
     |  get_slope_inter(self)
     |      Get data scaling (slope) and DC offset (intercept) from header data
     |      
     |      Returns
     |      -------
     |      slope : None or float
     |         scaling (slope).  None if there is no valid scaling from these
     |         fields
     |      inter : None or float
     |         offset (intercept). None if there is no valid scaling or if offset
     |         is not finite.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = 1
     |      >>> hdr['scl_inter'] = 1
     |      >>> hdr.get_slope_inter()
     |      (1.0, 1.0)
     |      >>> hdr['scl_inter'] = np.inf
     |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      HeaderDataError: Valid slope but invalid intercept inf
     |  
     |  get_xyzt_units(self)
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> hdr.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> hdr.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> hdr.set_data_dtype('int64')
     |      >>> hdr.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data  # noqa
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Nifti1 images can have up to seven dimensions. For FreeSurfer-variant
     |      Nifti surface files, the first dimension is assumed to correspond to
     |      vertices/nodes on a surface, and dimensions two and three are
     |      constrained to have depth of 1. Dimensions 4-7 are constrained only by
     |      type bounds.
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |      
     |      The Nifti1 `standard header`_ allows for the following "point set"
     |      definition of a surface, not currently implemented in nibabel.
     |      
     |      ::
     |      
     |        To signify that the vector value at each voxel is really a
     |        spatial coordinate (e.g., the vertices or nodes of a surface mesh):
     |          - dataset must have a 5th dimension
     |          - intent_code must be NIFTI_INTENT_POINTSET
     |          - dim[0] = 5
     |          - dim[1] = number of points
     |          - dim[2] = dim[3] = dim[4] = 1
     |          - dim[5] must be the dimensionality of space (e.g., 3 => 3D space).
     |          - intent_name may describe the object these points come from
     |            (e.g., "pial", "gray/white" , "EEG", "MEG").
     |      
     |      .. _issue 100: https://github.com/nipy/nibabel/issues/100
     |      .. _issue 309: https://github.com/nipy/nibabel/issues/309
     |      .. _save77:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82
     |      .. _save50:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56
     |      .. _load_nifti.m:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89
     |      .. _standard header: http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
     |  
     |  set_dim_info(self, freq=None, phase=None, slice=None)
     |      Sets nifti MRI slice etc dimension information
     |      
     |      Parameters
     |      ----------
     |      freq : {None, 0, 1, 2}
     |          axis of data array referring to frequency encoding
     |      phase : {None, 0, 1, 2}
     |          axis of data array referring to phase encoding
     |      slice : {None, 0, 1, 2}
     |          axis of data array referring to slice encoding
     |      
     |      ``None`` means the axis is not specified.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(1, 2, 0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info()
     |      >>> hdr.get_dim_info()
     |      (None, None, None)
     |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, None, 0)
     |      
     |      Notes
     |      -----
     |      This is stored in one byte in the header
     |  
     |  set_intent(self, code, params=(), name='', allow_unknown=False)
     |      Set the intent code, parameters and name
     |      
     |      If parameters are not specified, assumed to be all zero. Each
     |      intent code has a set number of parameters associated. If you
     |      specify any parameters, then it will need to be the correct number
     |      (e.g the "f test" intent requires 2).  However, parameters can
     |      also be set in the file data, so we also allow not setting any
     |      parameters (empty parameter tuple).
     |      
     |      Parameters
     |      ----------
     |      code : integer or string
     |          code specifying nifti intent
     |      params : list, tuple of scalars
     |          parameters relating to intent (see intent_codes)
     |          defaults to ().  Unspecified parameters are set to 0.0
     |      name : string
     |          intent name (description). Defaults to ''
     |      allow_unknown : {False, True}, optional
     |          Allow unknown integer intent codes. If False (the default),
     |          a KeyError is raised on attempts to set the intent
     |          to an unknown code.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent(0)  # no intent
     |      >>> hdr.set_intent('z score')
     |      >>> hdr.get_intent()
     |      ('z score', (), '')
     |      >>> hdr.get_intent('code')
     |      (5, (), '')
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.set_intent('f test', (2, 10), name='another score')
     |      >>> hdr.get_intent()
     |      ('f test', (2.0, 10.0), 'another score')
     |      >>> hdr.set_intent('f test')
     |      >>> hdr.get_intent()
     |      ('f test', (0.0, 0.0), '')
     |      >>> hdr.set_intent(9999, allow_unknown=True) # unknown code
     |      >>> hdr.get_intent()
     |      ('unknown code 9999', (), '')
     |  
     |  set_qform(self, affine, code=None, strip_shears=True)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      
     |      Notes
     |      -----
     |      The qform transform only encodes translations, rotations and
     |      zooms. If there are shear components to the `affine` transform, and
     |      `strip_shears` is True (the default), the written qform gives the
     |      closest approximation where the rotation matrix is orthogonal. This is
     |      to allow quaternion representation. The orthogonal representation
     |      enforces orthogonal axes.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['qform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_qform() == affine)
     |      False
     |      >>> hdr.set_qform(affine)
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> int(hdr['qform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_qform(affine, code='talairach')
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code=None)
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code='scanner')
     |      >>> int(hdr['qform_code'])
     |      1
     |      >>> hdr.set_qform(None)
     |      >>> int(hdr['qform_code'])
     |      0
     |  
     |  set_sform(self, affine, code=None)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['sform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_sform() == affine)
     |      False
     |      >>> hdr.set_sform(affine)
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |      >>> int(hdr['sform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_sform(affine, code='talairach')
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code=None)
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code='scanner')
     |      >>> int(hdr['sform_code'])
     |      1
     |      >>> hdr.set_sform(None)
     |      >>> int(hdr['sform_code'])
     |      0
     |  
     |  set_slice_duration(self, duration)
     |      Set slice duration
     |      
     |      Parameters
     |      ----------
     |      duration : scalar
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      See ``get_slice_duration``
     |  
     |  set_slice_times(self, slice_times)
     |      Set slice times into *hdr*
     |      
     |      Parameters
     |      ----------
     |      slice_times : tuple
     |          tuple of slice times, one value per slice
     |          tuple can include None to indicate no slice time for that slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape([1, 1, 7])
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
     |      >>> hdr.set_slice_times(times)
     |      >>> hdr.get_value_label('slice_code')
     |      'alternating decreasing'
     |      >>> int(hdr['slice_start'])
     |      1
     |      >>> int(hdr['slice_end'])
     |      5
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
     |      set `slope`, `inter` automatically on write.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
     |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
     |         HeaderDataError
     |      inter : None or float, optional
     |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
     |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
     |         HeaderDataError
     |  
     |  set_xyzt_units(self, xyz=None, t=None)
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Extend Analyze header copy by copying extensions from other Nifti
     |      types.
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  exts_klass = <class 'nibabel.nifti1.Nifti1Extensions'>
     |      Simple extension collection, implemented as a list-subclass.
     |  
     |  
     |  has_data_intercept = True
     |  
     |  has_data_slope = True
     |  
     |  is_single = True
     |  
     |  pair_magic = b'ni1'
     |  
     |  pair_vox_offset = 0
     |  
     |  quaternion_threshold = 3.5762786865234375e-07
     |  
     |  single_magic = b'n+1'
     |  
     |  single_vox_offset = 352
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Nifti1Image(Nifti1Pair, nibabel.filebasedimages.SerializableImage)
     |  Nifti1Image(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for single file NIfTI1 format image
     |  
     |  Method resolution order:
     |      Nifti1Image
     |      Nifti1Pair
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.SerializableImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  update_header(self)
     |      Harmonize header with image data and affine
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  files_types = (('image', '.nii'),)
     |  
     |  header_class = <class 'nibabel.nifti1.Nifti1Header'>
     |      Class for NIfTI1 header
     |      
     |      The NIfTI1 header has many more coded fields than the simpler Analyze
     |      variants.  NIfTI1 headers also have extensions.
     |      
     |      Nifti allows the header to be a separate file, as part of a nifti image /
     |      header pair, or to precede the data in a single file.  The object needs to
     |      know which type it is, in order to manage the voxel offset pointing to the
     |      data, extension reading, and writing the correct magic string.
     |      
     |      This class handles the header-preceding-data case.
     |  
     |  
     |  valid_exts = ('.nii',)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Pair:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |      
     |      Notes
     |      -----
     |      
     |      If both a `header` and an `affine` are specified, and the `affine` does
     |      not match the affine that is in the `header`, the `affine` will be used,
     |      but the ``sform_code`` and ``qform_code`` fields in the header will be
     |      re-initialised to their default values. This is performed on the basis
     |      that, if you are changing the affine, you are likely to be changing the
     |      space to which the affine is pointing.  The :meth:`set_sform` and
     |      :meth:`set_qform` methods can be used to update the codes after an image
     |      has been created - see those methods, and the :ref:`manual
     |      <default-sform-qform-codes>` for more details.
     |  
     |  as_reoriented(self, ornt)
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |  
     |  get_data_dtype(self, finalize=False)
     |      Get numpy dtype for data
     |      
     |      If ``set_data_dtype()`` has been called with an alias
     |      and ``finalize`` is ``False``, return the alias.
     |      If ``finalize`` is ``True``, determine the appropriate dtype
     |      from the image data object and set the final dtype in the
     |      header before returning it.
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_qform
     |      get_sform
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_sform
     |      get_qform
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code, dtype, type or alias
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      The following aliases are defined to allow for flexible specification:
     |      
     |        * ``'mask'`` - Alias for ``uint8``
     |        * ``'compat'`` - The nearest Analyze-compatible datatype
     |          (``uint8``, ``int16``, ``int32``, ``float32``)
     |        * ``'smallest'`` - The smallest Analyze-compatible integer
     |          (``uint8``, ``int16``, ``int32``)
     |      
     |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
     |      with a ``finalize=True`` flag. Until then, these aliases are not
     |      written to the header and will not persist to new images.
     |      
     |      Examples
     |      --------
     |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
     |      
     |      >>> img = Nifti1Image(ints, np.eye(4))
     |      >>> img.set_data_dtype(np.uint8)
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('mask')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('compat')
     |      >>> img.get_data_dtype()
     |      'compat'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('<i4')
     |      >>> img.get_data_dtype()
     |      dtype('<i4')
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype()
     |      'smallest'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('uint8')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      
     |      Note that floating point values will not be coerced to ``int``
     |      
     |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> img = Nifti1Image(floats, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype(finalize=True)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Cannot automatically cast array (of type float32) to an integer
     |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
     |      
     |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
     |      >>> img = Nifti1Image(arr, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> img.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> img.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> img.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> img.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> img.set_data_dtype('int64')
     |      >>> img.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform. Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_qform
     |      set_sform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_qform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> img.get_qform(coded=True)
     |      (None, 0)
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_qform(aff2, 'talairach')
     |      >>> qaff, code = img.get_qform(coded=True)
     |      >>> np.all(qaff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  set_sform(self, affine, code=None, **kwargs)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform.  Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_sform
     |      set_qform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_sform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> saff
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> int(code)
     |      2
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_sform(aff2, 'talairach')
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> np.all(saff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |      dtype : dtype-like, optional
     |         The on-disk data type to coerce the data array.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti1Pair:
     |  
     |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  makeable = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.SerializableImage:
     |  
     |  to_bytes(self, **kwargs) -> 'bytes'
     |      Return a ``bytes`` object with the contents of the file that would
     |      be written if the image were saved.
     |      
     |      Parameters
     |      ----------
     |      \*\*kwargs : keyword arguments
     |          Keyword arguments that may be passed to ``img.to_file_map()``
     |      
     |      Returns
     |      -------
     |      bytes
     |          Serialized image
     |  
     |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
     |      Save image to writable IO stream
     |      
     |      Parameters
     |      ----------
     |      io_obj : IOBase object
     |          Writable stream
     |      \*\*kwargs : keyword arguments
     |          Keyword arguments that may be passed to ``img.to_file_map()``
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.SerializableImage:
     |  
     |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
     |      Construct image from a byte string
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      bytestring : bytes
     |          Byte string containing the on-disk representation of an image
     |  
     |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
     |      Load image from readable IO stream
     |      
     |      Convert to BytesIO to enable seeking, if input stream is not seekable
     |      
     |      Parameters
     |      ----------
     |      io_obj : IOBase object
     |          Readable stream
     |  
     |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
     |      Retrieve and load an image from a URL
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      url : str or urllib.request.Request object
     |          URL of file to retrieve
     |      timeout : float, optional
     |          Time (in seconds) to wait for a response
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Nifti1Pair(nibabel.analyze.AnalyzeImage)
     |  Nifti1Pair(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for NIfTI1 format image, header pair
     |  
     |  Method resolution order:
     |      Nifti1Pair
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |      
     |      Notes
     |      -----
     |      
     |      If both a `header` and an `affine` are specified, and the `affine` does
     |      not match the affine that is in the `header`, the `affine` will be used,
     |      but the ``sform_code`` and ``qform_code`` fields in the header will be
     |      re-initialised to their default values. This is performed on the basis
     |      that, if you are changing the affine, you are likely to be changing the
     |      space to which the affine is pointing.  The :meth:`set_sform` and
     |      :meth:`set_qform` methods can be used to update the codes after an image
     |      has been created - see those methods, and the :ref:`manual
     |      <default-sform-qform-codes>` for more details.
     |  
     |  as_reoriented(self, ornt)
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |  
     |  get_data_dtype(self, finalize=False)
     |      Get numpy dtype for data
     |      
     |      If ``set_data_dtype()`` has been called with an alias
     |      and ``finalize`` is ``False``, return the alias.
     |      If ``finalize`` is ``True``, determine the appropriate dtype
     |      from the image data object and set the final dtype in the
     |      header before returning it.
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_qform
     |      get_sform
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_sform
     |      get_qform
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code, dtype, type or alias
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      The following aliases are defined to allow for flexible specification:
     |      
     |        * ``'mask'`` - Alias for ``uint8``
     |        * ``'compat'`` - The nearest Analyze-compatible datatype
     |          (``uint8``, ``int16``, ``int32``, ``float32``)
     |        * ``'smallest'`` - The smallest Analyze-compatible integer
     |          (``uint8``, ``int16``, ``int32``)
     |      
     |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
     |      with a ``finalize=True`` flag. Until then, these aliases are not
     |      written to the header and will not persist to new images.
     |      
     |      Examples
     |      --------
     |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
     |      
     |      >>> img = Nifti1Image(ints, np.eye(4))
     |      >>> img.set_data_dtype(np.uint8)
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('mask')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('compat')
     |      >>> img.get_data_dtype()
     |      'compat'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('<i4')
     |      >>> img.get_data_dtype()
     |      dtype('<i4')
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype()
     |      'smallest'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('uint8')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      
     |      Note that floating point values will not be coerced to ``int``
     |      
     |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> img = Nifti1Image(floats, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype(finalize=True)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Cannot automatically cast array (of type float32) to an integer
     |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
     |      
     |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
     |      >>> img = Nifti1Image(arr, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> img.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> img.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> img.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> img.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> img.set_data_dtype('int64')
     |      >>> img.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform. Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_qform
     |      set_sform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_qform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> img.get_qform(coded=True)
     |      (None, 0)
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_qform(aff2, 'talairach')
     |      >>> qaff, code = img.get_qform(coded=True)
     |      >>> np.all(qaff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  set_sform(self, affine, code=None, **kwargs)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform.  Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_sform
     |      set_qform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_sform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> saff
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> int(code)
     |      2
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_sform(aff2, 'talairach')
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> np.all(saff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |      dtype : dtype-like, optional
     |         The on-disk data type to coerce the data array.
     |  
     |  update_header(self)
     |      Harmonize header with image data and affine
     |      
     |      See AnalyzeImage.update_header for more examples
     |      
     |      Examples
     |      --------
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = Nifti1Image(data, affine)
     |      >>> hdr = img.header
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
     |  
     |  header_class = <class 'nibabel.nifti1.Nifti1PairHeader'>
     |      Class for NIfTI1 pair header
     |  
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'))
     |  
     |  makeable = True
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Nifti1PairHeader(Nifti1Header)
     |  Nifti1PairHeader(binaryblock=None, endianness=None, check=True, extensions=())
     |  
     |  Class for NIfTI1 pair header
     |  
     |  Method resolution order:
     |      Nifti1PairHeader
     |      Nifti1Header
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  is_single = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Header:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True, extensions=())
     |      Initialize header from binary data block and extensions
     |  
     |  copy(self)
     |      Return copy of header
     |      
     |      Take reference to extensions as well as copy of header contents
     |  
     |  get_best_affine(self)
     |      Select best of available transforms
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |  
     |  get_dim_info(self)
     |      Gets NIfTI MRI slice etc dimension information
     |      
     |      Returns
     |      -------
     |      freq : {None,0,1,2}
     |         Which data array axis is frequency encode direction
     |      phase : {None,0,1,2}
     |         Which data array axis is phase encode direction
     |      slice : {None,0,1,2}
     |         Which data array axis is slice encode direction
     |      
     |      where ``data array`` is the array returned by ``get_data``
     |      
     |      Because NIfTI1 files are natively Fortran indexed:
     |        0 is fastest changing in file
     |        1 is medium changing in file
     |        2 is slowest changing in file
     |      
     |      ``None`` means the axis appears not to be specified.
     |      
     |      Examples
     |      --------
     |      See set_dim_info function
     |  
     |  get_intent(self, code_repr='label')
     |      Get intent code, parameters and name
     |      
     |      Parameters
     |      ----------
     |      code_repr : string
     |         string giving output form of intent code representation.
     |         Default is 'label'; use 'code' for integer representation.
     |      
     |      Returns
     |      -------
     |      code : string or integer
     |          intent code, or string describing code
     |      parameters : tuple
     |          parameters for the intent
     |      name : string
     |          intent name
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.get_intent('code')
     |      (3, (10.0,), 'some score')
     |  
     |  get_n_slices(self)
     |      Return the number of slices
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |  
     |  get_qform_quaternion(self)
     |      Compute quaternion from b, c, d of quaternion
     |      
     |      Fills a value by assuming this is a unit quaternion
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |  
     |  get_slice_duration(self)
     |      Get slice duration
     |      
     |      Returns
     |      -------
     |      slice_duration : float
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_slice_duration(0.3)
     |      >>> print("%0.1f" % hdr.get_slice_duration())
     |      0.3
     |      
     |      Notes
     |      -----
     |      The NIfTI1 spec appears to require the slice dimension to be
     |      defined for slice_duration to have meaning.
     |  
     |  get_slice_times(self)
     |      Get slice times from slice timing information
     |      
     |      Returns
     |      -------
     |      slice_times : tuple
     |          Times of acquisition of slices, where 0 is the beginning of
     |          the acquisition, ordered by position in file.  nifti allows
     |          slices at the top and bottom of the volume to be excluded from
     |          the standard slice timing specification, and calls these
     |          "padding slices".  We give padding slices ``None`` as a time
     |          of acquisition
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape((1, 1, 7))
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
     |      >>> slice_times = hdr.get_slice_times()
     |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
     |      True
     |  
     |  get_slope_inter(self)
     |      Get data scaling (slope) and DC offset (intercept) from header data
     |      
     |      Returns
     |      -------
     |      slope : None or float
     |         scaling (slope).  None if there is no valid scaling from these
     |         fields
     |      inter : None or float
     |         offset (intercept). None if there is no valid scaling or if offset
     |         is not finite.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = 1
     |      >>> hdr['scl_inter'] = 1
     |      >>> hdr.get_slope_inter()
     |      (1.0, 1.0)
     |      >>> hdr['scl_inter'] = np.inf
     |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      HeaderDataError: Valid slope but invalid intercept inf
     |  
     |  get_xyzt_units(self)
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> hdr.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> hdr.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> hdr.set_data_dtype('int64')
     |      >>> hdr.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data  # noqa
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Nifti1 images can have up to seven dimensions. For FreeSurfer-variant
     |      Nifti surface files, the first dimension is assumed to correspond to
     |      vertices/nodes on a surface, and dimensions two and three are
     |      constrained to have depth of 1. Dimensions 4-7 are constrained only by
     |      type bounds.
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |      
     |      The Nifti1 `standard header`_ allows for the following "point set"
     |      definition of a surface, not currently implemented in nibabel.
     |      
     |      ::
     |      
     |        To signify that the vector value at each voxel is really a
     |        spatial coordinate (e.g., the vertices or nodes of a surface mesh):
     |          - dataset must have a 5th dimension
     |          - intent_code must be NIFTI_INTENT_POINTSET
     |          - dim[0] = 5
     |          - dim[1] = number of points
     |          - dim[2] = dim[3] = dim[4] = 1
     |          - dim[5] must be the dimensionality of space (e.g., 3 => 3D space).
     |          - intent_name may describe the object these points come from
     |            (e.g., "pial", "gray/white" , "EEG", "MEG").
     |      
     |      .. _issue 100: https://github.com/nipy/nibabel/issues/100
     |      .. _issue 309: https://github.com/nipy/nibabel/issues/309
     |      .. _save77:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82
     |      .. _save50:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56
     |      .. _load_nifti.m:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89
     |      .. _standard header: http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
     |  
     |  set_dim_info(self, freq=None, phase=None, slice=None)
     |      Sets nifti MRI slice etc dimension information
     |      
     |      Parameters
     |      ----------
     |      freq : {None, 0, 1, 2}
     |          axis of data array referring to frequency encoding
     |      phase : {None, 0, 1, 2}
     |          axis of data array referring to phase encoding
     |      slice : {None, 0, 1, 2}
     |          axis of data array referring to slice encoding
     |      
     |      ``None`` means the axis is not specified.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(1, 2, 0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info()
     |      >>> hdr.get_dim_info()
     |      (None, None, None)
     |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, None, 0)
     |      
     |      Notes
     |      -----
     |      This is stored in one byte in the header
     |  
     |  set_intent(self, code, params=(), name='', allow_unknown=False)
     |      Set the intent code, parameters and name
     |      
     |      If parameters are not specified, assumed to be all zero. Each
     |      intent code has a set number of parameters associated. If you
     |      specify any parameters, then it will need to be the correct number
     |      (e.g the "f test" intent requires 2).  However, parameters can
     |      also be set in the file data, so we also allow not setting any
     |      parameters (empty parameter tuple).
     |      
     |      Parameters
     |      ----------
     |      code : integer or string
     |          code specifying nifti intent
     |      params : list, tuple of scalars
     |          parameters relating to intent (see intent_codes)
     |          defaults to ().  Unspecified parameters are set to 0.0
     |      name : string
     |          intent name (description). Defaults to ''
     |      allow_unknown : {False, True}, optional
     |          Allow unknown integer intent codes. If False (the default),
     |          a KeyError is raised on attempts to set the intent
     |          to an unknown code.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent(0)  # no intent
     |      >>> hdr.set_intent('z score')
     |      >>> hdr.get_intent()
     |      ('z score', (), '')
     |      >>> hdr.get_intent('code')
     |      (5, (), '')
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.set_intent('f test', (2, 10), name='another score')
     |      >>> hdr.get_intent()
     |      ('f test', (2.0, 10.0), 'another score')
     |      >>> hdr.set_intent('f test')
     |      >>> hdr.get_intent()
     |      ('f test', (0.0, 0.0), '')
     |      >>> hdr.set_intent(9999, allow_unknown=True) # unknown code
     |      >>> hdr.get_intent()
     |      ('unknown code 9999', (), '')
     |  
     |  set_qform(self, affine, code=None, strip_shears=True)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      
     |      Notes
     |      -----
     |      The qform transform only encodes translations, rotations and
     |      zooms. If there are shear components to the `affine` transform, and
     |      `strip_shears` is True (the default), the written qform gives the
     |      closest approximation where the rotation matrix is orthogonal. This is
     |      to allow quaternion representation. The orthogonal representation
     |      enforces orthogonal axes.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['qform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_qform() == affine)
     |      False
     |      >>> hdr.set_qform(affine)
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> int(hdr['qform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_qform(affine, code='talairach')
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code=None)
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code='scanner')
     |      >>> int(hdr['qform_code'])
     |      1
     |      >>> hdr.set_qform(None)
     |      >>> int(hdr['qform_code'])
     |      0
     |  
     |  set_sform(self, affine, code=None)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['sform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_sform() == affine)
     |      False
     |      >>> hdr.set_sform(affine)
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |      >>> int(hdr['sform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_sform(affine, code='talairach')
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code=None)
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code='scanner')
     |      >>> int(hdr['sform_code'])
     |      1
     |      >>> hdr.set_sform(None)
     |      >>> int(hdr['sform_code'])
     |      0
     |  
     |  set_slice_duration(self, duration)
     |      Set slice duration
     |      
     |      Parameters
     |      ----------
     |      duration : scalar
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      See ``get_slice_duration``
     |  
     |  set_slice_times(self, slice_times)
     |      Set slice times into *hdr*
     |      
     |      Parameters
     |      ----------
     |      slice_times : tuple
     |          tuple of slice times, one value per slice
     |          tuple can include None to indicate no slice time for that slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape([1, 1, 7])
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
     |      >>> hdr.set_slice_times(times)
     |      >>> hdr.get_value_label('slice_code')
     |      'alternating decreasing'
     |      >>> int(hdr['slice_start'])
     |      1
     |      >>> int(hdr['slice_end'])
     |      5
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
     |      set `slope`, `inter` automatically on write.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
     |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
     |         HeaderDataError
     |      inter : None or float, optional
     |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
     |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
     |         HeaderDataError
     |  
     |  set_xyzt_units(self, xyz=None, t=None)
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Nifti1Header:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Extend Analyze header copy by copying extensions from other Nifti
     |      types.
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti1Header:
     |  
     |  exts_klass = <class 'nibabel.nifti1.Nifti1Extensions'>
     |      Simple extension collection, implemented as a list-subclass.
     |  
     |  
     |  has_data_intercept = True
     |  
     |  has_data_slope = True
     |  
     |  pair_magic = b'ni1'
     |  
     |  pair_vox_offset = 0
     |  
     |  quaternion_threshold = 3.5762786865234375e-07
     |  
     |  single_magic = b'n+1'
     |  
     |  single_vox_offset = 352
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta

FUNCTIONS
    load(filename)
        Load NIfTI1 single or pair from `filename`
        
        Parameters
        ----------
        filename : str
            filename of image to be loaded
        
        Returns
        -------
        img : Nifti1Image or Nifti1Pair
            NIfTI1 single or pair image instance
        
        Raises
        ------
        ImageFileError
            if `filename` doesn't look like NIfTI1;
        OSError
            if `filename` does not exist.
    
    save(img, filename)
        Save NIfTI1 single or pair to `filename`
        
        Parameters
        ----------
        filename : str
            filename to which to save image

DATA
    __annotations__ = {}
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    data_type_codes = <nibabel.volumeutils.Recoder object>
    endian_codes = <nibabel.volumeutils.Recoder object>
    extension_codes = <nibabel.volumeutils.Recoder object>
    have_dicom = True
    header_dtd = [('sizeof_hdr', 'i4'), ('data_type', 'S10'), ('db_name', ...
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (4,...
    intent_codes = <nibabel.volumeutils.Recoder object>
    slice_order_codes = <nibabel.volumeutils.Recoder object>
    unit_codes = <nibabel.volumeutils.Recoder object>
    xform_codes = <nibabel.volumeutils.Recoder object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/nifti1.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& nifti2 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.nifti2 in nibabel:

NAME
    nibabel.nifti2 - Read / write access to NIfTI2 image format

DESCRIPTION
    Format described here:
    
        https://www.nitrc.org/forum/message.php?msg_id=3738

CLASSES
    nibabel.nifti1.Nifti1Header(nibabel.spm99analyze.SpmAnalyzeHeader)
        Nifti2Header
            Nifti2PairHeader
    nibabel.nifti1.Nifti1Image(nibabel.nifti1.Nifti1Pair, nibabel.filebasedimages.SerializableImage)
        Nifti2Image
    nibabel.nifti1.Nifti1Pair(nibabel.analyze.AnalyzeImage)
        Nifti2Pair
    
    class Nifti2Header(nibabel.nifti1.Nifti1Header)
     |  Nifti2Header(binaryblock=None, endianness=None, check=True, extensions=())
     |  
     |  Class for NIfTI2 header
     |  
     |  NIfTI2 is a slightly simplified variant of NIfTI1 which replaces 32-bit
     |  floats with 64-bit floats, and increases some integer widths to 32 or 64
     |  bits.
     |  
     |  Method resolution order:
     |      Nifti2Header
     |      nibabel.nifti1.Nifti1Header
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti2Header()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |      
     |      Notes
     |      -----
     |      Does not use Nifti1 freesurfer hack for large vectors described in
     |      :meth:`Nifti1Header.set_data_shape`
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |      
     |      Notes
     |      -----
     |      Does not apply nifti1 Freesurfer hack for long vectors (see
     |      :meth:`Nifti1Header.set_data_shape`)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  pair_magic = b'ni2'
     |  
     |  pair_vox_offset = 0
     |  
     |  quaternion_threshold = -6.661338147750939e-16
     |  
     |  single_magic = b'n+2'
     |  
     |  single_vox_offset = 544
     |  
     |  sizeof_hdr = 540
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('magic', 'S4'), (...16...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.nifti1.Nifti1Header:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True, extensions=())
     |      Initialize header from binary data block and extensions
     |  
     |  copy(self)
     |      Return copy of header
     |      
     |      Take reference to extensions as well as copy of header contents
     |  
     |  get_best_affine(self)
     |      Select best of available transforms
     |  
     |  get_dim_info(self)
     |      Gets NIfTI MRI slice etc dimension information
     |      
     |      Returns
     |      -------
     |      freq : {None,0,1,2}
     |         Which data array axis is frequency encode direction
     |      phase : {None,0,1,2}
     |         Which data array axis is phase encode direction
     |      slice : {None,0,1,2}
     |         Which data array axis is slice encode direction
     |      
     |      where ``data array`` is the array returned by ``get_data``
     |      
     |      Because NIfTI1 files are natively Fortran indexed:
     |        0 is fastest changing in file
     |        1 is medium changing in file
     |        2 is slowest changing in file
     |      
     |      ``None`` means the axis appears not to be specified.
     |      
     |      Examples
     |      --------
     |      See set_dim_info function
     |  
     |  get_intent(self, code_repr='label')
     |      Get intent code, parameters and name
     |      
     |      Parameters
     |      ----------
     |      code_repr : string
     |         string giving output form of intent code representation.
     |         Default is 'label'; use 'code' for integer representation.
     |      
     |      Returns
     |      -------
     |      code : string or integer
     |          intent code, or string describing code
     |      parameters : tuple
     |          parameters for the intent
     |      name : string
     |          intent name
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.get_intent('code')
     |      (3, (10.0,), 'some score')
     |  
     |  get_n_slices(self)
     |      Return the number of slices
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |  
     |  get_qform_quaternion(self)
     |      Compute quaternion from b, c, d of quaternion
     |      
     |      Fills a value by assuming this is a unit quaternion
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |  
     |  get_slice_duration(self)
     |      Get slice duration
     |      
     |      Returns
     |      -------
     |      slice_duration : float
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_slice_duration(0.3)
     |      >>> print("%0.1f" % hdr.get_slice_duration())
     |      0.3
     |      
     |      Notes
     |      -----
     |      The NIfTI1 spec appears to require the slice dimension to be
     |      defined for slice_duration to have meaning.
     |  
     |  get_slice_times(self)
     |      Get slice times from slice timing information
     |      
     |      Returns
     |      -------
     |      slice_times : tuple
     |          Times of acquisition of slices, where 0 is the beginning of
     |          the acquisition, ordered by position in file.  nifti allows
     |          slices at the top and bottom of the volume to be excluded from
     |          the standard slice timing specification, and calls these
     |          "padding slices".  We give padding slices ``None`` as a time
     |          of acquisition
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape((1, 1, 7))
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
     |      >>> slice_times = hdr.get_slice_times()
     |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
     |      True
     |  
     |  get_slope_inter(self)
     |      Get data scaling (slope) and DC offset (intercept) from header data
     |      
     |      Returns
     |      -------
     |      slope : None or float
     |         scaling (slope).  None if there is no valid scaling from these
     |         fields
     |      inter : None or float
     |         offset (intercept). None if there is no valid scaling or if offset
     |         is not finite.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = 1
     |      >>> hdr['scl_inter'] = 1
     |      >>> hdr.get_slope_inter()
     |      (1.0, 1.0)
     |      >>> hdr['scl_inter'] = np.inf
     |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      HeaderDataError: Valid slope but invalid intercept inf
     |  
     |  get_xyzt_units(self)
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> hdr.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> hdr.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> hdr.set_data_dtype('int64')
     |      >>> hdr.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_dim_info(self, freq=None, phase=None, slice=None)
     |      Sets nifti MRI slice etc dimension information
     |      
     |      Parameters
     |      ----------
     |      freq : {None, 0, 1, 2}
     |          axis of data array referring to frequency encoding
     |      phase : {None, 0, 1, 2}
     |          axis of data array referring to phase encoding
     |      slice : {None, 0, 1, 2}
     |          axis of data array referring to slice encoding
     |      
     |      ``None`` means the axis is not specified.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(1, 2, 0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info()
     |      >>> hdr.get_dim_info()
     |      (None, None, None)
     |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, None, 0)
     |      
     |      Notes
     |      -----
     |      This is stored in one byte in the header
     |  
     |  set_intent(self, code, params=(), name='', allow_unknown=False)
     |      Set the intent code, parameters and name
     |      
     |      If parameters are not specified, assumed to be all zero. Each
     |      intent code has a set number of parameters associated. If you
     |      specify any parameters, then it will need to be the correct number
     |      (e.g the "f test" intent requires 2).  However, parameters can
     |      also be set in the file data, so we also allow not setting any
     |      parameters (empty parameter tuple).
     |      
     |      Parameters
     |      ----------
     |      code : integer or string
     |          code specifying nifti intent
     |      params : list, tuple of scalars
     |          parameters relating to intent (see intent_codes)
     |          defaults to ().  Unspecified parameters are set to 0.0
     |      name : string
     |          intent name (description). Defaults to ''
     |      allow_unknown : {False, True}, optional
     |          Allow unknown integer intent codes. If False (the default),
     |          a KeyError is raised on attempts to set the intent
     |          to an unknown code.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent(0)  # no intent
     |      >>> hdr.set_intent('z score')
     |      >>> hdr.get_intent()
     |      ('z score', (), '')
     |      >>> hdr.get_intent('code')
     |      (5, (), '')
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.set_intent('f test', (2, 10), name='another score')
     |      >>> hdr.get_intent()
     |      ('f test', (2.0, 10.0), 'another score')
     |      >>> hdr.set_intent('f test')
     |      >>> hdr.get_intent()
     |      ('f test', (0.0, 0.0), '')
     |      >>> hdr.set_intent(9999, allow_unknown=True) # unknown code
     |      >>> hdr.get_intent()
     |      ('unknown code 9999', (), '')
     |  
     |  set_qform(self, affine, code=None, strip_shears=True)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      
     |      Notes
     |      -----
     |      The qform transform only encodes translations, rotations and
     |      zooms. If there are shear components to the `affine` transform, and
     |      `strip_shears` is True (the default), the written qform gives the
     |      closest approximation where the rotation matrix is orthogonal. This is
     |      to allow quaternion representation. The orthogonal representation
     |      enforces orthogonal axes.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['qform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_qform() == affine)
     |      False
     |      >>> hdr.set_qform(affine)
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> int(hdr['qform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_qform(affine, code='talairach')
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code=None)
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code='scanner')
     |      >>> int(hdr['qform_code'])
     |      1
     |      >>> hdr.set_qform(None)
     |      >>> int(hdr['qform_code'])
     |      0
     |  
     |  set_sform(self, affine, code=None)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['sform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_sform() == affine)
     |      False
     |      >>> hdr.set_sform(affine)
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |      >>> int(hdr['sform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_sform(affine, code='talairach')
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code=None)
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code='scanner')
     |      >>> int(hdr['sform_code'])
     |      1
     |      >>> hdr.set_sform(None)
     |      >>> int(hdr['sform_code'])
     |      0
     |  
     |  set_slice_duration(self, duration)
     |      Set slice duration
     |      
     |      Parameters
     |      ----------
     |      duration : scalar
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      See ``get_slice_duration``
     |  
     |  set_slice_times(self, slice_times)
     |      Set slice times into *hdr*
     |      
     |      Parameters
     |      ----------
     |      slice_times : tuple
     |          tuple of slice times, one value per slice
     |          tuple can include None to indicate no slice time for that slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape([1, 1, 7])
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
     |      >>> hdr.set_slice_times(times)
     |      >>> hdr.get_value_label('slice_code')
     |      'alternating decreasing'
     |      >>> int(hdr['slice_start'])
     |      1
     |      >>> int(hdr['slice_end'])
     |      5
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
     |      set `slope`, `inter` automatically on write.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
     |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
     |         HeaderDataError
     |      inter : None or float, optional
     |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
     |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
     |         HeaderDataError
     |  
     |  set_xyzt_units(self, xyz=None, t=None)
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.nifti1.Nifti1Header:
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Extend Analyze header copy by copying extensions from other Nifti
     |      types.
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.nifti1.Nifti1Header:
     |  
     |  exts_klass = <class 'nibabel.nifti1.Nifti1Extensions'>
     |      Simple extension collection, implemented as a list-subclass.
     |  
     |  
     |  has_data_intercept = True
     |  
     |  has_data_slope = True
     |  
     |  is_single = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Nifti2Image(nibabel.nifti1.Nifti1Image)
     |  Nifti2Image(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for single file NIfTI2 format image
     |  
     |  Method resolution order:
     |      Nifti2Image
     |      nibabel.nifti1.Nifti1Image
     |      nibabel.nifti1.Nifti1Pair
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.SerializableImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  header_class = <class 'nibabel.nifti2.Nifti2Header'>
     |      Class for NIfTI2 header
     |      
     |      NIfTI2 is a slightly simplified variant of NIfTI1 which replaces 32-bit
     |      floats with 64-bit floats, and increases some integer widths to 32 or 64
     |      bits.
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.nifti1.Nifti1Image:
     |  
     |  update_header(self)
     |      Harmonize header with image data and affine
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.nifti1.Nifti1Image:
     |  
     |  files_types = (('image', '.nii'),)
     |  
     |  valid_exts = ('.nii',)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.nifti1.Nifti1Pair:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |      
     |      Notes
     |      -----
     |      
     |      If both a `header` and an `affine` are specified, and the `affine` does
     |      not match the affine that is in the `header`, the `affine` will be used,
     |      but the ``sform_code`` and ``qform_code`` fields in the header will be
     |      re-initialised to their default values. This is performed on the basis
     |      that, if you are changing the affine, you are likely to be changing the
     |      space to which the affine is pointing.  The :meth:`set_sform` and
     |      :meth:`set_qform` methods can be used to update the codes after an image
     |      has been created - see those methods, and the :ref:`manual
     |      <default-sform-qform-codes>` for more details.
     |  
     |  as_reoriented(self, ornt)
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |  
     |  get_data_dtype(self, finalize=False)
     |      Get numpy dtype for data
     |      
     |      If ``set_data_dtype()`` has been called with an alias
     |      and ``finalize`` is ``False``, return the alias.
     |      If ``finalize`` is ``True``, determine the appropriate dtype
     |      from the image data object and set the final dtype in the
     |      header before returning it.
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_qform
     |      get_sform
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_sform
     |      get_qform
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code, dtype, type or alias
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      The following aliases are defined to allow for flexible specification:
     |      
     |        * ``'mask'`` - Alias for ``uint8``
     |        * ``'compat'`` - The nearest Analyze-compatible datatype
     |          (``uint8``, ``int16``, ``int32``, ``float32``)
     |        * ``'smallest'`` - The smallest Analyze-compatible integer
     |          (``uint8``, ``int16``, ``int32``)
     |      
     |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
     |      with a ``finalize=True`` flag. Until then, these aliases are not
     |      written to the header and will not persist to new images.
     |      
     |      Examples
     |      --------
     |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
     |      
     |      >>> img = Nifti1Image(ints, np.eye(4))
     |      >>> img.set_data_dtype(np.uint8)
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('mask')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('compat')
     |      >>> img.get_data_dtype()
     |      'compat'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('<i4')
     |      >>> img.get_data_dtype()
     |      dtype('<i4')
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype()
     |      'smallest'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('uint8')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      
     |      Note that floating point values will not be coerced to ``int``
     |      
     |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> img = Nifti1Image(floats, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype(finalize=True)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Cannot automatically cast array (of type float32) to an integer
     |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
     |      
     |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
     |      >>> img = Nifti1Image(arr, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> img.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> img.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> img.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> img.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> img.set_data_dtype('int64')
     |      >>> img.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform. Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_qform
     |      set_sform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_qform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> img.get_qform(coded=True)
     |      (None, 0)
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_qform(aff2, 'talairach')
     |      >>> qaff, code = img.get_qform(coded=True)
     |      >>> np.all(qaff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  set_sform(self, affine, code=None, **kwargs)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform.  Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_sform
     |      set_qform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_sform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> saff
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> int(code)
     |      2
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_sform(aff2, 'talairach')
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> np.all(saff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |      dtype : dtype-like, optional
     |         The on-disk data type to coerce the data array.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.nifti1.Nifti1Pair:
     |  
     |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  makeable = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.SerializableImage:
     |  
     |  to_bytes(self, **kwargs) -> 'bytes'
     |      Return a ``bytes`` object with the contents of the file that would
     |      be written if the image were saved.
     |      
     |      Parameters
     |      ----------
     |      \*\*kwargs : keyword arguments
     |          Keyword arguments that may be passed to ``img.to_file_map()``
     |      
     |      Returns
     |      -------
     |      bytes
     |          Serialized image
     |  
     |  to_stream(self, io_obj: 'io.IOBase', **kwargs) -> 'None'
     |      Save image to writable IO stream
     |      
     |      Parameters
     |      ----------
     |      io_obj : IOBase object
     |          Writable stream
     |      \*\*kwargs : keyword arguments
     |          Keyword arguments that may be passed to ``img.to_file_map()``
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.SerializableImage:
     |  
     |  from_bytes(bytestring: 'bytes') -> 'StreamImgT' from builtins.type
     |      Construct image from a byte string
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      bytestring : bytes
     |          Byte string containing the on-disk representation of an image
     |  
     |  from_stream(io_obj: 'io.IOBase') -> 'StreamImgT' from builtins.type
     |      Load image from readable IO stream
     |      
     |      Convert to BytesIO to enable seeking, if input stream is not seekable
     |      
     |      Parameters
     |      ----------
     |      io_obj : IOBase object
     |          Readable stream
     |  
     |  from_url(url: 'str | request.Request', timeout: 'float' = 5) -> 'StreamImgT' from builtins.type
     |      Retrieve and load an image from a URL
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      url : str or urllib.request.Request object
     |          URL of file to retrieve
     |      timeout : float, optional
     |          Time (in seconds) to wait for a response
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Nifti2Pair(nibabel.nifti1.Nifti1Pair)
     |  Nifti2Pair(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for NIfTI2 format image, header pair
     |  
     |  Method resolution order:
     |      Nifti2Pair
     |      nibabel.nifti1.Nifti1Pair
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  header_class = <class 'nibabel.nifti2.Nifti2PairHeader'>
     |      Class for NIfTI2 pair header
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.nifti1.Nifti1Pair:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |      
     |      Notes
     |      -----
     |      
     |      If both a `header` and an `affine` are specified, and the `affine` does
     |      not match the affine that is in the `header`, the `affine` will be used,
     |      but the ``sform_code`` and ``qform_code`` fields in the header will be
     |      re-initialised to their default values. This is performed on the basis
     |      that, if you are changing the affine, you are likely to be changing the
     |      space to which the affine is pointing.  The :meth:`set_sform` and
     |      :meth:`set_qform` methods can be used to update the codes after an image
     |      has been created - see those methods, and the :ref:`manual
     |      <default-sform-qform-codes>` for more details.
     |  
     |  as_reoriented(self, ornt)
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |  
     |  get_data_dtype(self, finalize=False)
     |      Get numpy dtype for data
     |      
     |      If ``set_data_dtype()`` has been called with an alias
     |      and ``finalize`` is ``False``, return the alias.
     |      If ``finalize`` is ``True``, determine the appropriate dtype
     |      from the image data object and set the final dtype in the
     |      header before returning it.
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_qform
     |      get_sform
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_sform
     |      get_qform
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code, dtype, type or alias
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      The following aliases are defined to allow for flexible specification:
     |      
     |        * ``'mask'`` - Alias for ``uint8``
     |        * ``'compat'`` - The nearest Analyze-compatible datatype
     |          (``uint8``, ``int16``, ``int32``, ``float32``)
     |        * ``'smallest'`` - The smallest Analyze-compatible integer
     |          (``uint8``, ``int16``, ``int32``)
     |      
     |      Dynamic aliases are resolved when ``get_data_dtype()`` is called
     |      with a ``finalize=True`` flag. Until then, these aliases are not
     |      written to the header and will not persist to new images.
     |      
     |      Examples
     |      --------
     |      >>> ints = np.arange(24, dtype='i4').reshape((2,3,4))
     |      
     |      >>> img = Nifti1Image(ints, np.eye(4))
     |      >>> img.set_data_dtype(np.uint8)
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('mask')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      >>> img.set_data_dtype('compat')
     |      >>> img.get_data_dtype()
     |      'compat'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('<i4')
     |      >>> img.get_data_dtype()
     |      dtype('<i4')
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype()
     |      'smallest'
     |      >>> img.get_data_dtype(finalize=True)
     |      dtype('uint8')
     |      >>> img.get_data_dtype()
     |      dtype('uint8')
     |      
     |      Note that floating point values will not be coerced to ``int``
     |      
     |      >>> floats = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> img = Nifti1Image(floats, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.get_data_dtype(finalize=True)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Cannot automatically cast array (of type float32) to an integer
     |      type with fewer than 64 bits. Please set_data_dtype() to an explicit data type.
     |      
     |      >>> arr = np.arange(1000, 1024, dtype='i4').reshape((2,3,4))
     |      >>> img = Nifti1Image(arr, np.eye(4))
     |      >>> img.set_data_dtype('smallest')
     |      >>> img.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> img.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> img.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> img.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> img.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> img.set_data_dtype('int64')
     |      >>> img.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_qform(self, affine, code=None, strip_shears=True, **kwargs)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform. Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_qform
     |      set_sform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_qform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> img.get_qform(coded=True)
     |      (None, 0)
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_qform(aff2, 'talairach')
     |      >>> qaff, code = img.get_qform(coded=True)
     |      >>> np.all(qaff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  set_sform(self, affine, code=None, **kwargs)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform.  Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_sform
     |      set_qform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_sform()
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> saff
     |      array([[2., 0., 0., 0.],
     |             [0., 3., 0., 0.],
     |             [0., 0., 4., 0.],
     |             [0., 0., 0., 1.]])
     |      >>> int(code)
     |      2
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_sform(aff2, 'talairach')
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> np.all(saff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |      dtype : dtype-like, optional
     |         The on-disk data type to coerce the data array.
     |  
     |  update_header(self)
     |      Harmonize header with image data and affine
     |      
     |      See AnalyzeImage.update_header for more examples
     |      
     |      Examples
     |      --------
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = Nifti1Image(data, affine)
     |      >>> hdr = img.header
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.nifti1.Nifti1Pair:
     |  
     |  __annotations__ = {'header': 'Nifti1Header', 'header_class': 'type[Nif...
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'))
     |  
     |  makeable = True
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Nifti2PairHeader(Nifti2Header)
     |  Nifti2PairHeader(binaryblock=None, endianness=None, check=True, extensions=())
     |  
     |  Class for NIfTI2 pair header
     |  
     |  Method resolution order:
     |      Nifti2PairHeader
     |      Nifti2Header
     |      nibabel.nifti1.Nifti1Header
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  is_single = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti2Header:
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti2Header()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |      
     |      Notes
     |      -----
     |      Does not use Nifti1 freesurfer hack for large vectors described in
     |      :meth:`Nifti1Header.set_data_shape`
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |      
     |      Notes
     |      -----
     |      Does not apply nifti1 Freesurfer hack for long vectors (see
     |      :meth:`Nifti1Header.set_data_shape`)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Nifti2Header:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti2Header:
     |  
     |  pair_magic = b'ni2'
     |  
     |  pair_vox_offset = 0
     |  
     |  quaternion_threshold = -6.661338147750939e-16
     |  
     |  single_magic = b'n+2'
     |  
     |  single_vox_offset = 544
     |  
     |  sizeof_hdr = 540
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('magic', 'S4'), (...16...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.nifti1.Nifti1Header:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True, extensions=())
     |      Initialize header from binary data block and extensions
     |  
     |  copy(self)
     |      Return copy of header
     |      
     |      Take reference to extensions as well as copy of header contents
     |  
     |  get_best_affine(self)
     |      Select best of available transforms
     |  
     |  get_dim_info(self)
     |      Gets NIfTI MRI slice etc dimension information
     |      
     |      Returns
     |      -------
     |      freq : {None,0,1,2}
     |         Which data array axis is frequency encode direction
     |      phase : {None,0,1,2}
     |         Which data array axis is phase encode direction
     |      slice : {None,0,1,2}
     |         Which data array axis is slice encode direction
     |      
     |      where ``data array`` is the array returned by ``get_data``
     |      
     |      Because NIfTI1 files are natively Fortran indexed:
     |        0 is fastest changing in file
     |        1 is medium changing in file
     |        2 is slowest changing in file
     |      
     |      ``None`` means the axis appears not to be specified.
     |      
     |      Examples
     |      --------
     |      See set_dim_info function
     |  
     |  get_intent(self, code_repr='label')
     |      Get intent code, parameters and name
     |      
     |      Parameters
     |      ----------
     |      code_repr : string
     |         string giving output form of intent code representation.
     |         Default is 'label'; use 'code' for integer representation.
     |      
     |      Returns
     |      -------
     |      code : string or integer
     |          intent code, or string describing code
     |      parameters : tuple
     |          parameters for the intent
     |      name : string
     |          intent name
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.get_intent('code')
     |      (3, (10.0,), 'some score')
     |  
     |  get_n_slices(self)
     |      Return the number of slices
     |  
     |  get_qform(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |  
     |  get_qform_quaternion(self)
     |      Compute quaternion from b, c, d of quaternion
     |      
     |      Fills a value by assuming this is a unit quaternion
     |  
     |  get_sform(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |  
     |  get_slice_duration(self)
     |      Get slice duration
     |      
     |      Returns
     |      -------
     |      slice_duration : float
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_slice_duration(0.3)
     |      >>> print("%0.1f" % hdr.get_slice_duration())
     |      0.3
     |      
     |      Notes
     |      -----
     |      The NIfTI1 spec appears to require the slice dimension to be
     |      defined for slice_duration to have meaning.
     |  
     |  get_slice_times(self)
     |      Get slice times from slice timing information
     |      
     |      Returns
     |      -------
     |      slice_times : tuple
     |          Times of acquisition of slices, where 0 is the beginning of
     |          the acquisition, ordered by position in file.  nifti allows
     |          slices at the top and bottom of the volume to be excluded from
     |          the standard slice timing specification, and calls these
     |          "padding slices".  We give padding slices ``None`` as a time
     |          of acquisition
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape((1, 1, 7))
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
     |      >>> slice_times = hdr.get_slice_times()
     |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
     |      True
     |  
     |  get_slope_inter(self)
     |      Get data scaling (slope) and DC offset (intercept) from header data
     |      
     |      Returns
     |      -------
     |      slope : None or float
     |         scaling (slope).  None if there is no valid scaling from these
     |         fields
     |      inter : None or float
     |         offset (intercept). None if there is no valid scaling or if offset
     |         is not finite.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = 1
     |      >>> hdr['scl_inter'] = 1
     |      >>> hdr.get_slope_inter()
     |      (1.0, 1.0)
     |      >>> hdr['scl_inter'] = np.inf
     |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      HeaderDataError: Valid slope but invalid intercept inf
     |  
     |  get_xyzt_units(self)
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Using :py:class:`int` or ``"int"`` is disallowed, as these types
     |      will be interpreted as ``np.int64``, which is almost never desired.
     |      ``np.int64`` is permitted for those intent on making poor choices.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none')
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void)
     |      Traceback (most recent call last):
     |         ...
     |      nibabel.spatialimages.HeaderDataError: data dtype "<class 'numpy.void'>" known
     |      but not supported
     |      >>> hdr.set_data_dtype('int')
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type 'int'. Specify a sized integer, e.g., 'uint8' or numpy.int16.
     |      >>> hdr.set_data_dtype(int)
     |      Traceback (most recent call last):
     |         ...
     |      ValueError: Invalid data type <class 'int'>. Specify a sized integer, e.g., 'uint8' or
     |      numpy.int16.
     |      >>> hdr.set_data_dtype('int64')
     |      >>> hdr.get_data_dtype() == np.dtype('int64')
     |      True
     |  
     |  set_dim_info(self, freq=None, phase=None, slice=None)
     |      Sets nifti MRI slice etc dimension information
     |      
     |      Parameters
     |      ----------
     |      freq : {None, 0, 1, 2}
     |          axis of data array referring to frequency encoding
     |      phase : {None, 0, 1, 2}
     |          axis of data array referring to phase encoding
     |      slice : {None, 0, 1, 2}
     |          axis of data array referring to slice encoding
     |      
     |      ``None`` means the axis is not specified.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(1, 2, 0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info()
     |      >>> hdr.get_dim_info()
     |      (None, None, None)
     |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, None, 0)
     |      
     |      Notes
     |      -----
     |      This is stored in one byte in the header
     |  
     |  set_intent(self, code, params=(), name='', allow_unknown=False)
     |      Set the intent code, parameters and name
     |      
     |      If parameters are not specified, assumed to be all zero. Each
     |      intent code has a set number of parameters associated. If you
     |      specify any parameters, then it will need to be the correct number
     |      (e.g the "f test" intent requires 2).  However, parameters can
     |      also be set in the file data, so we also allow not setting any
     |      parameters (empty parameter tuple).
     |      
     |      Parameters
     |      ----------
     |      code : integer or string
     |          code specifying nifti intent
     |      params : list, tuple of scalars
     |          parameters relating to intent (see intent_codes)
     |          defaults to ().  Unspecified parameters are set to 0.0
     |      name : string
     |          intent name (description). Defaults to ''
     |      allow_unknown : {False, True}, optional
     |          Allow unknown integer intent codes. If False (the default),
     |          a KeyError is raised on attempts to set the intent
     |          to an unknown code.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent(0)  # no intent
     |      >>> hdr.set_intent('z score')
     |      >>> hdr.get_intent()
     |      ('z score', (), '')
     |      >>> hdr.get_intent('code')
     |      (5, (), '')
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.set_intent('f test', (2, 10), name='another score')
     |      >>> hdr.get_intent()
     |      ('f test', (2.0, 10.0), 'another score')
     |      >>> hdr.set_intent('f test')
     |      >>> hdr.get_intent()
     |      ('f test', (0.0, 0.0), '')
     |      >>> hdr.set_intent(9999, allow_unknown=True) # unknown code
     |      >>> hdr.get_intent()
     |      ('unknown code 9999', (), '')
     |  
     |  set_qform(self, affine, code=None, strip_shears=True)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      
     |      Notes
     |      -----
     |      The qform transform only encodes translations, rotations and
     |      zooms. If there are shear components to the `affine` transform, and
     |      `strip_shears` is True (the default), the written qform gives the
     |      closest approximation where the rotation matrix is orthogonal. This is
     |      to allow quaternion representation. The orthogonal representation
     |      enforces orthogonal axes.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['qform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_qform() == affine)
     |      False
     |      >>> hdr.set_qform(affine)
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> int(hdr['qform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_qform(affine, code='talairach')
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code=None)
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code='scanner')
     |      >>> int(hdr['qform_code'])
     |      1
     |      >>> hdr.set_qform(None)
     |      >>> int(hdr['qform_code'])
     |      0
     |  
     |  set_sform(self, affine, code=None)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['sform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_sform() == affine)
     |      False
     |      >>> hdr.set_sform(affine)
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |      >>> int(hdr['sform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_sform(affine, code='talairach')
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code=None)
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code='scanner')
     |      >>> int(hdr['sform_code'])
     |      1
     |      >>> hdr.set_sform(None)
     |      >>> int(hdr['sform_code'])
     |      0
     |  
     |  set_slice_duration(self, duration)
     |      Set slice duration
     |      
     |      Parameters
     |      ----------
     |      duration : scalar
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      See ``get_slice_duration``
     |  
     |  set_slice_times(self, slice_times)
     |      Set slice times into *hdr*
     |      
     |      Parameters
     |      ----------
     |      slice_times : tuple
     |          tuple of slice times, one value per slice
     |          tuple can include None to indicate no slice time for that slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape([1, 1, 7])
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
     |      >>> hdr.set_slice_times(times)
     |      >>> hdr.get_value_label('slice_code')
     |      'alternating decreasing'
     |      >>> int(hdr['slice_start'])
     |      1
     |      >>> int(hdr['slice_end'])
     |      5
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
     |      set `slope`, `inter` automatically on write.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
     |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
     |         HeaderDataError
     |      inter : None or float, optional
     |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
     |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
     |         HeaderDataError
     |  
     |  set_xyzt_units(self, xyz=None, t=None)
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.nifti1.Nifti1Header:
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Extend Analyze header copy by copying extensions from other Nifti
     |      types.
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.nifti1.Nifti1Header:
     |  
     |  exts_klass = <class 'nibabel.nifti1.Nifti1Extensions'>
     |      Simple extension collection, implemented as a list-subclass.
     |  
     |  
     |  has_data_intercept = True
     |  
     |  has_data_slope = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta

FUNCTIONS
    load(filename)
        Load NIfTI2 single or pair image from `filename`
        
        Parameters
        ----------
        filename : str
            filename of image to be loaded
        
        Returns
        -------
        img : Nifti2Image or Nifti2Pair
            nifti2 single or pair image instance
        
        Raises
        ------
        ImageFileError
            if `filename` doesn't look like nifti2;
        OSError
            if `filename` does not exist.
    
    save(img, filename)
        Save NIfTI2 single or pair to `filename`
        
        Parameters
        ----------
        filename : str
            filename to which to save image

DATA
    header_dtd = [('sizeof_hdr', 'i4'), ('magic', 'S4'), ('eol_check', 'i1...
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('magic', 'S4'), (...16')...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/nifti2.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& openers &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.openers in nibabel:

NAME
    nibabel.openers - Context manager openers for various fileobject types

CLASSES
    builtins.object
        Opener
            ImageOpener
    gzip.GzipFile(_compression.BaseStream)
        DeterministicGzipFile
    typing.Protocol(typing.Generic)
        Fileish
    
    class DeterministicGzipFile(gzip.GzipFile)
     |  DeterministicGzipFile(filename: 'str | None' = None, mode: 'Mode | None' = None, compresslevel: 'int' = 9, fileobj: 'io.FileIO | None' = None, mtime: 'int' = 0)
     |  
     |  Deterministic variant of GzipFile
     |  
     |  This writer does not add filename information to the header, and defaults
     |  to a modification time (``mtime``) of 0 seconds.
     |  
     |  Method resolution order:
     |      DeterministicGzipFile
     |      gzip.GzipFile
     |      _compression.BaseStream
     |      io.BufferedIOBase
     |      _io._BufferedIOBase
     |      io.IOBase
     |      _io._IOBase
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, filename: 'str | None' = None, mode: 'Mode | None' = None, compresslevel: 'int' = 9, fileobj: 'io.FileIO | None' = None, mtime: 'int' = 0)
     |      Constructor for the GzipFile class.
     |      
     |      At least one of fileobj and filename must be given a
     |      non-trivial value.
     |      
     |      The new class instance is based on fileobj, which can be a regular
     |      file, an io.BytesIO object, or any other object which simulates a file.
     |      It defaults to None, in which case filename is opened to provide
     |      a file object.
     |      
     |      When fileobj is not None, the filename argument is only used to be
     |      included in the gzip file header, which may include the original
     |      filename of the uncompressed file.  It defaults to the filename of
     |      fileobj, if discernible; otherwise, it defaults to the empty string,
     |      and in this case the original filename is not included in the header.
     |      
     |      The mode argument can be any of 'r', 'rb', 'a', 'ab', 'w', 'wb', 'x', or
     |      'xb' depending on whether the file will be read or written.  The default
     |      is the mode of fileobj if discernible; otherwise, the default is 'rb'.
     |      A mode of 'r' is equivalent to one of 'rb', and similarly for 'w' and
     |      'wb', 'a' and 'ab', and 'x' and 'xb'.
     |      
     |      The compresslevel argument is an integer from 0 to 9 controlling the
     |      level of compression; 1 is fastest and produces the least compression,
     |      and 9 is slowest and produces the most compression. 0 is no compression
     |      at all. The default is 9.
     |      
     |      The mtime argument is an optional numeric timestamp to be written
     |      to the last modification time field in the stream when compressing.
     |      If omitted or None, the current time is used.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from gzip.GzipFile:
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  close(self)
     |      Flush and close the IO object.
     |      
     |      This method has no effect if the file is already closed.
     |  
     |  fileno(self)
     |      Invoke the underlying file object's fileno() method.
     |      
     |      This will raise AttributeError if the underlying file object
     |      doesn't support fileno().
     |  
     |  flush(self, zlib_mode=2)
     |      Flush write buffers, if applicable.
     |      
     |      This is not implemented for read-only and non-blocking streams.
     |  
     |  peek(self, n)
     |  
     |  read(self, size=-1)
     |      Read and return up to n bytes.
     |      
     |      If the argument is omitted, None, or negative, reads and
     |      returns all data until EOF.
     |      
     |      If the argument is positive, and the underlying raw stream is
     |      not 'interactive', multiple raw reads may be issued to satisfy
     |      the byte count (unless EOF is reached first).  But for
     |      interactive raw streams (as well as sockets and pipes), at most
     |      one raw read will be issued, and a short result does not imply
     |      that EOF is imminent.
     |      
     |      Returns an empty bytes object on EOF.
     |      
     |      Returns None if the underlying raw stream was open in non-blocking
     |      mode and no data is available at the moment.
     |  
     |  read1(self, size=-1)
     |      Implements BufferedIOBase.read1()
     |      
     |      Reads up to a buffer's worth of data if size is negative.
     |  
     |  readable(self)
     |      Return whether object was opened for reading.
     |      
     |      If False, read() will raise OSError.
     |  
     |  readline(self, size=-1)
     |      Read and return a line from the stream.
     |      
     |      If size is specified, at most size bytes will be read.
     |      
     |      The line terminator is always b'\n' for binary files; for text
     |      files, the newlines argument to open can be used to select the line
     |      terminator(s) recognized.
     |  
     |  rewind(self)
     |      Return the uncompressed stream file position indicator to the
     |      beginning of the file
     |  
     |  seek(self, offset, whence=0)
     |      Change stream position.
     |      
     |      Change the stream position to the given byte offset. The offset is
     |      interpreted relative to the position indicated by whence.  Values
     |      for whence are:
     |      
     |      * 0 -- start of stream (the default); offset should be zero or positive
     |      * 1 -- current stream position; offset may be negative
     |      * 2 -- end of stream; offset is usually negative
     |      
     |      Return the new absolute position.
     |  
     |  seekable(self)
     |      Return whether object supports random access.
     |      
     |      If False, seek(), tell() and truncate() will raise OSError.
     |      This method may need to do a test seek().
     |  
     |  writable(self)
     |      Return whether object was opened for writing.
     |      
     |      If False, write() will raise OSError.
     |  
     |  write(self, data)
     |      Write the given buffer to the IO stream.
     |      
     |      Returns the number of bytes written, which is always the length of b
     |      in bytes.
     |      
     |      Raises BlockingIOError if the buffer is full and the
     |      underlying raw stream cannot accept more data at the moment.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from gzip.GzipFile:
     |  
     |  closed
     |  
     |  filename
     |  
     |  mtime
     |      Last modification time read from stream, or None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from gzip.GzipFile:
     |  
     |  myfileobj = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _io._BufferedIOBase:
     |  
     |  detach(self, /)
     |      Disconnect this buffer from its underlying raw stream and return it.
     |      
     |      After the raw stream has been detached, the buffer is in an unusable
     |      state.
     |  
     |  readinto(self, buffer, /)
     |  
     |  readinto1(self, buffer, /)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _io._IOBase:
     |  
     |  __del__(...)
     |  
     |  __enter__(...)
     |  
     |  __exit__(...)
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __next__(self, /)
     |      Implement next(self).
     |  
     |  isatty(self, /)
     |      Return whether this is an 'interactive' stream.
     |      
     |      Return False if it can't be determined.
     |  
     |  readlines(self, hint=-1, /)
     |      Return a list of lines from the stream.
     |      
     |      hint can be specified to control the number of lines read: no more
     |      lines will be read if the total size (in bytes/characters) of all
     |      lines so far exceeds hint.
     |  
     |  tell(self, /)
     |      Return current stream position.
     |  
     |  truncate(...)
     |      Truncate file to size bytes.
     |      
     |      File pointer is left unchanged.  Size defaults to the current IO
     |      position as reported by tell().  Returns the new size.
     |  
     |  writelines(self, lines, /)
     |      Write a list of lines to stream.
     |      
     |      Line separators are not added, so it is usual for each of the
     |      lines provided to have a line separator at the end.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from _io._IOBase:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _io._IOBase:
     |  
     |  __dict__
    
    class Fileish(typing.Protocol)
     |  Fileish(*args, **kwargs)
     |  
     |  Method resolution order:
     |      Fileish
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  read(self, size: 'int' = -1, /) -> 'bytes'
     |  
     |  write(self, b: 'bytes', /) -> 'int | None'
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class ImageOpener(Opener)
     |  ImageOpener(fileish: 'str | io.IOBase', *args, **kwargs)
     |  
     |  Opener-type class to collect extra compressed extensions
     |  
     |  A trivial sub-class of opener to which image classes can add extra
     |  extensions with custom openers, such as compressed openers.
     |  
     |  To add an extension, add a line to the class definition (not __init__):
     |  
     |      ImageOpener.compress_ext_map[ext] = func_def
     |  
     |  ``ext`` is a file extension beginning with '.' and should be included in
     |  the image class's ``valid_exts`` tuple.
     |  
     |  ``func_def`` is a `(function, (args,))` tuple, where `function accepts a
     |  filename as the first parameter, and `args` defines the other arguments
     |  that `function` accepts. These arguments must be any (unordered) subset of
     |  `mode`, `compresslevel`, and `buffering`.
     |  
     |  Method resolution order:
     |      ImageOpener
     |      Opener
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  compress_ext_map = {'.gz': (<function _gzip_open>, ('mode', 'compressl...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Opener:
     |  
     |  __enter__(self) -> 'Opener'
     |  
     |  __exit__(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'
     |  
     |  __init__(self, fileish: 'str | io.IOBase', *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self) -> 'ty.Iterator[bytes]'
     |  
     |  close(self, /) -> 'None'
     |  
     |  close_if_mine(self) -> 'None'
     |      Close ``self.fobj`` iff we opened it in the constructor
     |  
     |  fileno(self) -> 'int'
     |  
     |  read(self, size: 'int' = -1, /) -> 'bytes'
     |  
     |  readinto(self, buffer: 'WriteableBuffer', /) -> 'int | None'
     |  
     |  seek(self, pos: 'int', whence: 'int' = 0, /) -> 'int'
     |  
     |  tell(self, /) -> 'int'
     |  
     |  write(self, b: 'bytes', /) -> 'int | None'
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from Opener:
     |  
     |  closed
     |  
     |  mode
     |  
     |  name
     |      Return ``self.fobj.name`` or self._name if not present
     |      
     |      self._name will be None if object was created with a fileobj, otherwise
     |      it will be the filename.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Opener:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Opener:
     |  
     |  __annotations__ = {'compress_ext_icase': 'bool', 'compress_ext_map': '...
     |  
     |  bz2_def = (<class 'bz2.BZ2File'>, ('mode', 'buffering', 'compresslevel...
     |  
     |  compress_ext_icase = True
     |  
     |  default_compresslevel = 1
     |  
     |  default_level_or_option = {'r': None, 'rb': None, 'w': 3, 'wb': 3}
     |  
     |  default_zst_compresslevel = 3
     |  
     |  gz_def = (<function _gzip_open>, ('mode', 'compresslevel', 'mtime', 'k...
     |  
     |  zstd_def = (<function _zstd_open>, ('mode', 'level_or_option', 'zstd_d...
    
    class Opener(builtins.object)
     |  Opener(fileish: 'str | io.IOBase', *args, **kwargs)
     |  
     |  Class to accept, maybe open, and context-manage file-likes / filenames
     |  
     |  Provides context manager to close files that the constructor opened for
     |  you.
     |  
     |  Parameters
     |  ----------
     |  fileish : str or file-like
     |      if str, then open with suitable opening method. If file-like, accept as
     |      is
     |  \*args : positional arguments
     |      passed to opening method when `fileish` is str.  ``mode``, if not
     |      specified, is `rb`.  ``compresslevel``, if relevant, and not specified,
     |      is set from class variable ``default_compresslevel``. ``keep_open``, if
     |      relevant, and not specified, is ``False``.
     |  \*\*kwargs : keyword arguments
     |      passed to opening method when `fileish` is str.  Change of defaults as
     |      for \*args
     |  
     |  Methods defined here:
     |  
     |  __enter__(self) -> 'Opener'
     |  
     |  __exit__(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'
     |  
     |  __init__(self, fileish: 'str | io.IOBase', *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self) -> 'ty.Iterator[bytes]'
     |  
     |  close(self, /) -> 'None'
     |  
     |  close_if_mine(self) -> 'None'
     |      Close ``self.fobj`` iff we opened it in the constructor
     |  
     |  fileno(self) -> 'int'
     |  
     |  read(self, size: 'int' = -1, /) -> 'bytes'
     |  
     |  readinto(self, buffer: 'WriteableBuffer', /) -> 'int | None'
     |  
     |  seek(self, pos: 'int', whence: 'int' = 0, /) -> 'int'
     |  
     |  tell(self, /) -> 'int'
     |  
     |  write(self, b: 'bytes', /) -> 'int | None'
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  closed
     |  
     |  mode
     |  
     |  name
     |      Return ``self.fobj.name`` or self._name if not present
     |      
     |      self._name will be None if object was created with a fileobj, otherwise
     |      it will be the filename.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'compress_ext_icase': 'bool', 'compress_ext_map': '...
     |  
     |  bz2_def = (<class 'bz2.BZ2File'>, ('mode', 'buffering', 'compresslevel...
     |  
     |  compress_ext_icase = True
     |  
     |  compress_ext_map = {'.gz': (<function _gzip_open>, ('mode', 'compressl...
     |  
     |  default_compresslevel = 1
     |  
     |  default_level_or_option = {'r': None, 'rb': None, 'w': 3, 'wb': 3}
     |  
     |  default_zst_compresslevel = 3
     |  
     |  gz_def = (<function _gzip_open>, ('mode', 'compresslevel', 'mtime', 'k...
     |  
     |  zstd_def = (<function _zstd_open>, ('mode', 'level_or_option', 'zstd_d...

DATA
    HAVE_INDEXED_GZIP = True
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    pyzstd = <nibabel.tripwire.TripWire object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/openers.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& optpkg &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.optpkg in nibabel:

NAME
    nibabel.optpkg - Routines to support optional packages

FUNCTIONS
    optional_package(name: 'str', trip_msg: 'str | None' = None, min_version: 'str | Version | ty.Callable[[ModuleType], bool] | None' = None) -> 'tuple[ModuleType | TripWire, bool, ty.Callable[[], None]]'
        Return package-like thing and module setup for package `name`
        
        Parameters
        ----------
        name : str
            package name
        trip_msg : None or str
            message to give when someone tries to use the return package, but we
            could not import it at an acceptable version, and have returned a
            TripWire object instead. Default message if None.
        min_version : None or str or Version or callable
            If None, do not specify a minimum version.  If str, convert to a
            ``packaging.version.Version``.  If str or ``Version`` compare to
            version of package `name` with ``min_version <= pkg.__version__``.   If
            callable, accepts imported ``pkg`` as argument, and returns value of
            callable is True for acceptable package versions, False otherwise.
        
        Returns
        -------
        pkg_like : module or ``TripWire`` instance
            If we can import the package, return it.  Otherwise return an object
            raising an error when accessed
        have_pkg : bool
            True if import for package was successful, false otherwise
        module_setup : function
            callable usually set as ``setup_module`` in calling namespace, to allow
            skipping tests.
        
        Examples
        --------
        Typical use would be something like this at the top of a module using an
        optional package:
        
        >>> from nibabel.optpkg import optional_package
        >>> pkg, have_pkg, setup_module = optional_package('not_a_package')
        
        Of course in this case the package doesn't exist, and so, in the module:
        
        >>> have_pkg
        False
        
        and
        
        >>> pkg.some_function() #doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
            ...
        TripWireError: We need package not_a_package for these functions,
            but ``import not_a_package`` raised an ImportError
        
        If the module does exist - we get the module
        
        >>> pkg, _, _ = optional_package('os')
        >>> hasattr(pkg, 'path')
        True
        
        Or a submodule if that's what we asked for
        
        >>> subpkg, _, _ = optional_package('os.path')
        >>> hasattr(subpkg, 'dirname')
        True

DATA
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/optpkg.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& orientations &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.orientations in nibabel:

NAME
    nibabel.orientations - Utilities for calculating and applying affine orientations

CLASSES
    builtins.Exception(builtins.BaseException)
        OrientationError
    
    class OrientationError(builtins.Exception)
     |  Method resolution order:
     |      OrientationError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    aff2axcodes(aff, labels=None, tol=None)
        axis direction codes for affine `aff`
        
        Parameters
        ----------
        aff : (N,M) array-like
            affine transformation matrix
        labels : optional, None or sequence of (2,) sequences
            Labels for negative and positive ends of output axes of `aff`.  See
            docstring for ``ornt2axcodes`` for more detail
        tol : None or float
            Tolerance for SVD of affine - see ``io_orientation`` for more detail.
        
        Returns
        -------
        axcodes : (N,) tuple
            labels for positive end of voxel axes.  Dropped axes get a label of
            None.
        
        Examples
        --------
        >>> aff = [[0,1,0,10],[-1,0,0,20],[0,0,1,30],[0,0,0,1]]
        >>> aff2axcodes(aff, (('L','R'),('B','F'),('D','U')))
        ('B', 'R', 'U')
    
    apply_orientation(arr, ornt)
        Apply transformations implied by `ornt` to the first
        n axes of the array `arr`
        
        Parameters
        ----------
        arr : array-like of data with ndim >= n
        ornt : (n,2) orientation array
           orientation transform. ``ornt[N,1]` is flip of axis N of the
           array implied by `shape`, where 1 means no flip and -1 means
           flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
           there's an array ``arr`` of shape `shape`, the flip would
           correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
           the transpose that needs to be done to the implied array, as in
           ``arr.transpose(ornt[:,0])``
        
        Returns
        -------
        t_arr : ndarray
           data array `arr` transformed according to ornt
    
    axcodes2ornt(axcodes, labels=None)
        Convert axis codes `axcodes` to an orientation
        
        Parameters
        ----------
        axcodes : (N,) tuple
            axis codes - see ornt2axcodes docstring
        labels : optional, None or sequence of (2,) sequences
            (2,) sequences are labels for (beginning, end) of output axis.  That
            is, if the first element in `axcodes` is ``front``, and the second
            (2,) sequence in `labels` is ('back', 'front') then the first
            row of `ornt` will be ``[1, 1]``. If None, equivalent to
            ``(('L','R'),('P','A'),('I','S'))`` - that is - RAS axes.
        
        Returns
        -------
        ornt : (N,2) array-like
            orientation array - see io_orientation docstring
        
        Examples
        --------
        >>> axcodes2ornt(('F', 'L', 'U'), (('L','R'),('B','F'),('D','U')))
        array([[ 1.,  1.],
               [ 0., -1.],
               [ 2.,  1.]])
    
    flip_axis(arr, axis=0)
        Flip contents of `axis` in array `arr`
        
        flip_axis is deprecated. Please use numpy.flip instead.
        
        * deprecated from version: 3.2
        * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
    
    inv_ornt_aff(ornt, shape)
        Affine transform reversing transforms implied in `ornt`
        
        Imagine you have an array ``arr`` of shape `shape`, and you apply the
        transforms implied by `ornt` (more below), to get ``tarr``.
        ``tarr`` may have a different shape ``shape_prime``.  This routine
        returns the affine that will take a array coordinate for ``tarr``
        and give you the corresponding array coordinate in ``arr``.
        
        Parameters
        ----------
        ornt : (p, 2) ndarray
           orientation transform. ``ornt[P, 1]` is flip of axis N of the array
           implied by `shape`, where 1 means no flip and -1 means flip.  For
           example, if ``P==0`` and ``ornt[0, 1] == -1``, and there's an array
           ``arr`` of shape `shape`, the flip would correspond to the effect of
           ``np.flipud(arr)``.  ``ornt[:,0]`` gives us the (reverse of the)
           transpose that has been done to ``arr``.  If there are any NaNs in
           `ornt`, we raise an ``OrientationError`` (see notes)
        shape : length p sequence
           shape of array you may transform with `ornt`
        
        Returns
        -------
        transform_affine : (p + 1, p + 1) ndarray
           An array ``arr`` (shape `shape`) might be transformed according to
           `ornt`, resulting in a transformed array ``tarr``.  `transformed_affine`
           is the transform that takes you from array coordinates in ``tarr`` to
           array coordinates in ``arr``.
        
        Notes
        -----
        If a row in `ornt` contains NaN, this means that the input row does not
        influence the output space, and is thus effectively dropped from the output
        space.  In that case one ``tarr`` coordinate maps to many ``arr``
        coordinates, we can't invert the transform, and we raise an error
    
    io_orientation(affine, tol=None)
        Orientation of input axes in terms of output axes for `affine`
        
        Valid for an affine transformation from ``p`` dimensions to ``q``
        dimensions (``affine.shape == (q + 1, p + 1)``).
        
        The calculated orientations can be used to transform associated
        arrays to best match the output orientations. If ``p`` > ``q``, then
        some of the output axes should be considered dropped in this
        orientation.
        
        Parameters
        ----------
        affine : (q+1, p+1) ndarray-like
           Transformation affine from ``p`` inputs to ``q`` outputs.  Usually this
           will be a shape (4,4) matrix, transforming 3 inputs to 3 outputs, but
           the code also handles the more general case
        tol : {None, float}, optional
           threshold below which SVD values of the affine are considered zero. If
           `tol` is None, and ``S`` is an array with singular values for `affine`,
           and ``eps`` is the epsilon value for datatype of ``S``, then `tol` set
           to ``S.max() * max((q, p)) * eps``
        
        Returns
        -------
        orientations : (p, 2) ndarray
           one row per input axis, where the first value in each row is the closest
           corresponding output axis. The second value in each row is 1 if the
           input axis is in the same direction as the corresponding output axis and
           -1 if it is in the opposite direction.  If a row is [np.nan, np.nan],
           which can happen when p > q, then this row should be considered dropped.
    
    ornt2axcodes(ornt, labels=None)
        Convert orientation `ornt` to labels for axis directions
        
        Parameters
        ----------
        ornt : (N,2) array-like
            orientation array - see io_orientation docstring
        labels : optional, None or sequence of (2,) sequences
            (2,) sequences are labels for (beginning, end) of output axis.  That
            is, if the first row in `ornt` is ``[1, 1]``, and the second (2,)
            sequence in `labels` is ('back', 'front') then the first returned axis
            code will be ``'front'``.  If the first row in `ornt` had been
            ``[1, -1]`` then the first returned value would have been ``'back'``.
            If None, equivalent to ``(('L','R'),('P','A'),('I','S'))`` - that is -
            RAS axes.
        
        Returns
        -------
        axcodes : (N,) tuple
            labels for positive end of voxel axes.  Dropped axes get a label of
            None.
        
        Examples
        --------
        >>> ornt2axcodes([[1, 1],[0,-1],[2,1]], (('L','R'),('B','F'),('D','U')))
        ('F', 'L', 'U')
    
    ornt_transform(start_ornt, end_ornt)
        Return the orientation that transforms from `start_ornt` to `end_ornt`.
        
        Parameters
        ----------
        start_ornt : (n,2) orientation array
            Initial orientation.
        
        end_ornt : (n,2) orientation array
            Final orientation.
        
        Returns
        -------
        orientations : (p, 2) ndarray
           The orientation that will transform the `start_ornt` to the `end_ornt`.

DATA
    deprecate_with_version = <nibabel.deprecator.Deprecator object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/orientations.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& os &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module os:

NAME
    os - OS routines for NT or Posix depending on what system we're on.

MODULE REFERENCE
    https://docs.python.org/3.9/library/os
    
    The following documentation is automatically generated from the Python
    source files.  It may be incomplete, incorrect or include features that
    are considered implementation detail and may vary between Python
    implementations.  When in doubt, consult the module reference at the
    location listed above.

DESCRIPTION
    This exports:
      - all functions from posix or nt, e.g. unlink, stat, etc.
      - os.path is either posixpath or ntpath
      - os.name is either 'posix' or 'nt'
      - os.curdir is a string representing the current directory (always '.')
      - os.pardir is a string representing the parent directory (always '..')
      - os.sep is the (or a most common) pathname separator ('/' or '\\')
      - os.extsep is the extension separator (always '.')
      - os.altsep is the alternate pathname separator (None or '/')
      - os.pathsep is the component separator used in $PATH etc
      - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
      - os.defpath is the default search path for executables
      - os.devnull is the file path of the null device ('/dev/null', etc.)
    
    Programs that import and use 'os' stand a better chance of being
    portable between different platforms.  Of course, they must then
    only use functions that are defined by all platforms (e.g., unlink
    and opendir), and leave all pathname manipulation to os.path
    (e.g., split and join).

CLASSES
    builtins.Exception(builtins.BaseException)
        builtins.OSError
    builtins.object
        posix.DirEntry
    builtins.tuple(builtins.object)
        stat_result
        statvfs_result
        terminal_size
        posix.times_result
        posix.uname_result
    
    class DirEntry(builtins.object)
     |  Methods defined here:
     |  
     |  __fspath__(self, /)
     |      Returns the path for the entry.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  inode(self, /)
     |      Return inode of the entry; cached per entry.
     |  
     |  is_dir(self, /, *, follow_symlinks=True)
     |      Return True if the entry is a directory; cached per entry.
     |  
     |  is_file(self, /, *, follow_symlinks=True)
     |      Return True if the entry is a file; cached per entry.
     |  
     |  is_symlink(self, /)
     |      Return True if the entry is a symbolic link; cached per entry.
     |  
     |  stat(self, /, *, follow_symlinks=True)
     |      Return stat_result object for the entry; cached per entry.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  name
     |      the entry's base filename, relative to scandir() "path" argument
     |  
     |  path
     |      the entry's full path name; equivalent to os.path.join(scandir_path, entry.name)
    
    error = class OSError(Exception)
     |  Base class for I/O related errors.
     |  
     |  Method resolution order:
     |      OSError
     |      Exception
     |      BaseException
     |      object
     |  
     |  Built-in subclasses:
     |      BlockingIOError
     |      ChildProcessError
     |      ConnectionError
     |      FileExistsError
     |      ... and 7 other subclasses
     |  
     |  Methods defined here:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  characters_written
     |  
     |  errno
     |      POSIX exception code
     |  
     |  filename
     |      exception filename
     |  
     |  filename2
     |      second exception filename
     |  
     |  strerror
     |      exception strerror
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class stat_result(builtins.tuple)
     |  stat_result(iterable=(), /)
     |  
     |  stat_result: Result from stat, fstat, or lstat.
     |  
     |  This object may be accessed either as a tuple of
     |    (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)
     |  or via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.
     |  
     |  Posix/windows: If your platform supports st_blksize, st_blocks, st_rdev,
     |  or st_flags, they are available as attributes only.
     |  
     |  See os.stat for more information.
     |  
     |  Method resolution order:
     |      stat_result
     |      builtins.tuple
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  st_atime
     |      time of last access
     |  
     |  st_atime_ns
     |      time of last access in nanoseconds
     |  
     |  st_birthtime
     |      time of creation
     |  
     |  st_blksize
     |      blocksize for filesystem I/O
     |  
     |  st_blocks
     |      number of blocks allocated
     |  
     |  st_ctime
     |      time of last change
     |  
     |  st_ctime_ns
     |      time of last change in nanoseconds
     |  
     |  st_dev
     |      device
     |  
     |  st_flags
     |      user defined flags for file
     |  
     |  st_gen
     |      generation number
     |  
     |  st_gid
     |      group ID of owner
     |  
     |  st_ino
     |      inode
     |  
     |  st_mode
     |      protection bits
     |  
     |  st_mtime
     |      time of last modification
     |  
     |  st_mtime_ns
     |      time of last modification in nanoseconds
     |  
     |  st_nlink
     |      number of hard links
     |  
     |  st_rdev
     |      device type (if inode device)
     |  
     |  st_size
     |      total size, in bytes
     |  
     |  st_uid
     |      user ID of owner
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  n_fields = 22
     |  
     |  n_sequence_fields = 10
     |  
     |  n_unnamed_fields = 3
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.tuple:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __getnewargs__(self, /)
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.tuple:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585
    
    class statvfs_result(builtins.tuple)
     |  statvfs_result(iterable=(), /)
     |  
     |  statvfs_result: Result from statvfs or fstatvfs.
     |  
     |  This object may be accessed either as a tuple of
     |    (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),
     |  or via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.
     |  
     |  See os.statvfs for more information.
     |  
     |  Method resolution order:
     |      statvfs_result
     |      builtins.tuple
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  f_bavail
     |  
     |  f_bfree
     |  
     |  f_blocks
     |  
     |  f_bsize
     |  
     |  f_favail
     |  
     |  f_ffree
     |  
     |  f_files
     |  
     |  f_flag
     |  
     |  f_frsize
     |  
     |  f_fsid
     |  
     |  f_namemax
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  n_fields = 11
     |  
     |  n_sequence_fields = 10
     |  
     |  n_unnamed_fields = 0
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.tuple:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __getnewargs__(self, /)
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.tuple:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585
    
    class terminal_size(builtins.tuple)
     |  terminal_size(iterable=(), /)
     |  
     |  A tuple of (columns, lines) for holding terminal window size
     |  
     |  Method resolution order:
     |      terminal_size
     |      builtins.tuple
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  columns
     |      width of the terminal window in characters
     |  
     |  lines
     |      height of the terminal window in characters
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  n_fields = 2
     |  
     |  n_sequence_fields = 2
     |  
     |  n_unnamed_fields = 0
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.tuple:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __getnewargs__(self, /)
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.tuple:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585
    
    class times_result(builtins.tuple)
     |  times_result(iterable=(), /)
     |  
     |  times_result: Result from os.times().
     |  
     |  This object may be accessed either as a tuple of
     |    (user, system, children_user, children_system, elapsed),
     |  or via the attributes user, system, children_user, children_system,
     |  and elapsed.
     |  
     |  See os.times for more information.
     |  
     |  Method resolution order:
     |      times_result
     |      builtins.tuple
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  children_system
     |      system time of children
     |  
     |  children_user
     |      user time of children
     |  
     |  elapsed
     |      elapsed time since an arbitrary point in the past
     |  
     |  system
     |      system time
     |  
     |  user
     |      user time
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  n_fields = 5
     |  
     |  n_sequence_fields = 5
     |  
     |  n_unnamed_fields = 0
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.tuple:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __getnewargs__(self, /)
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.tuple:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585
    
    class uname_result(builtins.tuple)
     |  uname_result(iterable=(), /)
     |  
     |  uname_result: Result from os.uname().
     |  
     |  This object may be accessed either as a tuple of
     |    (sysname, nodename, release, version, machine),
     |  or via the attributes sysname, nodename, release, version, and machine.
     |  
     |  See os.uname for more information.
     |  
     |  Method resolution order:
     |      uname_result
     |      builtins.tuple
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  machine
     |      hardware identifier
     |  
     |  nodename
     |      name of machine on network (implementation-defined)
     |  
     |  release
     |      operating system release
     |  
     |  sysname
     |      operating system name
     |  
     |  version
     |      operating system version
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  n_fields = 5
     |  
     |  n_sequence_fields = 5
     |  
     |  n_unnamed_fields = 0
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.tuple:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __getnewargs__(self, /)
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.tuple:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585

FUNCTIONS
    WCOREDUMP(status, /)
        Return True if the process returning status was dumped to a core file.
    
    WEXITSTATUS(status)
        Return the process return code from status.
    
    WIFCONTINUED(status)
        Return True if a particular process was continued from a job control stop.
        
        Return True if the process returning status was continued from a
        job control stop.
    
    WIFEXITED(status)
        Return True if the process returning status exited via the exit() system call.
    
    WIFSIGNALED(status)
        Return True if the process returning status was terminated by a signal.
    
    WIFSTOPPED(status)
        Return True if the process returning status was stopped.
    
    WSTOPSIG(status)
        Return the signal that stopped the process that provided the status value.
    
    WTERMSIG(status)
        Return the signal that terminated the process that provided the status value.
    
    _exit(status)
        Exit to the system with specified status, without normal exit processing.
    
    abort()
        Abort the interpreter immediately.
        
        This function 'dumps core' or otherwise fails in the hardest way possible
        on the hosting operating system.  This function never returns.
    
    access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)
        Use the real uid/gid to test for access to a path.
        
          path
            Path to be tested; can be string, bytes, or a path-like object.
          mode
            Operating-system mode bitfield.  Can be F_OK to test existence,
            or the inclusive-OR of R_OK, W_OK, and X_OK.
          dir_fd
            If not None, it should be a file descriptor open to a directory,
            and path should be relative; path will then be relative to that
            directory.
          effective_ids
            If True, access will use the effective uid/gid instead of
            the real uid/gid.
          follow_symlinks
            If False, and the last element of the path is a symbolic link,
            access will examine the symbolic link itself instead of the file
            the link points to.
        
        dir_fd, effective_ids, and follow_symlinks may not be implemented
          on your platform.  If they are unavailable, using them will raise a
          NotImplementedError.
        
        Note that most operations will use the effective uid/gid, therefore this
          routine can be used in a suid/sgid environment to test if the invoking user
          has the specified access to the path.
    
    chdir(path)
        Change the current working directory to the specified path.
        
        path may always be specified as a string.
        On some platforms, path may also be specified as an open file descriptor.
          If this functionality is unavailable, using it raises an exception.
    
    chflags(path, flags, follow_symlinks=True)
        Set file flags.
        
        If follow_symlinks is False, and the last element of the path is a symbolic
          link, chflags will change flags on the symbolic link itself instead of the
          file the link points to.
        follow_symlinks may not be implemented on your platform.  If it is
        unavailable, using it will raise a NotImplementedError.
    
    chmod(path, mode, *, dir_fd=None, follow_symlinks=True)
        Change the access permissions of a file.
        
          path
            Path to be modified.  May always be specified as a str, bytes, or a path-like object.
            On some platforms, path may also be specified as an open file descriptor.
            If this functionality is unavailable, using it raises an exception.
          mode
            Operating-system mode bitfield.
          dir_fd
            If not None, it should be a file descriptor open to a directory,
            and path should be relative; path will then be relative to that
            directory.
          follow_symlinks
            If False, and the last element of the path is a symbolic link,
            chmod will modify the symbolic link itself instead of the file
            the link points to.
        
        It is an error to use dir_fd or follow_symlinks when specifying path as
          an open file descriptor.
        dir_fd and follow_symlinks may not be implemented on your platform.
          If they are unavailable, using them will raise a NotImplementedError.
    
    chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)
        Change the owner and group id of path to the numeric uid and gid.\
        
          path
            Path to be examined; can be string, bytes, a path-like object, or open-file-descriptor int.
          dir_fd
            If not None, it should be a file descriptor open to a directory,
            and path should be relative; path will then be relative to that
            directory.
          follow_symlinks
            If False, and the last element of the path is a symbolic link,
            stat will examine the symbolic link itself instead of the file
            the link points to.
        
        path may always be specified as a string.
        On some platforms, path may also be specified as an open file descriptor.
          If this functionality is unavailable, using it raises an exception.
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        If follow_symlinks is False, and the last element of the path is a symbolic
          link, chown will modify the symbolic link itself instead of the file the
          link points to.
        It is an error to use dir_fd or follow_symlinks when specifying path as
          an open file descriptor.
        dir_fd and follow_symlinks may not be implemented on your platform.
          If they are unavailable, using them will raise a NotImplementedError.
    
    chroot(path)
        Change root directory to path.
    
    close(fd)
        Close a file descriptor.
    
    closerange(fd_low, fd_high, /)
        Closes all file descriptors in [fd_low, fd_high), ignoring errors.
    
    confstr(name, /)
        Return a string-valued system configuration variable.
    
    cpu_count()
        Return the number of CPUs in the system; return None if indeterminable.
        
        This number is not equivalent to the number of CPUs the current process can
        use.  The number of usable CPUs can be obtained with
        ``len(os.sched_getaffinity(0))``
    
    ctermid()
        Return the name of the controlling terminal for this process.
    
    device_encoding(fd)
        Return a string describing the encoding of a terminal's file descriptor.
        
        The file descriptor must be attached to a terminal.
        If the device is not a terminal, return None.
    
    dup(fd, /)
        Return a duplicate of a file descriptor.
    
    dup2(fd, fd2, inheritable=True)
        Duplicate file descriptor.
    
    execl(file, *args)
        execl(file, *args)
        
        Execute the executable file with argument list args, replacing the
        current process.
    
    execle(file, *args)
        execle(file, *args, env)
        
        Execute the executable file with argument list args and
        environment env, replacing the current process.
    
    execlp(file, *args)
        execlp(file, *args)
        
        Execute the executable file (which is searched for along $PATH)
        with argument list args, replacing the current process.
    
    execlpe(file, *args)
        execlpe(file, *args, env)
        
        Execute the executable file (which is searched for along $PATH)
        with argument list args and environment env, replacing the current
        process.
    
    execv(path, argv, /)
        Execute an executable path with arguments, replacing current process.
        
        path
          Path of executable file.
        argv
          Tuple or list of strings.
    
    execve(path, argv, env)
        Execute an executable path with arguments, replacing current process.
        
        path
          Path of executable file.
        argv
          Tuple or list of strings.
        env
          Dictionary of strings mapping to strings.
    
    execvp(file, args)
        execvp(file, args)
        
        Execute the executable file (which is searched for along $PATH)
        with argument list args, replacing the current process.
        args may be a list or tuple of strings.
    
    execvpe(file, args, env)
        execvpe(file, args, env)
        
        Execute the executable file (which is searched for along $PATH)
        with argument list args and environment env, replacing the
        current process.
        args may be a list or tuple of strings.
    
    fchdir(fd)
        Change to the directory of the given file descriptor.
        
        fd must be opened on a directory, not a file.
        Equivalent to os.chdir(fd).
    
    fchmod(fd, mode)
        Change the access permissions of the file given by file descriptor fd.
        
        Equivalent to os.chmod(fd, mode).
    
    fchown(fd, uid, gid)
        Change the owner and group id of the file specified by file descriptor.
        
        Equivalent to os.chown(fd, uid, gid).
    
    fdopen(fd, *args, **kwargs)
        # Supply os.fdopen()
    
    fork()
        Fork a child process.
        
        Return 0 to child process and PID of child to parent process.
    
    forkpty()
        Fork a new process with a new pseudo-terminal as controlling tty.
        
        Returns a tuple of (pid, master_fd).
        Like fork(), return pid of 0 to the child process,
        and pid of child to the parent process.
        To both, return fd of newly opened pseudo-terminal.
    
    fpathconf(fd, name, /)
        Return the configuration limit name for the file descriptor fd.
        
        If there is no limit, return -1.
    
    fsdecode(filename)
        Decode filename (an os.PathLike, bytes, or str) from the filesystem
        encoding with 'surrogateescape' error handler, return str unchanged. On
        Windows, use 'strict' error handler if the file system encoding is
        'mbcs' (which is the default encoding).
    
    fsencode(filename)
        Encode filename (an os.PathLike, bytes, or str) to the filesystem
        encoding with 'surrogateescape' error handler, return bytes unchanged.
        On Windows, use 'strict' error handler if the file system encoding is
        'mbcs' (which is the default encoding).
    
    fspath(path)
        Return the file system path representation of the object.
        
        If the object is str or bytes, then allow it to pass through as-is. If the
        object defines __fspath__(), then return the result of that method. All other
        types raise a TypeError.
    
    fstat(fd)
        Perform a stat system call on the given file descriptor.
        
        Like stat(), but for an open file descriptor.
        Equivalent to os.stat(fd).
    
    fstatvfs(fd, /)
        Perform an fstatvfs system call on the given fd.
        
        Equivalent to statvfs(fd).
    
    fsync(fd)
        Force write of fd to disk.
    
    ftruncate(fd, length, /)
        Truncate a file, specified by file descriptor, to a specific length.
    
    fwalk(top='.', topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None)
        Directory tree generator.
        
        This behaves exactly like walk(), except that it yields a 4-tuple
        
            dirpath, dirnames, filenames, dirfd
        
        `dirpath`, `dirnames` and `filenames` are identical to walk() output,
        and `dirfd` is a file descriptor referring to the directory `dirpath`.
        
        The advantage of fwalk() over walk() is that it's safe against symlink
        races (when follow_symlinks is False).
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and top should be relative; top will then be relative to that directory.
          (dir_fd is always supported for fwalk.)
        
        Caution:
        Since fwalk() yields file descriptors, those are only valid until the
        next iteration step, so you should dup() them if you want to keep them
        for a longer period.
        
        Example:
        
        import os
        for root, dirs, files, rootfd in os.fwalk('python/Lib/email'):
            print(root, "consumes", end="")
            print(sum(os.stat(name, dir_fd=rootfd).st_size for name in files),
                  end="")
            print("bytes in", len(files), "non-directory files")
            if 'CVS' in dirs:
                dirs.remove('CVS')  # don't visit CVS directories
    
    get_blocking(fd, /)
        Get the blocking mode of the file descriptor.
        
        Return False if the O_NONBLOCK flag is set, True if the flag is cleared.
    
    get_exec_path(env=None)
        Returns the sequence of directories that will be searched for the
        named executable (similar to a shell) when launching a process.
        
        *env* must be an environment variable dict or None.  If *env* is None,
        os.environ will be used.
    
    get_inheritable(fd, /)
        Get the close-on-exe flag of the specified file descriptor.
    
    get_terminal_size(...)
        Return the size of the terminal window as (columns, lines).
        
        The optional argument fd (default standard output) specifies
        which file descriptor should be queried.
        
        If the file descriptor is not connected to a terminal, an OSError
        is thrown.
        
        This function will only be defined if an implementation is
        available for this system.
        
        shutil.get_terminal_size is the high-level function which should
        normally be used, os.get_terminal_size is the low-level implementation.
    
    getcwd()
        Return a unicode string representing the current working directory.
    
    getcwdb()
        Return a bytes string representing the current working directory.
    
    getegid()
        Return the current process's effective group id.
    
    getenv(key, default=None)
        Get an environment variable, return None if it doesn't exist.
        The optional second argument can specify an alternate default.
        key, default and the result are str.
    
    getenvb(key, default=None)
        Get an environment variable, return None if it doesn't exist.
        The optional second argument can specify an alternate default.
        key, default and the result are bytes.
    
    geteuid()
        Return the current process's effective user id.
    
    getgid()
        Return the current process's group id.
    
    getgrouplist(user, group, /)
        Returns a list of groups to which a user belongs.
        
        user
          username to lookup
        group
          base group id of the user
    
    getgroups()
        Return list of supplemental group IDs for the process.
    
    getloadavg()
        Return average recent system load information.
        
        Return the number of processes in the system run queue averaged over
        the last 1, 5, and 15 minutes as a tuple of three floats.
        Raises OSError if the load average was unobtainable.
    
    getlogin()
        Return the actual login name.
    
    getpgid(pid)
        Call the system call getpgid(), and return the result.
    
    getpgrp()
        Return the current process group id.
    
    getpid()
        Return the current process id.
    
    getppid()
        Return the parent's process id.
        
        If the parent process has already exited, Windows machines will still
        return its id; others systems will return the id of the 'init' process (1).
    
    getpriority(which, who)
        Return program scheduling priority.
    
    getsid(pid, /)
        Call the system call getsid(pid) and return the result.
    
    getuid()
        Return the current process's user id.
    
    initgroups(username, gid, /)
        Initialize the group access list.
        
        Call the system initgroups() to initialize the group access list with all of
        the groups of which the specified username is a member, plus the specified
        group id.
    
    isatty(fd, /)
        Return True if the fd is connected to a terminal.
        
        Return True if the file descriptor is an open file descriptor
        connected to the slave end of a terminal.
    
    kill(pid, signal, /)
        Kill a process with a signal.
    
    killpg(pgid, signal, /)
        Kill a process group with a signal.
    
    lchflags(path, flags)
        Set file flags.
        
        This function will not follow symbolic links.
        Equivalent to chflags(path, flags, follow_symlinks=False).
    
    lchmod(path, mode)
        Change the access permissions of a file, without following symbolic links.
        
        If path is a symlink, this affects the link itself rather than the target.
        Equivalent to chmod(path, mode, follow_symlinks=False)."
    
    lchown(path, uid, gid)
        Change the owner and group id of path to the numeric uid and gid.
        
        This function will not follow symbolic links.
        Equivalent to os.chown(path, uid, gid, follow_symlinks=False).
    
    link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)
        Create a hard link to a file.
        
        If either src_dir_fd or dst_dir_fd is not None, it should be a file
          descriptor open to a directory, and the respective path string (src or dst)
          should be relative; the path will then be relative to that directory.
        If follow_symlinks is False, and the last element of src is a symbolic
          link, link will create a link to the symbolic link itself instead of the
          file the link points to.
        src_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your
          platform.  If they are unavailable, using them will raise a
          NotImplementedError.
    
    listdir(path=None)
        Return a list containing the names of the files in the directory.
        
        path can be specified as either str, bytes, or a path-like object.  If path is bytes,
          the filenames returned will also be bytes; in all other circumstances
          the filenames returned will be str.
        If path is None, uses the path='.'.
        On some platforms, path may also be specified as an open file descriptor;\
          the file descriptor must refer to a directory.
          If this functionality is unavailable, using it raises NotImplementedError.
        
        The list is in arbitrary order.  It does not include the special
        entries '.' and '..' even if they are present in the directory.
    
    lockf(fd, command, length, /)
        Apply, test or remove a POSIX lock on an open file descriptor.
        
        fd
          An open file descriptor.
        command
          One of F_LOCK, F_TLOCK, F_ULOCK or F_TEST.
        length
          The number of bytes to lock, starting at the current position.
    
    lseek(fd, position, how, /)
        Set the position of a file descriptor.  Return the new position.
        
        Return the new cursor position in number of bytes
        relative to the beginning of the file.
    
    lstat(path, *, dir_fd=None)
        Perform a stat system call on the given path, without following symbolic links.
        
        Like stat(), but do not follow symbolic links.
        Equivalent to stat(path, follow_symlinks=False).
    
    major(device, /)
        Extracts a device major number from a raw device number.
    
    makedev(major, minor, /)
        Composes a raw device number from the major and minor device numbers.
    
    makedirs(name, mode=511, exist_ok=False)
        makedirs(name [, mode=0o777][, exist_ok=False])
        
        Super-mkdir; create a leaf directory and all intermediate ones.  Works like
        mkdir, except that any intermediate path segment (not just the rightmost)
        will be created if it does not exist. If the target directory already
        exists, raise an OSError if exist_ok is False. Otherwise no exception is
        raised.  This is recursive.
    
    minor(device, /)
        Extracts a device minor number from a raw device number.
    
    mkdir(path, mode=511, *, dir_fd=None)
        Create a directory.
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
          If it is unavailable, using it will raise a NotImplementedError.
        
        The mode argument is ignored on Windows.
    
    mkfifo(path, mode=438, *, dir_fd=None)
        Create a "fifo" (a POSIX named pipe).
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
          If it is unavailable, using it will raise a NotImplementedError.
    
    mknod(path, mode=384, device=0, *, dir_fd=None)
        Create a node in the file system.
        
        Create a node in the file system (file, device special file or named pipe)
        at path.  mode specifies both the permissions to use and the
        type of node to be created, being combined (bitwise OR) with one of
        S_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO.  If S_IFCHR or S_IFBLK is set on mode,
        device defines the newly created device special file (probably using
        os.makedev()).  Otherwise device is ignored.
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
          If it is unavailable, using it will raise a NotImplementedError.
    
    nice(increment, /)
        Add increment to the priority of process and return the new priority.
    
    open(path, flags, mode=511, *, dir_fd=None)
        Open a file for low level IO.  Returns a file descriptor (integer).
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
          If it is unavailable, using it will raise a NotImplementedError.
    
    openpty()
        Open a pseudo-terminal.
        
        Return a tuple of (master_fd, slave_fd) containing open file descriptors
        for both the master and slave ends.
    
    pathconf(path, name)
        Return the configuration limit name for the file or directory path.
        
        If there is no limit, return -1.
        On some platforms, path may also be specified as an open file descriptor.
          If this functionality is unavailable, using it raises an exception.
    
    pipe()
        Create a pipe.
        
        Returns a tuple of two file descriptors:
          (read_fd, write_fd)
    
    popen(cmd, mode='r', buffering=-1)
        # Supply os.popen()
    
    posix_spawn(...)
        Execute the program specified by path in a new process.
        
        path
          Path of executable file.
        argv
          Tuple or list of strings.
        env
          Dictionary of strings mapping to strings.
        file_actions
          A sequence of file action tuples.
        setpgroup
          The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.
        resetids
          If the value is `true` the POSIX_SPAWN_RESETIDS will be activated.
        setsid
          If the value is `true` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.
        setsigmask
          The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.
        setsigdef
          The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.
        scheduler
          A tuple with the scheduler policy (optional) and parameters.
    
    posix_spawnp(...)
        Execute the program specified by path in a new process.
        
        path
          Path of executable file.
        argv
          Tuple or list of strings.
        env
          Dictionary of strings mapping to strings.
        file_actions
          A sequence of file action tuples.
        setpgroup
          The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.
        resetids
          If the value is `True` the POSIX_SPAWN_RESETIDS will be activated.
        setsid
          If the value is `True` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.
        setsigmask
          The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.
        setsigdef
          The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.
        scheduler
          A tuple with the scheduler policy (optional) and parameters.
    
    pread(fd, length, offset, /)
        Read a number of bytes from a file descriptor starting at a particular offset.
        
        Read length bytes from file descriptor fd, starting at offset bytes from
        the beginning of the file.  The file offset remains unchanged.
    
    preadv(fd, buffers, offset, flags=0, /)
        Reads from a file descriptor into a number of mutable bytes-like objects.
        
        Combines the functionality of readv() and pread(). As readv(), it will
        transfer data into each buffer until it is full and then move on to the next
        buffer in the sequence to hold the rest of the data. Its fourth argument,
        specifies the file offset at which the input operation is to be performed. It
        will return the total number of bytes read (which can be less than the total
        capacity of all the objects).
        
        The flags argument contains a bitwise OR of zero or more of the following flags:
        
        - RWF_HIPRI
        - RWF_NOWAIT
        
        Using non-zero flags requires Linux 4.6 or newer.
    
    putenv(name, value, /)
        Change or add an environment variable.
    
    pwrite(fd, buffer, offset, /)
        Write bytes to a file descriptor starting at a particular offset.
        
        Write buffer to fd, starting at offset bytes from the beginning of
        the file.  Returns the number of bytes writte.  Does not change the
        current file offset.
    
    pwritev(fd, buffers, offset, flags=0, /)
        Writes the contents of bytes-like objects to a file descriptor at a given offset.
        
        Combines the functionality of writev() and pwrite(). All buffers must be a sequence
        of bytes-like objects. Buffers are processed in array order. Entire contents of first
        buffer is written before proceeding to second, and so on. The operating system may
        set a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used.
        This function writes the contents of each object to the file descriptor and returns
        the total number of bytes written.
        
        The flags argument contains a bitwise OR of zero or more of the following flags:
        
        - RWF_DSYNC
        - RWF_SYNC
        
        Using non-zero flags requires Linux 4.7 or newer.
    
    read(fd, length, /)
        Read from a file descriptor.  Returns a bytes object.
    
    readlink(path, *, dir_fd=None)
        Return a string representing the path to which the symbolic link points.
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
        and path should be relative; path will then be relative to that directory.
        
        dir_fd may not be implemented on your platform.  If it is unavailable,
        using it will raise a NotImplementedError.
    
    readv(fd, buffers, /)
        Read from a file descriptor fd into an iterable of buffers.
        
        The buffers should be mutable buffers accepting bytes.
        readv will transfer data into each buffer until it is full
        and then move on to the next buffer in the sequence to hold
        the rest of the data.
        
        readv returns the total number of bytes read,
        which may be less than the total capacity of all the buffers.
    
    register_at_fork(...)
        Register callables to be called when forking a new process.
        
          before
            A callable to be called in the parent before the fork() syscall.
          after_in_child
            A callable to be called in the child after fork().
          after_in_parent
            A callable to be called in the parent after fork().
        
        'before' callbacks are called in reverse order.
        'after_in_child' and 'after_in_parent' callbacks are called in order.
    
    remove(path, *, dir_fd=None)
        Remove a file (same as unlink()).
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
          If it is unavailable, using it will raise a NotImplementedError.
    
    removedirs(name)
        removedirs(name)
        
        Super-rmdir; remove a leaf directory and all empty intermediate
        ones.  Works like rmdir except that, if the leaf directory is
        successfully removed, directories corresponding to rightmost path
        segments will be pruned away until either the whole path is
        consumed or an error occurs.  Errors during this latter phase are
        ignored -- they generally mean that a directory was not empty.
    
    rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)
        Rename a file or directory.
        
        If either src_dir_fd or dst_dir_fd is not None, it should be a file
          descriptor open to a directory, and the respective path string (src or dst)
          should be relative; the path will then be relative to that directory.
        src_dir_fd and dst_dir_fd, may not be implemented on your platform.
          If they are unavailable, using them will raise a NotImplementedError.
    
    renames(old, new)
        renames(old, new)
        
        Super-rename; create directories as necessary and delete any left
        empty.  Works like rename, except creation of any intermediate
        directories needed to make the new pathname good is attempted
        first.  After the rename, directories corresponding to rightmost
        path segments of the old name will be pruned until either the
        whole path is consumed or a nonempty directory is found.
        
        Note: this function can fail with the new directory structure made
        if you lack permissions needed to unlink the leaf directory or
        file.
    
    replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)
        Rename a file or directory, overwriting the destination.
        
        If either src_dir_fd or dst_dir_fd is not None, it should be a file
          descriptor open to a directory, and the respective path string (src or dst)
          should be relative; the path will then be relative to that directory.
        src_dir_fd and dst_dir_fd, may not be implemented on your platform.
          If they are unavailable, using them will raise a NotImplementedError.
    
    rmdir(path, *, dir_fd=None)
        Remove a directory.
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
          If it is unavailable, using it will raise a NotImplementedError.
    
    scandir(path=None)
        Return an iterator of DirEntry objects for given path.
        
        path can be specified as either str, bytes, or a path-like object.  If path
        is bytes, the names of yielded DirEntry objects will also be bytes; in
        all other circumstances they will be str.
        
        If path is None, uses the path='.'.
    
    sched_get_priority_max(policy)
        Get the maximum scheduling priority for policy.
    
    sched_get_priority_min(policy)
        Get the minimum scheduling priority for policy.
    
    sched_yield()
        Voluntarily relinquish the CPU.
    
    sendfile(out_fd, in_fd, offset, count, headers=(), trailers=(), flags=0)
        Copy count bytes from file descriptor in_fd to file descriptor out_fd.
    
    set_blocking(fd, blocking, /)
        Set the blocking mode of the specified file descriptor.
        
        Set the O_NONBLOCK flag if blocking is False,
        clear the O_NONBLOCK flag otherwise.
    
    set_inheritable(fd, inheritable, /)
        Set the inheritable flag of the specified file descriptor.
    
    setegid(egid, /)
        Set the current process's effective group id.
    
    seteuid(euid, /)
        Set the current process's effective user id.
    
    setgid(gid, /)
        Set the current process's group id.
    
    setgroups(groups, /)
        Set the groups of the current process to list.
    
    setpgid(pid, pgrp, /)
        Call the system call setpgid(pid, pgrp).
    
    setpgrp()
        Make the current process the leader of its process group.
    
    setpriority(which, who, priority)
        Set program scheduling priority.
    
    setregid(rgid, egid, /)
        Set the current process's real and effective group ids.
    
    setreuid(ruid, euid, /)
        Set the current process's real and effective user ids.
    
    setsid()
        Call the system call setsid().
    
    setuid(uid, /)
        Set the current process's user id.
    
    spawnl(mode, file, *args)
        spawnl(mode, file, *args) -> integer
        
        Execute file with arguments from args in a subprocess.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.
    
    spawnle(mode, file, *args)
        spawnle(mode, file, *args, env) -> integer
        
        Execute file with arguments from args in a subprocess with the
        supplied environment.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.
    
    spawnlp(mode, file, *args)
        spawnlp(mode, file, *args) -> integer
        
        Execute file (which is looked for along $PATH) with arguments from
        args in a subprocess with the supplied environment.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.
    
    spawnlpe(mode, file, *args)
        spawnlpe(mode, file, *args, env) -> integer
        
        Execute file (which is looked for along $PATH) with arguments from
        args in a subprocess with the supplied environment.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.
    
    spawnv(mode, file, args)
        spawnv(mode, file, args) -> integer
        
        Execute file with arguments from args in a subprocess.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.
    
    spawnve(mode, file, args, env)
        spawnve(mode, file, args, env) -> integer
        
        Execute file with arguments from args in a subprocess with the
        specified environment.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.
    
    spawnvp(mode, file, args)
        spawnvp(mode, file, args) -> integer
        
        Execute file (which is looked for along $PATH) with arguments from
        args in a subprocess.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.
    
    spawnvpe(mode, file, args, env)
        spawnvpe(mode, file, args, env) -> integer
        
        Execute file (which is looked for along $PATH) with arguments from
        args in a subprocess with the supplied environment.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.
    
    stat(path, *, dir_fd=None, follow_symlinks=True)
        Perform a stat system call on the given path.
        
          path
            Path to be examined; can be string, bytes, a path-like object or
            open-file-descriptor int.
          dir_fd
            If not None, it should be a file descriptor open to a directory,
            and path should be a relative string; path will then be relative to
            that directory.
          follow_symlinks
            If False, and the last element of the path is a symbolic link,
            stat will examine the symbolic link itself instead of the file
            the link points to.
        
        dir_fd and follow_symlinks may not be implemented
          on your platform.  If they are unavailable, using them will raise a
          NotImplementedError.
        
        It's an error to use dir_fd or follow_symlinks when specifying path as
          an open file descriptor.
    
    statvfs(path)
        Perform a statvfs system call on the given path.
        
        path may always be specified as a string.
        On some platforms, path may also be specified as an open file descriptor.
          If this functionality is unavailable, using it raises an exception.
    
    strerror(code, /)
        Translate an error code to a message string.
    
    symlink(src, dst, target_is_directory=False, *, dir_fd=None)
        Create a symbolic link pointing to src named dst.
        
        target_is_directory is required on Windows if the target is to be
          interpreted as a directory.  (On Windows, symlink requires
          Windows 6.0 or greater, and raises a NotImplementedError otherwise.)
          target_is_directory is ignored on non-Windows platforms.
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
          If it is unavailable, using it will raise a NotImplementedError.
    
    sync()
        Force write of everything to disk.
    
    sysconf(name, /)
        Return an integer-valued system configuration variable.
    
    system(command)
        Execute the command in a subshell.
    
    tcgetpgrp(fd, /)
        Return the process group associated with the terminal specified by fd.
    
    tcsetpgrp(fd, pgid, /)
        Set the process group associated with the terminal specified by fd.
    
    times()
        Return a collection containing process timing information.
        
        The object returned behaves like a named tuple with these fields:
          (utime, stime, cutime, cstime, elapsed_time)
        All fields are floating point numbers.
    
    truncate(path, length)
        Truncate a file, specified by path, to a specific length.
        
        On some platforms, path may also be specified as an open file descriptor.
          If this functionality is unavailable, using it raises an exception.
    
    ttyname(fd, /)
        Return the name of the terminal device connected to 'fd'.
        
        fd
          Integer file descriptor handle.
    
    umask(mask, /)
        Set the current numeric umask and return the previous umask.
    
    uname()
        Return an object identifying the current operating system.
        
        The object behaves like a named tuple with the following fields:
          (sysname, nodename, release, version, machine)
    
    unlink(path, *, dir_fd=None)
        Remove a file (same as remove()).
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
          If it is unavailable, using it will raise a NotImplementedError.
    
    unsetenv(name, /)
        Delete an environment variable.
    
    urandom(size, /)
        Return a bytes object containing random bytes suitable for cryptographic use.
    
    utime(...)
        Set the access and modified time of path.
        
        path may always be specified as a string.
        On some platforms, path may also be specified as an open file descriptor.
          If this functionality is unavailable, using it raises an exception.
        
        If times is not None, it must be a tuple (atime, mtime);
            atime and mtime should be expressed as float seconds since the epoch.
        If ns is specified, it must be a tuple (atime_ns, mtime_ns);
            atime_ns and mtime_ns should be expressed as integer nanoseconds
            since the epoch.
        If times is None and ns is unspecified, utime uses the current time.
        Specifying tuples for both times and ns is an error.
        
        If dir_fd is not None, it should be a file descriptor open to a directory,
          and path should be relative; path will then be relative to that directory.
        If follow_symlinks is False, and the last element of the path is a symbolic
          link, utime will modify the symbolic link itself instead of the file the
          link points to.
        It is an error to use dir_fd or follow_symlinks when specifying path
          as an open file descriptor.
        dir_fd and follow_symlinks may not be available on your platform.
          If they are unavailable, using them will raise a NotImplementedError.
    
    wait()
        Wait for completion of a child process.
        
        Returns a tuple of information about the child process:
            (pid, status)
    
    wait3(options)
        Wait for completion of a child process.
        
        Returns a tuple of information about the child process:
          (pid, status, rusage)
    
    wait4(pid, options)
        Wait for completion of a specific child process.
        
        Returns a tuple of information about the child process:
          (pid, status, rusage)
    
    waitpid(pid, options, /)
        Wait for completion of a given child process.
        
        Returns a tuple of information regarding the child process:
            (pid, status)
        
        The options argument is ignored on Windows.
    
    waitstatus_to_exitcode(status)
        Convert a wait status to an exit code.
        
        On Unix:
        
        * If WIFEXITED(status) is true, return WEXITSTATUS(status).
        * If WIFSIGNALED(status) is true, return -WTERMSIG(status).
        * Otherwise, raise a ValueError.
        
        On Windows, return status shifted right by 8 bits.
        
        On Unix, if the process is being traced or if waitpid() was called with
        WUNTRACED option, the caller must first check if WIFSTOPPED(status) is true.
        This function must not be called if WIFSTOPPED(status) is true.
    
    walk(top, topdown=True, onerror=None, followlinks=False)
        Directory tree generator.
        
        For each directory in the directory tree rooted at top (including top
        itself, but excluding '.' and '..'), yields a 3-tuple
        
            dirpath, dirnames, filenames
        
        dirpath is a string, the path to the directory.  dirnames is a list of
        the names of the subdirectories in dirpath (excluding '.' and '..').
        filenames is a list of the names of the non-directory files in dirpath.
        Note that the names in the lists are just names, with no path components.
        To get a full path (which begins with top) to a file or directory in
        dirpath, do os.path.join(dirpath, name).
        
        If optional arg 'topdown' is true or not specified, the triple for a
        directory is generated before the triples for any of its subdirectories
        (directories are generated top down).  If topdown is false, the triple
        for a directory is generated after the triples for all of its
        subdirectories (directories are generated bottom up).
        
        When topdown is true, the caller can modify the dirnames list in-place
        (e.g., via del or slice assignment), and walk will only recurse into the
        subdirectories whose names remain in dirnames; this can be used to prune the
        search, or to impose a specific order of visiting.  Modifying dirnames when
        topdown is false has no effect on the behavior of os.walk(), since the
        directories in dirnames have already been generated by the time dirnames
        itself is generated. No matter the value of topdown, the list of
        subdirectories is retrieved before the tuples for the directory and its
        subdirectories are generated.
        
        By default errors from the os.scandir() call are ignored.  If
        optional arg 'onerror' is specified, it should be a function; it
        will be called with one argument, an OSError instance.  It can
        report the error to continue with the walk, or raise the exception
        to abort the walk.  Note that the filename is available as the
        filename attribute of the exception object.
        
        By default, os.walk does not follow symbolic links to subdirectories on
        systems that support them.  In order to get this functionality, set the
        optional argument 'followlinks' to true.
        
        Caution:  if you pass a relative pathname for top, don't change the
        current working directory between resumptions of walk.  walk never
        changes the current directory, and assumes that the client doesn't
        either.
        
        Example:
        
        import os
        from os.path import join, getsize
        for root, dirs, files in os.walk('python/Lib/email'):
            print(root, "consumes", end="")
            print(sum(getsize(join(root, name)) for name in files), end="")
            print("bytes in", len(files), "non-directory files")
            if 'CVS' in dirs:
                dirs.remove('CVS')  # don't visit CVS directories
    
    write(fd, data, /)
        Write a bytes object to a file descriptor.
    
    writev(fd, buffers, /)
        Iterate over buffers, and write the contents of each to a file descriptor.
        
        Returns the total number of bytes written.
        buffers must be a sequence of bytes-like objects.

DATA
    CLD_CONTINUED = 6
    CLD_DUMPED = 3
    CLD_EXITED = 1
    CLD_KILLED = 2
    CLD_STOPPED = 5
    CLD_TRAPPED = 4
    EX_CANTCREAT = 73
    EX_CONFIG = 78
    EX_DATAERR = 65
    EX_IOERR = 74
    EX_NOHOST = 68
    EX_NOINPUT = 66
    EX_NOPERM = 77
    EX_NOUSER = 67
    EX_OK = 0
    EX_OSERR = 71
    EX_OSFILE = 72
    EX_PROTOCOL = 76
    EX_SOFTWARE = 70
    EX_TEMPFAIL = 75
    EX_UNAVAILABLE = 69
    EX_USAGE = 64
    F_LOCK = 1
    F_OK = 0
    F_TEST = 3
    F_TLOCK = 2
    F_ULOCK = 0
    NGROUPS_MAX = 16
    O_ACCMODE = 3
    O_APPEND = 8
    O_ASYNC = 64
    O_CLOEXEC = 16777216
    O_CREAT = 512
    O_DIRECTORY = 1048576
    O_DSYNC = 4194304
    O_EXCL = 2048
    O_EXLOCK = 32
    O_NDELAY = 4
    O_NOCTTY = 131072
    O_NOFOLLOW = 256
    O_NONBLOCK = 4
    O_RDONLY = 0
    O_RDWR = 2
    O_SHLOCK = 16
    O_SYNC = 128
    O_TRUNC = 1024
    O_WRONLY = 1
    POSIX_SPAWN_CLOSE = 1
    POSIX_SPAWN_DUP2 = 2
    POSIX_SPAWN_OPEN = 0
    PRIO_PGRP = 1
    PRIO_PROCESS = 0
    PRIO_USER = 2
    P_ALL = 0
    P_NOWAIT = 1
    P_NOWAITO = 1
    P_PGID = 2
    P_PID = 1
    P_WAIT = 0
    RTLD_GLOBAL = 8
    RTLD_LAZY = 1
    RTLD_LOCAL = 4
    RTLD_NODELETE = 128
    RTLD_NOLOAD = 16
    RTLD_NOW = 2
    R_OK = 4
    SCHED_FIFO = 4
    SCHED_OTHER = 1
    SCHED_RR = 2
    SEEK_CUR = 1
    SEEK_DATA = 4
    SEEK_END = 2
    SEEK_HOLE = 3
    SEEK_SET = 0
    ST_NOSUID = 2
    ST_RDONLY = 1
    TMP_MAX = 308915776
    WCONTINUED = 16
    WEXITED = 4
    WNOHANG = 1
    WNOWAIT = 32
    WSTOPPED = 8
    WUNTRACED = 2
    W_OK = 2
    X_OK = 1
    __all__ = ['altsep', 'curdir', 'pardir', 'sep', 'pathsep', 'linesep', ...
    altsep = None
    confstr_names = {'CS_PATH': 1, 'CS_XBS5_ILP32_OFF32_CFLAGS': 20, 'CS_X...
    curdir = '.'
    defpath = '/bin:/usr/bin'
    devnull = '/dev/null'
    environ = environ({'TERM_PROGRAM': 'Apple_Terminal', 'TERM...niconda3/...
    environb = environ({b'TERM_PROGRAM': b'Apple_Terminal', b'T...niconda3...
    extsep = '.'
    linesep = '\n'
    name = 'posix'
    pardir = '..'
    pathconf_names = {'PC_ALLOC_SIZE_MIN': 16, 'PC_ASYNC_IO': 17, 'PC_CHOW...
    pathsep = ':'
    sep = '/'
    supports_bytes_environ = True
    sysconf_names = {'SC_2_CHAR_TERM': 20, 'SC_2_C_BIND': 18, 'SC_2_C_DEV'...

FILE
    /Users/santosg/miniconda3/lib/python3.9/os.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& parrec &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.parrec in nibabel:

NAME
    nibabel.parrec - Read images in PAR/REC format

DESCRIPTION
    This is yet another MRI image format generated by Philips scanners. It is an
    ASCII header (PAR) plus a binary blob (REC).
    
    This implementation aims to read version 4.0 through 4.2 of this format. Other
    versions could probably be supported, but we need example images to test
    against.  If you want us to support another version, and have an image we can
    add to the test suite, let us know.  You would make us very happy by submitting
    a pull request.
    
    ###############
    PAR file format
    ###############
    
    The PAR format appears to have two sections:
    
    General information
    ###################
    
    This is a set of lines each giving one key : value pair, examples::
    
        .    EPI factor        <0,1=no EPI>     :   39
        .    Dynamic scan      <0=no 1=yes> ?   :   1
        .    Diffusion         <0=no 1=yes> ?   :   0
    
    (from ``nibabel/tests/data/phantom_EPI_asc_CLEAR_2_1.PAR``)
    
    Image information
    #################
    
    There is a ``#`` prefixed list of fields under the heading "IMAGE INFORMATION
    DEFINITION".  From the same file, here is the start of this list::
    
        # === IMAGE INFORMATION DEFINITION =============================================
        #  The rest of this file contains ONE line per image, this line contains the following information:
        #
        #  slice number                             (integer)
        #  echo number                              (integer)
        #  dynamic scan number                      (integer)
    
    There follows a space separated table with values for these fields, each row
    containing all the named values. Here are the first few lines from the example
    file above::
    
        # === IMAGE INFORMATION ==========================================================
        #  sl ec  dyn ph ty    idx pix scan% rec size                (re)scale              window        angulation              offcentre        thick   gap   info      spacing     echo     dtime   ttime    diff  avg  flip    freq   RR-int  turbo delay b grad cont anis         diffusion       L.ty
    
        1   1    1  1 0 2     0  16    62   64   64     0.00000   1.29035 4.28404e-003  1070  1860 -13.26  -0.00  -0.00    2.51   -0.81   -8.69  6.000  2.000 0 1 0 2  3.750  3.750  30.00    0.00     0.00    0.00   0   90.00     0    0    0    39   0.0  1   1    8    0   0.000    0.000    0.000  1
        2   1    1  1 0 2     1  16    62   64   64     0.00000   1.29035 4.28404e-003  1122  1951 -13.26  -0.00  -0.00    2.51    6.98  -10.53  6.000  2.000 0 1 0 2  3.750  3.750  30.00    0.00     0.00    0.00   0   90.00     0    0    0    39   0.0  1   1    8    0   0.000    0.000    0.000  1
        3   1    1  1 0 2     2  16    62   64   64     0.00000   1.29035 4.28404e-003  1137  1977 -13.26  -0.00  -0.00    2.51   14.77  -12.36  6.000  2.000 0 1 0 2  3.750  3.750  30.00    0.00     0.00    0.00   0   90.00     0    0    0    39   0.0  1   1    8    0   0.000    0.000    0.000  1
    
    Orientation
    ###########
    
    PAR files refer to orientations "ap", "fh" and "rl".
    
    Nibabel's required affine output axes are RAS (left to Right, posterior to
    Anterior, inferior to Superior). The correspondence of the PAR file's axes to
    RAS axes is:
    
    * ap = anterior -> posterior = negative A in RAS = P
    * fh = foot -> head = S in RAS = S
    * rl = right -> left = negative R in RAS = L
    
    We therefore call the PAR file's axis system "PSL" (Posterior, Superior, Left).
    
    The orientation of the PAR file axes corresponds to DICOM's LPS coordinate
    system (right to Left, anterior to Posterior, inferior to Superior), but in a
    different order.
    
    Data type
    #########
    
    It seems that everyone agrees that Philips stores REC data in little-endian
    format - see https://github.com/nipy/nibabel/issues/274
    
    Philips XML header files, and some previous experience, suggest that the REC
    data is always stored as 8 or 16 bit unsigned integers - see
    https://github.com/nipy/nibabel/issues/275
    
    Data Sorting
    ############
    
    PAR/REC files have a large number of potential image dimensions.  To handle
    sorting of volumes in PAR/REC files based on these fields and not the order
    slices first appear in the PAR file, the ``strict_sort`` flag of
    ``nibabel.load`` (or ``parrec.load``) should be set to ``True``.  The fields
    that are taken into account during sorting are:
    
        - slice number
        - echo number
        - cardiac phase number
        - gradient orientation number
        - diffusion b value number
        - label type  (ASL tag vs. control)
        - dynamic scan number
        - image_type_mr  (Re, Im, Mag, Phase)
    
    Slices are sorted into the third dimension and the
    order of preference for sorting along the 4th dimension corresponds to the
    order in the list above.  If the image data has more than 4 dimensions these
    will all be concatenated along the 4th dimension.  For example, for a scan with
    two echos and two dynamics, the 4th dimension will have both echos of dynamic 1
    prior to the two echos for dynamic 2.
    
    The``get_volume_labels`` method of the header returns a dictionary containing
    the PAR field labels for this 4th dimension.
    
    The volume sorting described above can be enabled in the parrec2nii command
    utility via the option "--strict-sort".  The dimension info can be exported
    to a CSV file by adding the option "--volume-info".

CLASSES
    builtins.Exception(builtins.BaseException)
        PARRECError
    builtins.object
        PARRECArrayProxy
    nibabel.spatialimages.SpatialHeader(nibabel.filebasedimages.FileBasedHeader, nibabel.spatialimages.SpatialProtocol)
        PARRECHeader
    nibabel.spatialimages.SpatialImage(nibabel.dataobj_images.DataobjImage)
        PARRECImage
    
    class PARRECArrayProxy(builtins.object)
     |  PARRECArrayProxy(file_like, header, *, mmap=True, scaling='dv')
     |  
     |  Methods defined here:
     |  
     |  __array__(self, dtype=None)
     |      Read data from file and apply scaling, casting to ``dtype``
     |      
     |      If ``dtype`` is unspecified, the dtype of the returned array is the
     |      narrowest dtype that can represent the data without overflow.
     |      Generally, it is the wider of the dtypes of the slopes or intercepts.
     |      
     |      Parameters
     |      ----------
     |      dtype : numpy dtype specifier, optional
     |          A numpy dtype specifier specifying the type of the returned array.
     |      
     |      Returns
     |      -------
     |      array
     |          Scaled image data with type `dtype`.
     |  
     |  __getitem__(self, slicer)
     |  
     |  __init__(self, file_like, header, *, mmap=True, scaling='dv')
     |      Initialize PARREC array proxy
     |      
     |      Parameters
     |      ----------
     |      file_like : file-like object
     |          Filename or object implementing ``read, seek, tell``
     |      header : PARRECHeader instance
     |          Implementing ``get_data_shape, get_data_dtype``,
     |          ``get_sorted_slice_indices``, ``get_data_scaling``,
     |          ``get_rec_shape``.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading data.
     |          If False, do not try numpy ``memmap`` for data array.  If one of
     |          {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A `mmap` value of
     |          True gives the same behavior as ``mmap='c'``.  If `file_like`
     |          cannot be memory-mapped, ignore `mmap` value and read array from
     |          file.
     |      scaling : {'fp', 'dv'}, optional, keyword only
     |          Type of scaling to use - see header ``get_data_scaling`` method.
     |  
     |  get_unscaled(self)
     |      Read data from file
     |      
     |      This is an optional part of the proxy API
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  dtype
     |  
     |  is_proxy
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class PARRECError(builtins.Exception)
     |  Exception for PAR/REC format related problems.
     |  
     |  To be raised whenever PAR/REC is not happy, or we are not happy with
     |  PAR/REC.
     |  
     |  Method resolution order:
     |      PARRECError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class PARRECHeader(nibabel.spatialimages.SpatialHeader)
     |  PARRECHeader(info, image_defs, permit_truncated=False, strict_sort=False)
     |  
     |  PAR/REC header
     |  
     |  Method resolution order:
     |      PARRECHeader
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, info, image_defs, permit_truncated=False, strict_sort=False)
     |      Parameters
     |      ----------
     |      info : dict
     |          "General information" from the PAR file (as returned by
     |          `parse_PAR_header()`).
     |      image_defs : array
     |          Structured array with image definitions from the PAR file (as
     |          returned by `parse_PAR_header()`).
     |      permit_truncated : bool, optional
     |          If True, a warning is emitted instead of an error when a truncated
     |          recording is detected.
     |      strict_sort : bool, optional, keyword-only
     |          If True, a larger number of header fields are used while sorting
     |          the REC data array.  This may produce a different sort order than
     |          `strict_sort=False`, where volumes are sorted by the order in which
     |          the slices appear in the .PAR file.
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  as_analyze_map(self)
     |      Convert PAR parameters to NIFTI1 format
     |  
     |  copy(self)
     |      Copy object to independent representation
     |      
     |      The copy should not be affected by any changes to the original
     |      object.
     |  
     |  get_affine(self, origin='scanner')
     |      Compute affine transformation into scanner space.
     |      
     |      The method only considers global rotation and offset settings in the
     |      header and ignores potentially deviating information in the image
     |      definitions.
     |      
     |      Parameters
     |      ----------
     |      origin : {'scanner', 'fov'}
     |          Transformation origin. By default the transformation is computed
     |          relative to the scanner's iso center. If 'fov' is requested the
     |          transformation origin will be the center of the field of view
     |          instead.
     |      
     |      Returns
     |      -------
     |      aff : (4, 4) array
     |          4x4 array, with output axis order corresponding to RAS or (x,y,z)
     |          or (lr, pa, fh).
     |      
     |      Notes
     |      -----
     |      Transformations appear to be specified in (ap, fh, rl) axes.  The
     |      orientation of data is recorded in the "slice orientation" field of the
     |      PAR header "General Information".
     |      
     |      We need to:
     |      
     |      * translate to coordinates in terms of the center of the FOV
     |      * apply voxel size scaling
     |      * reorder / flip the data to Philips' PSL axes
     |      * apply the rotations
     |      * apply any isocenter scaling offset if `origin` == "scanner"
     |      * reorder and flip to RAS axes
     |  
     |  get_bvals_bvecs(self)
     |      Get bvals and bvecs from data
     |      
     |      Returns
     |      -------
     |      b_vals : None or array
     |          Array of b values, shape (n_directions,), or None if not a
     |          diffusion acquisition.
     |      b_vectors : None or array
     |          Array of b vectors, shape (n_directions, 3), or None if not a
     |          diffusion acquisition.
     |  
     |  get_data_offset(self)
     |      PAR header always has 0 data offset (into REC file)
     |  
     |  get_data_scaling(self, method='dv')
     |      Returns scaling slope and intercept.
     |      
     |      Parameters
     |      ----------
     |      method : {'fp', 'dv'}
     |        Scaling settings to be reported -- see notes below.
     |      
     |      Returns
     |      -------
     |      slope : array
     |          scaling slope
     |      intercept : array
     |          scaling intercept
     |      
     |      Notes
     |      -----
     |      The PAR header contains two different scaling settings: 'dv' (value on
     |      console) and 'fp' (floating point value). Here is how they are defined:
     |      
     |      DV = PV * RS + RI
     |      FP = DV / (RS * SS)
     |      
     |      where:
     |      
     |      PV: value in REC
     |      RS: rescale slope
     |      RI: rescale intercept
     |      SS: scale slope
     |  
     |  get_def(self, name)
     |      Return a single image definition field (or None if missing)
     |  
     |  get_echo_train_length(self)
     |      Echo train length of the recording
     |  
     |  get_q_vectors(self)
     |      Get Q vectors from the data
     |      
     |      Returns
     |      -------
     |      q_vectors : None or array
     |          Array of q vectors (bvals * bvecs), or None if not a diffusion
     |          acquisition.
     |  
     |  get_rec_shape(self)
     |  
     |  get_slice_orientation(self)
     |      Returns the slice orientation label.
     |      
     |      Returns
     |      -------
     |      orientation : {'transverse', 'sagittal', 'coronal'}
     |  
     |  get_sorted_slice_indices(self)
     |      Return indices to sort (and maybe discard) slices in REC file.
     |      
     |      If the recording is truncated, the returned indices take care of
     |      discarding any slice indices from incomplete volumes.
     |      
     |      If `self.strict_sort` is True, a more complicated sorting based on
     |      multiple fields from the .PAR file is used.  This may produce a
     |      different sort order than `strict_sort=False`, where volumes are sorted
     |      by the order in which the slices appear in the .PAR file.
     |      
     |      Returns
     |      -------
     |      slice_indices : list
     |          List for indexing into the last (third) dimension of the REC data
     |          array, and (equivalently) the only dimension of
     |          ``self.image_defs``.
     |  
     |  get_volume_labels(self)
     |      Dynamic labels corresponding to the final data dimension(s).
     |      
     |      This is useful for custom data sorting.  A subset of the info in
     |      ``self.image_defs`` is returned in an order that matches the final
     |      data dimension(s).  Only labels that have more than one unique value
     |      across the dataset will be returned.
     |      
     |      Returns
     |      -------
     |      sort_info : dict
     |          Each key corresponds to volume labels for a dynamically varying
     |          sequence dimension.  The ordering of the labels matches the volume
     |          ordering determined via ``self.get_sorted_slice_indices``.
     |  
     |  get_water_fat_shift(self)
     |      Water fat shift, in pixels
     |  
     |  set_data_offset(self, offset)
     |      PAR header always has 0 data offset (into REC file)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_fileobj(fileobj, permit_truncated=False, strict_sort=False) from typing._ProtocolMeta
     |  
     |  from_header(header=None) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |  
     |  data_from_fileobj(self, fileobj: 'io.IOBase') -> 'np.ndarray'
     |      Read binary image data from `fileobj`
     |  
     |  data_to_fileobj(self, data: 'npt.ArrayLike', fileobj: 'io.IOBase', rescale: 'bool' = True)
     |      Write array data `data` as binary to `fileobj`
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |          data to write
     |      fileobj : file-like object
     |          file-like object implementing 'write'
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. For this minimal header, `rescale` has no effect
     |  
     |  get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_best_affine = get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  get_data_shape(self) -> 'tuple[int, ...]'
     |  
     |  get_zooms(self) -> 'tuple[float, ...]'
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  set_data_shape(self, shape: 'Sequence[int]') -> 'None'
     |  
     |  set_zooms(self, zooms: 'Sequence[float]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  __annotations__ = {'_dtype': 'np.dtype', '_shape': 'tuple[int, ...]', ...
     |  
     |  __hash__ = None
     |  
     |  data_layout = 'F'
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |  
     |  write_to(self, fileobj: 'io.IOBase') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class PARRECImage(nibabel.spatialimages.SpatialImage)
     |  PARRECImage(dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |  
     |  PAR/REC image
     |  
     |  Method resolution order:
     |      PARRECImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Class methods defined here:
     |  
     |  from_file_map(file_map, *, mmap=True, permit_truncated=False, scaling='dv', strict_sort=False) from builtins.type
     |      Create PARREC image from file map `file_map`
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          dict with keys ``image, header`` and values being fileholder
     |          objects for the respective REC and PAR files.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      permit_truncated : {False, True}, optional, keyword-only
     |          If False, raise an error for an image where the header shows signs
     |          that fewer slices / volumes were recorded than were expected.
     |      scaling : {'dv', 'fp'}, optional, keyword-only
     |          Scaling method to apply to data (see
     |          :meth:`PARRECHeader.get_data_scaling`).
     |      strict_sort : bool, optional, keyword-only
     |          If True, a larger number of header fields are used while sorting
     |          the REC data array.  This may produce a different sort order than
     |          `strict_sort=False`, where volumes are sorted by the order in which
     |          the slices appear in the .PAR file.
     |  
     |  from_filename(filename, *, mmap=True, permit_truncated=False, scaling='dv', strict_sort=False) from builtins.type
     |      Create PARREC image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of "PAR" or "REC" file
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      permit_truncated : {False, True}, optional, keyword-only
     |          If False, raise an error for an image where the header shows signs
     |          that fewer slices / volumes were recorded than were expected.
     |      scaling : {'dv', 'fp'}, optional, keyword-only
     |          Scaling method to apply to data (see
     |          :meth:`PARRECHeader.get_data_scaling`).
     |      strict_sort : bool, optional, keyword-only
     |          If True, a larger number of header fields are used while sorting
     |          the REC data array.  This may produce a different sort order than
     |          `strict_sort=False`, where volumes are sorted by the order in which
     |          the slices appear in the .PAR file.
     |  
     |  load = from_filename(filename, *, mmap=True, permit_truncated=False, scaling='dv', strict_sort=False) from builtins.type
     |      Create PARREC image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of "PAR" or "REC" file
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      permit_truncated : {False, True}, optional, keyword-only
     |          If False, raise an error for an image where the header shows signs
     |          that fewer slices / volumes were recorded than were expected.
     |      scaling : {'dv', 'fp'}, optional, keyword-only
     |          Scaling method to apply to data (see
     |          :meth:`PARRECHeader.get_data_scaling`).
     |      strict_sort : bool, optional, keyword-only
     |          If True, a larger number of header fields are used while sorting
     |          the REC data array.  This may produce a different sort order than
     |          `strict_sort=False`, where volumes are sorted by the order in which
     |          the slices appear in the .PAR file.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ImageArrayProxy = <class 'nibabel.parrec.PARRECArrayProxy'>
     |  
     |  __annotations__ = {'header': <class 'nibabel.parrec.PARRECHeader'>}
     |  
     |  files_types = (('image', '.rec'), ('header', '.par'))
     |  
     |  header_class = <class 'nibabel.parrec.PARRECHeader'>
     |      PAR/REC header
     |  
     |  
     |  makeable = False
     |  
     |  rw = False
     |  
     |  valid_exts = ('.rec', '.par')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __init__(self, dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    exts2pars(exts_source)
        Parse, return any PAR headers from NIfTI extensions in `exts_source`
        
        Parameters
        ----------
        exts_source : sequence or `Nifti1Image`, `Nifti1Header` instance
            A sequence of extensions, or header containing NIfTI extensions, or an
            image containing a header with NIfTI extensions.
        
        Returns
        -------
        par_headers : list
            A list of PARRECHeader objects, usually empty or with one element, each
            element contains a PARRECHeader read from the contained extensions.
    
    load = from_filename(filename, *, mmap=True, permit_truncated=False, scaling='dv', strict_sort=False) method of builtins.type instance
        Create PARREC image from filename `filename`
        
        Parameters
        ----------
        filename : str
            Filename of "PAR" or "REC" file
        mmap : {True, False, 'c', 'r'}, optional, keyword only
            `mmap` controls the use of numpy memory mapping for reading image
            array data.  If False, do not try numpy ``memmap`` for data array.
            If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
            `mmap` value of True gives the same behavior as ``mmap='c'``.  If
            image data file cannot be memory-mapped, ignore `mmap` value and
            read array from file.
        permit_truncated : {False, True}, optional, keyword-only
            If False, raise an error for an image where the header shows signs
            that fewer slices / volumes were recorded than were expected.
        scaling : {'dv', 'fp'}, optional, keyword-only
            Scaling method to apply to data (see
            :meth:`PARRECHeader.get_data_scaling`).
        strict_sort : bool, optional, keyword-only
            If True, a larger number of header fields are used while sorting
            the REC data array.  This may produce a different sort order than
            `strict_sort=False`, where volumes are sorted by the order in which
            the slices appear in the .PAR file.
    
    one_line(long_str)
        Make maybe mutli-line `long_str` into one long line
    
    parse_PAR_header(fobj)
        Parse a PAR header and aggregate all information into useful containers.
        
        Parameters
        ----------
        fobj : file-object
            The PAR header file object.
        
        Returns
        -------
        general_info : dict
            Contains all "General Information" from the header file
        image_info : ndarray
            Structured array with fields giving all "Image information" in the
            header
    
    vol_is_full(slice_nos, slice_max, slice_min=1)
        Vector with True for slices in complete volume, False otherwise
        
        Parameters
        ----------
        slice_nos : sequence
            Sequence of slice numbers, e.g. ``[1, 2, 3, 4, 1, 2, 3, 4]``.
        slice_max : int
            Highest slice number for a full slice set.  Slice set will be
            ``range(slice_min, slice_max+1)``.
        slice_min : int, optional
            Lowest slice number for full slice set.  Default is 1.
        
        Returns
        -------
        is_full : array
            Bool vector with True for slices in full volumes, False for slices in
            partial volumes.  A full volume is a volume with all slices in the
            ``slice set`` as defined above.
        
        Raises
        ------
        ValueError
            if any value in `slice_nos` is outside slice set indices.
    
    vol_numbers(slice_nos)
        Calculate volume numbers inferred from slice numbers `slice_nos`
        
        The volume number for each slice is the number of times this slice number
        has occurred previously in the `slice_nos` sequence
        
        Parameters
        ----------
        slice_nos : sequence
            Sequence of slice numbers, e.g. ``[1, 2, 3, 4, 1, 2, 3, 4]``.
        
        Returns
        -------
        vol_nos : list
            A list, the same length of `slice_nos` giving the volume number for
            each corresponding slice number.

DATA
    ACQ_TO_PSL = {'coronal': array([[ 0,  0,  1,  0],
           [ 0, -1,  0, ...
    DEG2RAD = 0.017453292519943295
    GEN_RE = re.compile('.\\s+(.*?)\\s*:\\s*(.*)')
    PSL_TO_RAS = array([[ 0,  0, -1,  0],
           [-1,  0,  0,  0],
           ...
    image_def_dtds = {'V4': [('slice number', <class 'int'>), ('echo numbe...
    image_def_dtype = dtype([('slice number', '<i8'), ('echo number', ...d...
    slice_orientation_codes = <nibabel.volumeutils.Recoder object>
    supported_versions = ['V4', 'V4.1', 'V4.2']
    unit_codes = <nibabel.volumeutils.Recoder object>

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/parrec.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& pkg_info &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.pkg_info in nibabel:

NAME
    nibabel.pkg_info

FUNCTIONS
    cmp_pkg_version(version_str: 'str', pkg_version_str: 'str' = '5.2.1') -> 'int'
        Compare ``version_str`` to current package version
        
        This comparator follows `PEP-440`_ conventions for determining version
        ordering.
        
        To be valid, a version must have a numerical major version. It may be
        optionally followed by a dot and a numerical minor version, which may,
        in turn, optionally be followed by a dot and a numerical micro version,
        and / or by an "extra" string.
        The extra string may further contain a "+". Any value to the left of a "+"
        labels the version as pre-release, while values to the right indicate a
        post-release relative to the values to the left. That is,
        ``1.2.0+1`` is post-release for ``1.2.0``, while ``1.2.0rc1+1`` is
        post-release for ``1.2.0rc1`` and pre-release for ``1.2.0``.
        
        Parameters
        ----------
        version_str : str
            Version string to compare to current package version
        pkg_version_str : str, optional
            Version of our package.  Optional, set from ``__version__`` by default.
        
        Returns
        -------
        version_cmp : int
            1 if `version_str` is a later version than `pkg_version_str`, 0 if
            same, -1 if earlier.
        
        Examples
        --------
        >>> cmp_pkg_version('1.2.1', '1.2.0')
        1
        >>> cmp_pkg_version('1.2.0dev', '1.2.0')
        -1
        >>> cmp_pkg_version('1.2.0dev', '1.2.0rc1')
        -1
        >>> cmp_pkg_version('1.2.0rc1', '1.2.0')
        -1
        >>> cmp_pkg_version('1.2.0rc1+1', '1.2.0rc1')
        1
        >>> cmp_pkg_version('1.2.0rc1+1', '1.2.0')
        -1
        >>> cmp_pkg_version('1.2.0.post1', '1.2.0')
        1
        
        .. _`PEP-440`: https://www.python.org/dev/peps/pep-0440/
    
    get_pkg_info(pkg_path: 'str') -> 'dict[str, str]'
        Return dict describing the context of this package
        
        Parameters
        ----------
        pkg_path : str
           path containing __init__.py for package
        
        Returns
        -------
        context : dict
           with named parameters of interest
    
    pkg_commit_hash(pkg_path: 'str | None' = None) -> 'tuple[str, str]'
        Get short form of commit hash
        
        In this file is a variable called COMMIT_HASH. This contains a substitution
        pattern that may have been filled by the execution of ``git archive``.
        
        We get the commit hash from (in order of preference):
        
        * A substituted value in ``archive_subst_hash``
        * A truncated commit hash value that is part of the local portion of the
          version
        * git's output, if we are in a git repository
        
        If all these fail, we return a not-found placeholder tuple
        
        Parameters
        ----------
        pkg_path : str
           directory containing package
        
        Returns
        -------
        hash_from : str
           Where we got the hash from - description
        hash_str : str
           short form of hash

DATA
    COMMIT_HASH = '1df3b610e6'
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...

VERSION
    5.2.1

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/pkg_info.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& quaternions &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.quaternions in nibabel:

NAME
    nibabel.quaternions - Functions to operate on, or return, quaternions

DESCRIPTION
    The module also includes functions for the closely related angle, axis
    pair as a specification for rotation.
    
    Quaternions here consist of 4 values ``w, x, y, z``, where ``w`` is the
    real (scalar) part, and ``x, y, z`` are the complex (vector) part.
    
    Note - rotation matrices here apply to column vectors, that is,
    they are applied on the left of the vector.  For example:
    
    >>> import numpy as np
    >>> from nibabel.quaternions import quat2mat
    >>> q = [0, 1, 0, 0] # 180 degree rotation around axis 0
    >>> M = quat2mat(q) # from this module
    >>> vec = np.array([1, 2, 3]).reshape((3,1)) # column vector
    >>> tvec = np.dot(M, vec)

FUNCTIONS
    angle_axis2mat(theta, vector, is_normalized=False)
        Rotation matrix of angle `theta` around `vector`
        
        Parameters
        ----------
        theta : scalar
           angle of rotation
        vector : 3 element sequence
           vector specifying axis for rotation.
        is_normalized : bool, optional
           True if vector is already normalized (has norm of 1).  Default
           False
        
        Returns
        -------
        mat : array shape (3,3)
           rotation matrix for specified rotation
        
        Notes
        -----
        From: https://en.wikipedia.org/wiki/Rotation_matrix#Axis_and_angle
    
    angle_axis2quat(theta, vector, is_normalized=False)
        Quaternion for rotation of angle `theta` around `vector`
        
        Parameters
        ----------
        theta : scalar
           angle of rotation
        vector : 3 element sequence
           vector specifying axis for rotation.
        is_normalized : bool, optional
           True if vector is already normalized (has norm of 1).  Default
           False
        
        Returns
        -------
        quat : 4 element sequence of symbols
           quaternion giving specified rotation
        
        Examples
        --------
        >>> q = angle_axis2quat(np.pi, [1, 0, 0])
        >>> np.allclose(q, [0, 1, 0,  0])
        True
        
        Notes
        -----
        Formula from http://mathworld.wolfram.com/EulerParameters.html
    
    conjugate(q)
        Conjugate of quaternion
        
        Parameters
        ----------
        q : 4 element sequence
           w, i, j, k of quaternion
        
        Returns
        -------
        conjq : array shape (4,)
           w, i, j, k of conjugate of `q`
    
    eye()
        Return identity quaternion
    
    fillpositive(xyz, w2_thresh=None)
        Compute unit quaternion from last 3 values
        
        Parameters
        ----------
        xyz : iterable
           iterable containing 3 values, corresponding to quaternion x, y, z
        w2_thresh : None or float, optional
           threshold to determine if w squared is non-zero.
           If None (default) then w2_thresh set equal to
           3 * ``np.finfo(xyz.dtype).eps``, if possible, otherwise
           3 * ``np.finfo(np.float64).eps``
        
        Returns
        -------
        wxyz : array shape (4,)
             Full 4 values of quaternion
        
        Notes
        -----
        If w, x, y, z are the values in the full quaternion, assumes w is
        positive.
        
        Gives error if w*w is estimated to be negative
        
        w = 0 corresponds to a 180 degree rotation
        
        The unit quaternion specifies that np.dot(wxyz, wxyz) == 1.
        
        If w is positive (assumed here), w is given by:
        
        w = np.sqrt(1.0-(x*x+y*y+z*z))
        
        w2 = 1.0-(x*x+y*y+z*z) can be near zero, which will lead to
        numerical instability in sqrt.  Here we use the system maximum
        float type to reduce numerical instability
        
        Examples
        --------
        >>> import numpy as np
        >>> wxyz = fillpositive([0,0,0])
        >>> np.all(wxyz == [1, 0, 0, 0])
        True
        >>> wxyz = fillpositive([1,0,0]) # Corner case; w is 0
        >>> np.all(wxyz == [0, 1, 0, 0])
        True
        >>> np.dot(wxyz, wxyz)
        1.0
    
    inverse(q)
        Return multiplicative inverse of quaternion `q`
        
        Parameters
        ----------
        q : 4 element sequence
           w, i, j, k of quaternion
        
        Returns
        -------
        invq : array shape (4,)
           w, i, j, k of quaternion inverse
    
    isunit(q)
        Return True is this is very nearly a unit quaternion
    
    mat2quat(M)
        Calculate quaternion corresponding to given rotation matrix
        
        Parameters
        ----------
        M : array-like
          3x3 rotation matrix
        
        Returns
        -------
        q : (4,) array
          closest quaternion to input matrix, having positive q[0]
        
        Notes
        -----
        Method claimed to be robust to numerical errors in M
        
        Constructs quaternion by calculating maximum eigenvector for matrix
        K (constructed from input `M`).  Although this is not tested, a
        maximum eigenvalue of 1 corresponds to a valid rotation.
        
        A quaternion q*-1 corresponds to the same rotation as q; thus the
        sign of the reconstructed quaternion is arbitrary, and we return
        quaternions with positive w (q[0]).
        
        References
        ----------
        * https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion
        * Bar-Itzhack, Itzhack Y. (2000), "New method for extracting the
          quaternion from a rotation matrix", AIAA Journal of Guidance,
          Control and Dynamics 23(6):1085-1087 (Engineering Note), ISSN
          0731-5090
        
        Examples
        --------
        >>> import numpy as np
        >>> q = mat2quat(np.eye(3)) # Identity rotation
        >>> np.allclose(q, [1, 0, 0, 0])
        True
        >>> q = mat2quat(np.diag([1, -1, -1]))
        >>> np.allclose(q, [0, 1, 0, 0]) # 180 degree rotn around axis 0
        True
    
    mult(q1, q2)
        Multiply two quaternions
        
        Parameters
        ----------
        q1 : 4 element sequence
        q2 : 4 element sequence
        
        Returns
        -------
        q12 : shape (4,) array
        
        Notes
        -----
        See : https://en.wikipedia.org/wiki/Quaternions#Hamilton_product
    
    nearly_equivalent(q1, q2, rtol=1e-05, atol=1e-08)
        Returns True if `q1` and `q2` give near equivalent transforms
        
        `q1` may be nearly numerically equal to `q2`, or nearly equal to `q2` * -1
        (because a quaternion multiplied by -1 gives the same transform).
        
        Parameters
        ----------
        q1 : 4 element sequence
           w, x, y, z of first quaternion
        q2 : 4 element sequence
           w, x, y, z of second quaternion
        
        Returns
        -------
        equiv : bool
           True if `q1` and `q2` are nearly equivalent, False otherwise
        
        Examples
        --------
        >>> q1 = [1, 0, 0, 0]
        >>> nearly_equivalent(q1, [0, 1, 0, 0])
        False
        >>> nearly_equivalent(q1, [1, 0, 0, 0])
        True
        >>> nearly_equivalent(q1, [-1, 0, 0, 0])
        True
    
    norm(q)
        Return norm of quaternion
        
        Parameters
        ----------
        q : 4 element sequence
           w, i, j, k of quaternion
        
        Returns
        -------
        n : scalar
           quaternion norm
    
    quat2angle_axis(quat, identity_thresh=None)
        Convert quaternion to rotation of angle around axis
        
        Parameters
        ----------
        quat : 4 element sequence
           w, x, y, z forming quaternion
        identity_thresh : None or scalar, optional
           threshold below which the norm of the vector part of the
           quaternion (x, y, z) is deemed to be 0, leading to the identity
           rotation.  None (the default) leads to a threshold estimated
           based on the precision of the input.
        
        Returns
        -------
        theta : scalar
           angle of rotation
        vector : array shape (3,)
           axis around which rotation occurs
        
        Examples
        --------
        >>> theta, vec = quat2angle_axis([0, 1, 0, 0])
        >>> np.allclose(theta, np.pi)
        True
        >>> vec
        array([1., 0., 0.])
        
        If this is an identity rotation, we return a zero angle and an
        arbitrary vector
        
        >>> quat2angle_axis([1, 0, 0, 0])
        (0.0, array([1., 0., 0.]))
        
        Notes
        -----
        A quaternion for which x, y, z are all equal to 0, is an identity
        rotation.  In this case we return a 0 angle and an  arbitrary
        vector, here [1, 0, 0]
    
    quat2mat(q)
        Calculate rotation matrix corresponding to quaternion
        
        Parameters
        ----------
        q : 4 element array-like
        
        Returns
        -------
        M : (3,3) array
          Rotation matrix corresponding to input quaternion *q*
        
        Notes
        -----
        Rotation matrix applies to column vectors, and is applied to the
        left of coordinate vectors.  The algorithm here allows non-unit
        quaternions.
        
        References
        ----------
        Algorithm from
        https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion
        
        Examples
        --------
        >>> import numpy as np
        >>> M = quat2mat([1, 0, 0, 0]) # Identity quaternion
        >>> np.allclose(M, np.eye(3))
        True
        >>> M = quat2mat([0, 1, 0, 0]) # 180 degree rotn around axis 0
        >>> np.allclose(M, np.diag([1, -1, -1]))
        True
    
    rotate_vector(v, q)
        Apply transformation in quaternion `q` to vector `v`
        
        Parameters
        ----------
        v : 3 element sequence
           3 dimensional vector
        q : 4 element sequence
           w, i, j, k of quaternion
        
        Returns
        -------
        vdash : array shape (3,)
           `v` rotated by quaternion `q`
        
        Notes
        -----
        See:
        https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Describing_rotations_with_quaternions

DATA
    FLOAT_EPS = 2.220446049250313e-16
    sctypes = {'complex': [<class 'numpy.complex64'>, <class 'numpy.comple...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/quaternions.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& save &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function save in module nibabel.loadsave:

save(img: 'FileBasedImage', filename: 'FileSpec', **kwargs) -> 'None'
    Save an image to file adapting format to `filename`
    
    Parameters
    ----------
    img : ``SpatialImage``
       image to save
    filename : str or os.PathLike
       filename (often implying filenames) to which to save `img`.
    \*\*kwargs : keyword arguments
        Keyword arguments to format-specific save
    
    Returns
    -------
    None

None
&&&&&&&&&&&&&&&&&&&&&&&&& spatialimages &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.spatialimages in nibabel:

NAME
    nibabel.spatialimages - A simple spatial image class

DESCRIPTION
    The image class maintains the association between a 3D (or greater)
    array, and an affine transform that maps voxel coordinates to some world space.
    It also has a ``header`` - some standard set of meta-data that is specific to
    the image format, and ``extra`` - a dictionary container for any other
    metadata.
    
    It has attributes:
    
       * extra
    
    methods:
    
       * .get_fdata()
       * .to_filename(fname) - writes data to filename(s) derived from
         ``fname``, where the derivation may differ between formats.
       * to_file_map() - save image to files with which the image is already
         associated.
    
    properties:
    
       * shape
       * affine
       * header
       * dataobj
    
    classmethods:
    
       * from_filename(fname) - make instance by loading from filename
       * from_file_map(fmap) - make instance from file map
       * instance_to_filename(img, fname) - save ``img`` instance to
         filename ``fname``.
    
    You cannot slice an image, and trying to slice an image generates an
    informative TypeError.
    
    There are several ways of writing data.
    =======================================
    
    There is the usual way, which is the default::
    
        img.to_filename(fname)
    
    and that is, to take the data encapsulated by the image and cast it to
    the datatype the header expects, setting any available header scaling
    into the header to help the data match.
    
    You can load the data into an image from file with::
    
       img.from_filename(fname)
    
    The image stores its associated files in its ``file_map`` attribute.  In order
    to just save an image, for which you know there is an associated filename, or
    other storage, you can do::
    
       img.to_file_map()
    
    You can get the data out again with::
    
        img.get_fdata()
    
    Less commonly, for some image types that support it, you might want to
    fetch out the unscaled array via the object containing the data::
    
        unscaled_data = img.dataoobj.get_unscaled()
    
    Analyze-type images (including nifti) support this, but others may not
    (MINC, for example).
    
    Sometimes you might to avoid any loss of precision by making the
    data type the same as the input::
    
        hdr = img.header
        hdr.set_data_dtype(data.dtype)
        img.to_filename(fname)
    
    Files interface
    ===============
    
    The image has an attribute ``file_map``.  This is a mapping, that has keys
    corresponding to the file types that an image needs for storage.  For
    example, the Analyze data format needs an ``image`` and a ``header``
    file type for storage:
    
       >>> import numpy as np
       >>> import nibabel as nib
       >>> data = np.arange(24, dtype='f4').reshape((2,3,4))
       >>> img = nib.AnalyzeImage(data, np.eye(4))
       >>> sorted(img.file_map)
       ['header', 'image']
    
    The values of ``file_map`` are not in fact files but objects with
    attributes ``filename``, ``fileobj`` and ``pos``.
    
    The reason for this interface, is that the contents of files has to
    contain enough information so that an existing image instance can save
    itself back to the files pointed to in ``file_map``.  When a file holder
    holds active file-like objects, then these may be affected by the
    initial file read; in this case, the contains file-like objects need to
    carry the position at which a write (with ``to_file_map``) should place the
    data.  The ``file_map`` contents should therefore be such, that this will
    work:
    
        >>> # write an image to files
        >>> from io import BytesIO
        >>> import nibabel as nib
        >>> file_map = nib.AnalyzeImage.make_file_map()
        >>> file_map['image'].fileobj = BytesIO()
        >>> file_map['header'].fileobj = BytesIO()
        >>> img = nib.AnalyzeImage(data, np.eye(4))
        >>> img.file_map = file_map
        >>> img.to_file_map()
        >>> # read it back again from the written files
        >>> img2 = nib.AnalyzeImage.from_file_map(file_map)
        >>> np.all(img2.get_fdata(dtype=np.float32) == data)
        True
        >>> # write, read it again
        >>> img2.to_file_map()
        >>> img3 = nib.AnalyzeImage.from_file_map(file_map)
        >>> np.all(img3.get_fdata(dtype=np.float32) == data)
        True

CLASSES
    builtins.Exception(builtins.BaseException)
        HeaderDataError
        HeaderTypeError
        ImageDataError
    nibabel.dataobj_images.DataobjImage(nibabel.filebasedimages.FileBasedImage)
        SpatialImage
    nibabel.filebasedimages.FileBasedHeader(builtins.object)
        SpatialHeader(nibabel.filebasedimages.FileBasedHeader, SpatialProtocol)
    typing.Generic(builtins.object)
        SpatialFirstSlicer
    typing.Protocol(typing.Generic)
        HasDtype
        SpatialProtocol
            SpatialHeader(nibabel.filebasedimages.FileBasedHeader, SpatialProtocol)
    
    class HasDtype(typing.Protocol)
     |  HasDtype(*args, **kwargs)
     |  
     |  Method resolution order:
     |      HasDtype
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class HeaderDataError(builtins.Exception)
     |  Class to indicate error in getting or setting header data
     |  
     |  Method resolution order:
     |      HeaderDataError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class HeaderTypeError(builtins.Exception)
     |  Class to indicate error in parameters into header functions
     |  
     |  Method resolution order:
     |      HeaderTypeError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class ImageDataError(builtins.Exception)
     |  Method resolution order:
     |      ImageDataError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class SpatialFirstSlicer(typing.Generic)
     |  SpatialFirstSlicer(img: 'SpatialImgT')
     |  
     |  Slicing interface that returns a new image with an updated affine
     |  
     |  Checks that an image's first three axes are spatial
     |  
     |  Method resolution order:
     |      SpatialFirstSlicer
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, slicer: 'object') -> 'SpatialImgT'
     |  
     |  __init__(self, img: 'SpatialImgT')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  check_slicing(self, slicer: 'object', return_spatial: 'bool' = False) -> 'tuple[slice | int | None, ...]'
     |      Canonicalize slicers and check for scalar indices in spatial dims
     |      
     |      Parameters
     |      ----------
     |      slicer : object
     |          something that can be used to slice an array as in
     |          ``arr[sliceobj]``
     |      return_spatial : bool
     |          return only slices along spatial dimensions (x, y, z)
     |      
     |      Returns
     |      -------
     |      slicer : object
     |          Validated slicer object that will slice image's `dataobj`
     |          without collapsing spatial dimensions
     |  
     |  slice_affine(self, slicer: 'object') -> 'np.ndarray'
     |      Retrieve affine for current image, if sliced by a given index
     |      
     |      Applies scaling if down-sampling is applied, and adjusts the intercept
     |      to account for any cropping.
     |      
     |      Parameters
     |      ----------
     |      slicer : object
     |          something that can be used to slice an array as in
     |          ``arr[sliceobj]``
     |      
     |      Returns
     |      -------
     |      affine : (4,4) ndarray
     |          Affine with updated scale and intercept
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'img': 'SpatialImgT'}
     |  
     |  __orig_bases__ = (typing.Generic[~SpatialImgT],)
     |  
     |  __parameters__ = (~SpatialImgT,)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from builtins.type
     |  
     |  __init_subclass__(*args, **kwargs) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class SpatialHeader(nibabel.filebasedimages.FileBasedHeader, SpatialProtocol)
     |  SpatialHeader(data_dtype: 'npt.DTypeLike' = <class 'numpy.float32'>, shape: 'Sequence[int]' = (0,), zooms: 'Sequence[float] | None' = None)
     |  
     |  Template class to implement header protocol
     |  
     |  Method resolution order:
     |      SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |  
     |  __init__(self, data_dtype: 'npt.DTypeLike' = <class 'numpy.float32'>, shape: 'Sequence[int]' = (0,), zooms: 'Sequence[float] | None' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  copy(self: 'SpatialHdrT') -> 'SpatialHdrT'
     |      Copy object to independent representation
     |      
     |      The copy should not be affected by any changes to the original
     |      object.
     |  
     |  data_from_fileobj(self, fileobj: 'io.IOBase') -> 'np.ndarray'
     |      Read binary image data from `fileobj`
     |  
     |  data_to_fileobj(self, data: 'npt.ArrayLike', fileobj: 'io.IOBase', rescale: 'bool' = True)
     |      Write array data `data` as binary to `fileobj`
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |          data to write
     |      fileobj : file-like object
     |          file-like object implementing 'write'
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. For this minimal header, `rescale` has no effect
     |  
     |  get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_best_affine = get_base_affine(self) -> 'np.ndarray'
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  get_data_shape(self) -> 'tuple[int, ...]'
     |  
     |  get_zooms(self) -> 'tuple[float, ...]'
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  set_data_shape(self, shape: 'Sequence[int]') -> 'None'
     |  
     |  set_zooms(self, zooms: 'Sequence[float]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_header(header: 'SpatialProtocol | FileBasedHeader | ty.Mapping | None' = None) -> 'SpatialHdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __annotations__ = {'_dtype': 'np.dtype', '_shape': 'tuple[int, ...]', ...
     |  
     |  __hash__ = None
     |  
     |  __parameters__ = ()
     |  
     |  data_layout = 'F'
     |  
     |  default_x_flip = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |  
     |  write_to(self, fileobj: 'io.IOBase') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  from_fileobj(fileobj: 'io.IOBase') -> 'HdrT' from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class SpatialImage(nibabel.dataobj_images.DataobjImage)
     |  SpatialImage(dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |  
     |  Template class for volumetric (3D/4D) images
     |  
     |  Method resolution order:
     |      SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __init__(self, dataobj: 'ArrayLike', affine: 'np.ndarray | None', header: 'FileBasedHeader | ty.Mapping | None' = None, extra: 'ty.Mapping | None' = None, file_map: 'FileMap | None' = None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  set_data_dtype(self, dtype: 'npt.DTypeLike') -> 'None'
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  __annotations__ = {'ImageSlicer': 'type[SpatialFirstSlicer]', '_header...
     |  
     |  header_class = <class 'nibabel.spatialimages.SpatialHeader'>
     |      Template class to implement header protocol
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_file_map(file_map: 'FileMap', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_file_map(self, file_map: 'FileMap | None' = None, **kwargs) -> 'None'
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  files_types = (('image', None),)
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  valid_exts = ()
    
    class SpatialProtocol(typing.Protocol)
     |  SpatialProtocol(*args, **kwargs)
     |  
     |  Method resolution order:
     |      SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs)
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_data_dtype(self) -> 'np.dtype'
     |  
     |  get_data_shape(self) -> 'ty.Tuple[int, ...]'
     |  
     |  get_zooms(self) -> 'ty.Tuple[float, ...]'
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta

FUNCTIONS
    supported_np_types(obj: 'HasDtype') -> 'set[type[np.generic]]'
        Numpy data types that instance `obj` supports
        
        Parameters
        ----------
        obj : object
            Object implementing `get_data_dtype` and `set_data_dtype`.  The object
            should raise ``HeaderDataError`` for setting unsupported dtypes. The
            object will likely be a header or a :class:`SpatialImage`
        
        Returns
        -------
        np_types : set
            set of numpy types that `obj` supports

DATA
    FileMap = typing.Mapping[str, nibabel.fileholders.FileHolder]
    Literal = typing.Literal
        Special typing form to define literal types (a.k.a. value types).
        
        This form can be used to indicate to type checkers that the corresponding
        variable or function parameter has a value equivalent to the provided
        literal (or one of several literals):
        
          def validate_simple(data: Any) -> Literal[True]:  # always returns True
              ...
        
          MODE = Literal['r', 'rb', 'w', 'wb']
          def open_helper(file: str, mode: MODE) -> str:
              ...
        
          open_helper('/some/path', 'r')  # Passes type check
          open_helper('/other/path', 'typo')  # Error in type checker
        
        Literal[...] cannot be subclassed. At runtime, an arbitrary value
        is allowed as type argument to Literal[...], but type checkers may
        impose restrictions.
    
    SpatialHdrT = ~SpatialHdrT
    SpatialImgT = ~SpatialImgT
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    sctypes_aliases = {<class 'numpy.float16'>, <class 'numpy.int8'>, <cla...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/spatialimages.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& spm2 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.spm2analyze in nibabel:

NAME
    nibabel.spm2analyze - Read / write access to SPM2 version of analyze image format

CLASSES
    nibabel.spm99analyze.Spm99AnalyzeHeader(nibabel.spm99analyze.SpmAnalyzeHeader)
        Spm2AnalyzeHeader
    nibabel.spm99analyze.Spm99AnalyzeImage(nibabel.analyze.AnalyzeImage)
        Spm2AnalyzeImage
    
    class Spm2AnalyzeHeader(nibabel.spm99analyze.Spm99AnalyzeHeader)
     |  Spm2AnalyzeHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Class for SPM2 variant of basic Analyze header
     |  
     |  SPM2 variant adds the following to basic Analyze format:
     |  
     |  * voxel origin;
     |  * slope scaling of data;
     |  * reading - but not writing - intercept of data.
     |  
     |  Method resolution order:
     |      Spm2AnalyzeHeader
     |      nibabel.spm99analyze.Spm99AnalyzeHeader
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_slope_inter(self)
     |      Get data scaling (slope) and intercept from header data
     |      
     |      Uses the algorithm from SPM2 spm_vol_ana.m by John Ashburner
     |      
     |      Parameters
     |      ----------
     |      self : header
     |         Mapping with fields:
     |         * scl_slope - slope
     |         * scl_inter - possible intercept (SPM2 use - shared by nifti)
     |         * glmax - the (recorded) maximum value in the data (unscaled)
     |         * glmin - recorded minimum unscaled value
     |         * cal_max - the calibrated (scaled) maximum value in the dataset
     |         * cal_min - ditto minimum value
     |      
     |      Returns
     |      -------
     |      scl_slope : None or float
     |          slope.  None if there is no valid scaling from these fields
     |      scl_inter : None or float
     |          intercept.  Also None if there is no valid slope, intercept
     |      
     |      Examples
     |      --------
     |      >>> fields = {'scl_slope': 1, 'scl_inter': 0, 'glmax': 0, 'glmin': 0,
     |      ...           'cal_max': 0, 'cal_min': 0}
     |      >>> hdr = Spm2AnalyzeHeader()
     |      >>> for key, value in fields.items():
     |      ...     hdr[key] = value
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_inter'] = 0.5
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.5)
     |      >>> hdr['scl_inter'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      
     |      If 'scl_slope' is 0, nan or inf, cannot use 'scl_slope'.
     |      Without valid information in the gl / cal fields, we cannot get
     |      scaling, and return None
     |      
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      
     |      Valid information in the gl AND cal fields are needed
     |      
     |      >>> hdr['cal_max'] = 0.8
     |      >>> hdr['cal_min'] = 0.2
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['glmax'] = 110
     |      >>> hdr['glmin'] = 10
     |      >>> np.allclose(hdr.get_slope_inter(), [0.6/100, 0.2-0.6/100*10])
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spm99analyze.Spm99AnalyzeHeader:
     |  
     |  get_best_affine = get_origin_affine(self)
     |  
     |  get_origin_affine(self)
     |      Get affine from header, using SPM origin field if sensible
     |      
     |      The default translations are got from the ``origin``
     |      field, if set, or from the center of the image otherwise.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Spm99AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_origin_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> hdr['origin'][:3] = [3,4,5]
     |      >>> hdr.get_origin_affine() # using origin
     |      array([[-3.,  0.,  0.,  6.],
     |             [ 0.,  2.,  0., -6.],
     |             [ 0.,  0.,  1., -4.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> hdr['origin'] = 0 # unset origin
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.get_origin_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  set_origin_from_affine(self, affine)
     |      Set SPM origin to header from affine matrix.
     |      
     |      The ``origin`` field was read but not written by SPM99 and 2.  It was
     |      used for storing a central voxel coordinate, that could be used in
     |      aligning the image to some standard position - a proxy for a full
     |      translation vector that was usually stored in a separate matlab .mat
     |      file.
     |      
     |      Nifti uses the space occupied by the SPM ``origin`` field for important
     |      other information (the transform codes), so writing the origin will
     |      make the header a confusing Nifti file.  If you work with both Analyze
     |      and Nifti, you should probably avoid doing this.
     |      
     |      Parameters
     |      ----------
     |      affine : array-like, shape (4,4)
     |         Affine matrix to set
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Spm99AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3,2,1))
     |      >>> hdr.get_origin_affine()
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> affine = np.diag([3,2,1,1])
     |      >>> affine[:3,3] = [-6, -6, -4]
     |      >>> hdr.set_origin_from_affine(affine)
     |      >>> np.all(hdr['origin'][:3] == [3,4,5])
     |      True
     |      >>> hdr.get_origin_affine()
     |      array([[-3.,  0.,  0.,  6.],
     |             [ 0.,  2.,  0., -6.],
     |             [ 0.,  0.,  1., -4.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      The SPM Analyze header can't save an intercept value, and we raise an
     |      error unless `inter` is None, NaN or 0
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope` of NaN.  NaN is a signal to the image
     |         writing routines to rescale on save.  0, Inf, -Inf are invalid and
     |         cause a HeaderDataError
     |      inter : None or float, optional
     |         intercept. Must be None, NaN or 0, because SPM99 cannot store
     |         intercepts.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
     |  
     |  has_data_intercept = False
     |  
     |  has_data_slope = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize header from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into header.  By default, None, in
     |          which case we insert the default empty header block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of header in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> hdr1 = AnalyzeHeader() # an empty header
     |      >>> hdr1.endianness == native_code
     |      True
     |      >>> hdr1.get_data_shape()
     |      (0,)
     |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
     |      >>> hdr1.get_data_shape()
     |      (1, 2, 3)
     |      
     |      We can set the binary block directly via this initialization.
     |      Here we get it from the header we have just made
     |      
     |      >>> binblock2 = hdr1.binaryblock
     |      >>> hdr2 = AnalyzeHeader(binblock2)
     |      >>> hdr2.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Empty headers are native endian by default
     |      
     |      >>> hdr2.endianness == native_code
     |      True
     |      
     |      You can pass valid opposite endian headers with the
     |      ``endianness`` parameter. Even empty headers can have
     |      endianness
     |      
     |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
     |      >>> hdr3.endianness == swapped_code
     |      True
     |      
     |      If you do not pass an endianness, and you pass some data, we
     |      will try to guess from the passed data.
     |      
     |      >>> binblock3 = hdr3.binaryblock
     |      >>> hdr4 = AnalyzeHeader(binblock3)
     |      >>> hdr4.endianness == swapped_code
     |      True
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Spm2AnalyzeImage(nibabel.spm99analyze.Spm99AnalyzeImage)
     |  Spm2AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for SPM2 variant of basic Analyze image
     |  
     |  Method resolution order:
     |      Spm2AnalyzeImage
     |      nibabel.spm99analyze.Spm99AnalyzeImage
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'header': <class 'nibabel.spm2analyze.Spm2AnalyzeHe...
     |  
     |  header_class = <class 'nibabel.spm2analyze.Spm2AnalyzeHeader'>
     |      Class for SPM2 variant of basic Analyze header
     |      
     |      SPM2 variant adds the following to basic Analyze format:
     |      
     |      * voxel origin;
     |      * slope scaling of data;
     |      * reading - but not writing - intercept of data.
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Extends Analyze ``to_file_map`` method by writing ``mat`` file
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : Spm99AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'), ('mat', '.mat'))
     |  
     |  has_affine = True
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_data_dtype(self)
     |  
     |  set_data_dtype(self, dtype)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...omin...
    image_dimension_dtd = [('dim', 'i2', (8,)), ('vox_units', 'S4'), ('cal...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/spm2analyze.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& spm2analyze &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.spm2analyze in nibabel:

NAME
    nibabel.spm2analyze - Read / write access to SPM2 version of analyze image format

CLASSES
    nibabel.spm99analyze.Spm99AnalyzeHeader(nibabel.spm99analyze.SpmAnalyzeHeader)
        Spm2AnalyzeHeader
    nibabel.spm99analyze.Spm99AnalyzeImage(nibabel.analyze.AnalyzeImage)
        Spm2AnalyzeImage
    
    class Spm2AnalyzeHeader(nibabel.spm99analyze.Spm99AnalyzeHeader)
     |  Spm2AnalyzeHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Class for SPM2 variant of basic Analyze header
     |  
     |  SPM2 variant adds the following to basic Analyze format:
     |  
     |  * voxel origin;
     |  * slope scaling of data;
     |  * reading - but not writing - intercept of data.
     |  
     |  Method resolution order:
     |      Spm2AnalyzeHeader
     |      nibabel.spm99analyze.Spm99AnalyzeHeader
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_slope_inter(self)
     |      Get data scaling (slope) and intercept from header data
     |      
     |      Uses the algorithm from SPM2 spm_vol_ana.m by John Ashburner
     |      
     |      Parameters
     |      ----------
     |      self : header
     |         Mapping with fields:
     |         * scl_slope - slope
     |         * scl_inter - possible intercept (SPM2 use - shared by nifti)
     |         * glmax - the (recorded) maximum value in the data (unscaled)
     |         * glmin - recorded minimum unscaled value
     |         * cal_max - the calibrated (scaled) maximum value in the dataset
     |         * cal_min - ditto minimum value
     |      
     |      Returns
     |      -------
     |      scl_slope : None or float
     |          slope.  None if there is no valid scaling from these fields
     |      scl_inter : None or float
     |          intercept.  Also None if there is no valid slope, intercept
     |      
     |      Examples
     |      --------
     |      >>> fields = {'scl_slope': 1, 'scl_inter': 0, 'glmax': 0, 'glmin': 0,
     |      ...           'cal_max': 0, 'cal_min': 0}
     |      >>> hdr = Spm2AnalyzeHeader()
     |      >>> for key, value in fields.items():
     |      ...     hdr[key] = value
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_inter'] = 0.5
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.5)
     |      >>> hdr['scl_inter'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      
     |      If 'scl_slope' is 0, nan or inf, cannot use 'scl_slope'.
     |      Without valid information in the gl / cal fields, we cannot get
     |      scaling, and return None
     |      
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      
     |      Valid information in the gl AND cal fields are needed
     |      
     |      >>> hdr['cal_max'] = 0.8
     |      >>> hdr['cal_min'] = 0.2
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['glmax'] = 110
     |      >>> hdr['glmin'] = 10
     |      >>> np.allclose(hdr.get_slope_inter(), [0.6/100, 0.2-0.6/100*10])
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spm99analyze.Spm99AnalyzeHeader:
     |  
     |  get_best_affine = get_origin_affine(self)
     |  
     |  get_origin_affine(self)
     |      Get affine from header, using SPM origin field if sensible
     |      
     |      The default translations are got from the ``origin``
     |      field, if set, or from the center of the image otherwise.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Spm99AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_origin_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> hdr['origin'][:3] = [3,4,5]
     |      >>> hdr.get_origin_affine() # using origin
     |      array([[-3.,  0.,  0.,  6.],
     |             [ 0.,  2.,  0., -6.],
     |             [ 0.,  0.,  1., -4.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> hdr['origin'] = 0 # unset origin
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.get_origin_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  set_origin_from_affine(self, affine)
     |      Set SPM origin to header from affine matrix.
     |      
     |      The ``origin`` field was read but not written by SPM99 and 2.  It was
     |      used for storing a central voxel coordinate, that could be used in
     |      aligning the image to some standard position - a proxy for a full
     |      translation vector that was usually stored in a separate matlab .mat
     |      file.
     |      
     |      Nifti uses the space occupied by the SPM ``origin`` field for important
     |      other information (the transform codes), so writing the origin will
     |      make the header a confusing Nifti file.  If you work with both Analyze
     |      and Nifti, you should probably avoid doing this.
     |      
     |      Parameters
     |      ----------
     |      affine : array-like, shape (4,4)
     |         Affine matrix to set
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Spm99AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3,2,1))
     |      >>> hdr.get_origin_affine()
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> affine = np.diag([3,2,1,1])
     |      >>> affine[:3,3] = [-6, -6, -4]
     |      >>> hdr.set_origin_from_affine(affine)
     |      >>> np.all(hdr['origin'][:3] == [3,4,5])
     |      True
     |      >>> hdr.get_origin_affine()
     |      array([[-3.,  0.,  0.,  6.],
     |             [ 0.,  2.,  0., -6.],
     |             [ 0.,  0.,  1., -4.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      The SPM Analyze header can't save an intercept value, and we raise an
     |      error unless `inter` is None, NaN or 0
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope` of NaN.  NaN is a signal to the image
     |         writing routines to rescale on save.  0, Inf, -Inf are invalid and
     |         cause a HeaderDataError
     |      inter : None or float, optional
     |         intercept. Must be None, NaN or 0, because SPM99 cannot store
     |         intercepts.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spm99analyze.SpmAnalyzeHeader:
     |  
     |  has_data_intercept = False
     |  
     |  has_data_slope = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize header from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into header.  By default, None, in
     |          which case we insert the default empty header block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of header in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> hdr1 = AnalyzeHeader() # an empty header
     |      >>> hdr1.endianness == native_code
     |      True
     |      >>> hdr1.get_data_shape()
     |      (0,)
     |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
     |      >>> hdr1.get_data_shape()
     |      (1, 2, 3)
     |      
     |      We can set the binary block directly via this initialization.
     |      Here we get it from the header we have just made
     |      
     |      >>> binblock2 = hdr1.binaryblock
     |      >>> hdr2 = AnalyzeHeader(binblock2)
     |      >>> hdr2.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Empty headers are native endian by default
     |      
     |      >>> hdr2.endianness == native_code
     |      True
     |      
     |      You can pass valid opposite endian headers with the
     |      ``endianness`` parameter. Even empty headers can have
     |      endianness
     |      
     |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
     |      >>> hdr3.endianness == swapped_code
     |      True
     |      
     |      If you do not pass an endianness, and you pass some data, we
     |      will try to guess from the passed data.
     |      
     |      >>> binblock3 = hdr3.binaryblock
     |      >>> hdr4 = AnalyzeHeader(binblock3)
     |      >>> hdr4.endianness == swapped_code
     |      True
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Spm2AnalyzeImage(nibabel.spm99analyze.Spm99AnalyzeImage)
     |  Spm2AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for SPM2 variant of basic Analyze image
     |  
     |  Method resolution order:
     |      Spm2AnalyzeImage
     |      nibabel.spm99analyze.Spm99AnalyzeImage
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'header': <class 'nibabel.spm2analyze.Spm2AnalyzeHe...
     |  
     |  header_class = <class 'nibabel.spm2analyze.Spm2AnalyzeHeader'>
     |      Class for SPM2 variant of basic Analyze header
     |      
     |      SPM2 variant adds the following to basic Analyze format:
     |      
     |      * voxel origin;
     |      * slope scaling of data;
     |      * reading - but not writing - intercept of data.
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Extends Analyze ``to_file_map`` method by writing ``mat`` file
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : Spm99AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spm99analyze.Spm99AnalyzeImage:
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'), ('mat', '.mat'))
     |  
     |  has_affine = True
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_data_dtype(self)
     |  
     |  set_data_dtype(self, dtype)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...omin...
    image_dimension_dtd = [('dim', 'i2', (8,)), ('vox_units', 'S4'), ('cal...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/spm2analyze.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& spm99 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.spm99analyze in nibabel:

NAME
    nibabel.spm99analyze - Read / write access to SPM99 version of analyze image format

CLASSES
    nibabel.analyze.AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
        SpmAnalyzeHeader
            Spm99AnalyzeHeader
    nibabel.analyze.AnalyzeImage(nibabel.spatialimages.SpatialImage)
        Spm99AnalyzeImage
    
    class Spm99AnalyzeHeader(SpmAnalyzeHeader)
     |  Spm99AnalyzeHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Class for SPM99 variant of basic Analyze header
     |  
     |  SPM99 variant adds the following to basic Analyze format:
     |  
     |  * voxel origin;
     |  * slope scaling of data.
     |  
     |  Method resolution order:
     |      Spm99AnalyzeHeader
     |      SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_best_affine = get_origin_affine(self)
     |  
     |  get_origin_affine(self)
     |      Get affine from header, using SPM origin field if sensible
     |      
     |      The default translations are got from the ``origin``
     |      field, if set, or from the center of the image otherwise.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Spm99AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_origin_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> hdr['origin'][:3] = [3,4,5]
     |      >>> hdr.get_origin_affine() # using origin
     |      array([[-3.,  0.,  0.,  6.],
     |             [ 0.,  2.,  0., -6.],
     |             [ 0.,  0.,  1., -4.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> hdr['origin'] = 0 # unset origin
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.get_origin_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  set_origin_from_affine(self, affine)
     |      Set SPM origin to header from affine matrix.
     |      
     |      The ``origin`` field was read but not written by SPM99 and 2.  It was
     |      used for storing a central voxel coordinate, that could be used in
     |      aligning the image to some standard position - a proxy for a full
     |      translation vector that was usually stored in a separate matlab .mat
     |      file.
     |      
     |      Nifti uses the space occupied by the SPM ``origin`` field for important
     |      other information (the transform codes), so writing the origin will
     |      make the header a confusing Nifti file.  If you work with both Analyze
     |      and Nifti, you should probably avoid doing this.
     |      
     |      Parameters
     |      ----------
     |      affine : array-like, shape (4,4)
     |         Affine matrix to set
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Spm99AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3,2,1))
     |      >>> hdr.get_origin_affine()
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> affine = np.diag([3,2,1,1])
     |      >>> affine[:3,3] = [-6, -6, -4]
     |      >>> hdr.set_origin_from_affine(affine)
     |      >>> np.all(hdr['origin'][:3] == [3,4,5])
     |      True
     |      >>> hdr.get_origin_affine()
     |      array([[-3.,  0.,  0.,  6.],
     |             [ 0.,  2.,  0., -6.],
     |             [ 0.,  0.,  1., -4.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from SpmAnalyzeHeader:
     |  
     |  get_slope_inter(self)
     |      Get scalefactor and intercept
     |      
     |      If scalefactor is 0.0 return None to indicate no scalefactor.
     |      Intercept is always None because SPM99 analyze cannot store intercepts.
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      The SPM Analyze header can't save an intercept value, and we raise an
     |      error unless `inter` is None, NaN or 0
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope` of NaN.  NaN is a signal to the image
     |         writing routines to rescale on save.  0, Inf, -Inf are invalid and
     |         cause a HeaderDataError
     |      inter : None or float, optional
     |         intercept. Must be None, NaN or 0, because SPM99 cannot store
     |         intercepts.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from SpmAnalyzeHeader:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from SpmAnalyzeHeader:
     |  
     |  has_data_intercept = False
     |  
     |  has_data_slope = True
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize header from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into header.  By default, None, in
     |          which case we insert the default empty header block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of header in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> hdr1 = AnalyzeHeader() # an empty header
     |      >>> hdr1.endianness == native_code
     |      True
     |      >>> hdr1.get_data_shape()
     |      (0,)
     |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
     |      >>> hdr1.get_data_shape()
     |      (1, 2, 3)
     |      
     |      We can set the binary block directly via this initialization.
     |      Here we get it from the header we have just made
     |      
     |      >>> binblock2 = hdr1.binaryblock
     |      >>> hdr2 = AnalyzeHeader(binblock2)
     |      >>> hdr2.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Empty headers are native endian by default
     |      
     |      >>> hdr2.endianness == native_code
     |      True
     |      
     |      You can pass valid opposite endian headers with the
     |      ``endianness`` parameter. Even empty headers can have
     |      endianness
     |      
     |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
     |      >>> hdr3.endianness == swapped_code
     |      True
     |      
     |      If you do not pass an endianness, and you pass some data, we
     |      will try to guess from the passed data.
     |      
     |      >>> binblock3 = hdr3.binaryblock
     |      >>> hdr4 = AnalyzeHeader(binblock3)
     |      >>> hdr4.endianness == swapped_code
     |      True
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Spm99AnalyzeImage(nibabel.analyze.AnalyzeImage)
     |  Spm99AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for SPM99 variant of basic Analyze image
     |  
     |  Method resolution order:
     |      Spm99AnalyzeImage
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Extends Analyze ``to_file_map`` method by writing ``mat`` file
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : Spm99AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'header': <class 'nibabel.spm99analyze.Spm99Analyze...
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'), ('mat', '.mat'))
     |  
     |  has_affine = True
     |  
     |  header_class = <class 'nibabel.spm99analyze.Spm99AnalyzeHeader'>
     |      Class for SPM99 variant of basic Analyze header
     |      
     |      SPM99 variant adds the following to basic Analyze format:
     |      
     |      * voxel origin;
     |      * slope scaling of data.
     |  
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_data_dtype(self)
     |  
     |  set_data_dtype(self, dtype)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class SpmAnalyzeHeader(nibabel.analyze.AnalyzeHeader)
     |  SpmAnalyzeHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Basic scaling Spm Analyze header
     |  
     |  Method resolution order:
     |      SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_slope_inter(self)
     |      Get scalefactor and intercept
     |      
     |      If scalefactor is 0.0 return None to indicate no scalefactor.
     |      Intercept is always None because SPM99 analyze cannot store intercepts.
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      The SPM Analyze header can't save an intercept value, and we raise an
     |      error unless `inter` is None, NaN or 0
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope` of NaN.  NaN is a signal to the image
     |         writing routines to rescale on save.  0, Inf, -Inf are invalid and
     |         cause a HeaderDataError
     |      inter : None or float, optional
     |         intercept. Must be None, NaN or 0, because SPM99 cannot store
     |         intercepts.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  has_data_intercept = False
     |  
     |  has_data_slope = True
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize header from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into header.  By default, None, in
     |          which case we insert the default empty header block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of header in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> hdr1 = AnalyzeHeader() # an empty header
     |      >>> hdr1.endianness == native_code
     |      True
     |      >>> hdr1.get_data_shape()
     |      (0,)
     |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
     |      >>> hdr1.get_data_shape()
     |      (1, 2, 3)
     |      
     |      We can set the binary block directly via this initialization.
     |      Here we get it from the header we have just made
     |      
     |      >>> binblock2 = hdr1.binaryblock
     |      >>> hdr2 = AnalyzeHeader(binblock2)
     |      >>> hdr2.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Empty headers are native endian by default
     |      
     |      >>> hdr2.endianness == native_code
     |      True
     |      
     |      You can pass valid opposite endian headers with the
     |      ``endianness`` parameter. Even empty headers can have
     |      endianness
     |      
     |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
     |      >>> hdr3.endianness == swapped_code
     |      True
     |      
     |      If you do not pass an endianness, and you pass some data, we
     |      will try to guess from the passed data.
     |      
     |      >>> binblock3 = hdr3.binaryblock
     |      >>> hdr4 = AnalyzeHeader(binblock3)
     |      >>> hdr4.endianness == swapped_code
     |      True
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_best_affine = get_base_affine(self)
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta

DATA
    data_history_dtd = [('descrip', 'S80'), ('aux_file', 'S24'), ('orient'...
    have_scipy = True
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...omin...
    header_key_dtd = [('sizeof_hdr', 'i4'), ('data_type', 'S10'), ('db_nam...
    image_dimension_dtd = [('dim', 'i2', (8,)), ('vox_units', 'S4'), ('cal...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/spm99analyze.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& spm99analyze &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.spm99analyze in nibabel:

NAME
    nibabel.spm99analyze - Read / write access to SPM99 version of analyze image format

CLASSES
    nibabel.analyze.AnalyzeHeader(nibabel.wrapstruct.LabeledWrapStruct, nibabel.spatialimages.SpatialHeader)
        SpmAnalyzeHeader
            Spm99AnalyzeHeader
    nibabel.analyze.AnalyzeImage(nibabel.spatialimages.SpatialImage)
        Spm99AnalyzeImage
    
    class Spm99AnalyzeHeader(SpmAnalyzeHeader)
     |  Spm99AnalyzeHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Class for SPM99 variant of basic Analyze header
     |  
     |  SPM99 variant adds the following to basic Analyze format:
     |  
     |  * voxel origin;
     |  * slope scaling of data.
     |  
     |  Method resolution order:
     |      Spm99AnalyzeHeader
     |      SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_best_affine = get_origin_affine(self)
     |  
     |  get_origin_affine(self)
     |      Get affine from header, using SPM origin field if sensible
     |      
     |      The default translations are got from the ``origin``
     |      field, if set, or from the center of the image otherwise.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Spm99AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_origin_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> hdr['origin'][:3] = [3,4,5]
     |      >>> hdr.get_origin_affine() # using origin
     |      array([[-3.,  0.,  0.,  6.],
     |             [ 0.,  2.,  0., -6.],
     |             [ 0.,  0.,  1., -4.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> hdr['origin'] = 0 # unset origin
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.get_origin_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  set_origin_from_affine(self, affine)
     |      Set SPM origin to header from affine matrix.
     |      
     |      The ``origin`` field was read but not written by SPM99 and 2.  It was
     |      used for storing a central voxel coordinate, that could be used in
     |      aligning the image to some standard position - a proxy for a full
     |      translation vector that was usually stored in a separate matlab .mat
     |      file.
     |      
     |      Nifti uses the space occupied by the SPM ``origin`` field for important
     |      other information (the transform codes), so writing the origin will
     |      make the header a confusing Nifti file.  If you work with both Analyze
     |      and Nifti, you should probably avoid doing this.
     |      
     |      Parameters
     |      ----------
     |      affine : array-like, shape (4,4)
     |         Affine matrix to set
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Spm99AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3,2,1))
     |      >>> hdr.get_origin_affine()
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> affine = np.diag([3,2,1,1])
     |      >>> affine[:3,3] = [-6, -6, -4]
     |      >>> hdr.set_origin_from_affine(affine)
     |      >>> np.all(hdr['origin'][:3] == [3,4,5])
     |      True
     |      >>> hdr.get_origin_affine()
     |      array([[-3.,  0.,  0.,  6.],
     |             [ 0.,  2.,  0., -6.],
     |             [ 0.,  0.,  1., -4.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from SpmAnalyzeHeader:
     |  
     |  get_slope_inter(self)
     |      Get scalefactor and intercept
     |      
     |      If scalefactor is 0.0 return None to indicate no scalefactor.
     |      Intercept is always None because SPM99 analyze cannot store intercepts.
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      The SPM Analyze header can't save an intercept value, and we raise an
     |      error unless `inter` is None, NaN or 0
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope` of NaN.  NaN is a signal to the image
     |         writing routines to rescale on save.  0, Inf, -Inf are invalid and
     |         cause a HeaderDataError
     |      inter : None or float, optional
     |         intercept. Must be None, NaN or 0, because SPM99 cannot store
     |         intercepts.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from SpmAnalyzeHeader:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from SpmAnalyzeHeader:
     |  
     |  has_data_intercept = False
     |  
     |  has_data_slope = True
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize header from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into header.  By default, None, in
     |          which case we insert the default empty header block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of header in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> hdr1 = AnalyzeHeader() # an empty header
     |      >>> hdr1.endianness == native_code
     |      True
     |      >>> hdr1.get_data_shape()
     |      (0,)
     |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
     |      >>> hdr1.get_data_shape()
     |      (1, 2, 3)
     |      
     |      We can set the binary block directly via this initialization.
     |      Here we get it from the header we have just made
     |      
     |      >>> binblock2 = hdr1.binaryblock
     |      >>> hdr2 = AnalyzeHeader(binblock2)
     |      >>> hdr2.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Empty headers are native endian by default
     |      
     |      >>> hdr2.endianness == native_code
     |      True
     |      
     |      You can pass valid opposite endian headers with the
     |      ``endianness`` parameter. Even empty headers can have
     |      endianness
     |      
     |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
     |      >>> hdr3.endianness == swapped_code
     |      True
     |      
     |      If you do not pass an endianness, and you pass some data, we
     |      will try to guess from the passed data.
     |      
     |      >>> binblock3 = hdr3.binaryblock
     |      >>> hdr4 = AnalyzeHeader(binblock3)
     |      >>> hdr4.endianness == swapped_code
     |      True
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta
    
    class Spm99AnalyzeImage(nibabel.analyze.AnalyzeImage)
     |  Spm99AnalyzeImage(dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |  
     |  Class for SPM99 variant of basic Analyze image
     |  
     |  Method resolution order:
     |      Spm99AnalyzeImage
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.dataobj_images.DataobjImage
     |      nibabel.filebasedimages.FileBasedImage
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  to_file_map(self, file_map=None, dtype=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Extends Analyze ``to_file_map`` method by writing ``mat`` file
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_file_map(file_map, *, mmap=True, keep_file_open=None) from builtins.type
     |      Class method to create image from mapping in ``file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          If ``file_map`` refers to an open file handle, this setting has no
     |          effect. The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : Spm99AnalyzeImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'header': <class 'nibabel.spm99analyze.Spm99Analyze...
     |  
     |  files_types = (('image', '.img'), ('header', '.hdr'), ('mat', '.mat'))
     |  
     |  has_affine = True
     |  
     |  header_class = <class 'nibabel.spm99analyze.Spm99AnalyzeHeader'>
     |      Class for SPM99 variant of basic Analyze header
     |      
     |      SPM99 variant adds the following to basic Analyze format:
     |      
     |      * voxel origin;
     |      * slope scaling of data.
     |  
     |  
     |  makeable = True
     |  
     |  rw = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  __init__(self, dataobj, affine, header=None, extra=None, file_map=None, dtype=None)
     |      Initialize image
     |      
     |      The image is a combination of (array-like, affine matrix, header), with
     |      optional metadata in `extra`, and filename / file-like objects
     |      contained in the `file_map` mapping.
     |      
     |      Parameters
     |      ----------
     |      dataobj : object
     |         Object containing image data.  It should be some object that returns an
     |         array from ``np.asanyarray``.  It should have a ``shape`` attribute
     |         or property
     |      affine : None or (4,4) array-like
     |         homogeneous affine giving relationship between voxel coordinates and
     |         world coordinates.  Affine can also be None.  In this case,
     |         ``obj.affine`` also returns None, and the affine as written to disk
     |         will depend on the file format.
     |      header : None or mapping or header instance, optional
     |         metadata for this image format
     |      extra : None or mapping, optional
     |         metadata to associate with image that cannot be stored in the
     |         metadata of this image type
     |      file_map : mapping, optional
     |         mapping giving file information for this image format
     |  
     |  get_data_dtype(self)
     |  
     |  set_data_dtype(self, dtype)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ImageArrayProxy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a spec which defines how the data will be
     |      read and rescaled. The spec may be a tuple of length 2 - 5, containing the
     |      shape, storage dtype, offset, slope and intercept, or a ``header`` object
     |      with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      A header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' property goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  
     |  valid_exts = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  __getitem__(self, idx: 'object') -> 'None'
     |      No slicing or dictionary interface for images
     |      
     |      Use the slicer attribute to perform cropping and subsampling at your
     |      own risk.
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  as_reoriented(self: 'SpatialImgT', ornt: 'Sequence[Sequence[int]]') -> 'SpatialImgT'
     |      Apply an orientation change and return a new image
     |      
     |      If ornt is identity transform, return the original image, unchanged
     |      
     |      Parameters
     |      ----------
     |      ornt : (n,2) orientation array
     |         orientation transform. ``ornt[N,1]` is flip of axis N of the
     |         array implied by `shape`, where 1 means no flip and -1 means
     |         flip.  For example, if ``N==0`` and ``ornt[0,1] == -1``, and
     |         there's an array ``arr`` of shape `shape`, the flip would
     |         correspond to the effect of ``np.flipud(arr)``.  ``ornt[:,0]`` is
     |         the transpose that needs to be done to the implied array, as in
     |         ``arr.transpose(ornt[:,0])``
     |      
     |      Notes
     |      -----
     |      Subclasses should override this if they have additional requirements
     |      when re-orienting an image.
     |  
     |  orthoview(self) -> 'OrthoSlicer3D'
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  update_header(self) -> 'None'
     |      Harmonize header with image data and affine
     |      
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = SpatialImage(data, affine)
     |      >>> img.shape == (2, 3, 4)
     |      True
     |      >>> img.update_header()
     |      >>> img.header.get_data_shape() == (2, 3, 4)
     |      True
     |      >>> img.header.get_zooms()
     |      (1.0, 2.0, 3.0)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  from_image(img: 'SpatialImage | FileBasedImage') -> 'SpatialImgT' from builtins.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  affine
     |  
     |  slicer
     |      Slicer object that returns cropped and subsampled images
     |      
     |      The image is resliced in the current orientation; no rotation or
     |      resampling is performed, and no attempt is made to filter the image
     |      to avoid `aliasing`_.
     |      
     |      The affine matrix is updated with the new intercept (and scales, if
     |      down-sampling is used), so that all values are found at the same RAS
     |      locations.
     |      
     |      Slicing may include non-spatial dimensions.
     |      However, this method does not currently adjust the repetition time in
     |      the image header.
     |      
     |      .. _aliasing: https://en.wikipedia.org/wiki/Aliasing
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ImageSlicer = <class 'nibabel.spatialimages.SpatialFirstSlicer'>
     |      Slicing interface that returns a new image with an updated affine
     |      
     |      Checks that an image's first three axes are spatial
     |  
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  get_data(self, caching='fill')
     |      Return image data from image with any necessary scaling applied
     |      
     |      get_data() is deprecated in favor of get_fdata(), which has a more predictable return type. To obtain get_data() behavior going forward, use numpy.asanyarray(img.dataobj).
     |      
     |      * deprecated from version: 3.0
     |      * Raises <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 5.0
     |  
     |  get_fdata(self, caching: "ty.Literal['fill', 'unchanged']" = 'fill', dtype: 'npt.DTypeLike' = <class 'numpy.float64'>) -> 'np.ndarray[ty.Any, np.dtype[np.floating]]'
     |      Return floating point image data with necessary scaling applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_fdata()`` on a proxy image is to read
     |      the data from the proxy, and store in an internal cache.  Future calls
     |      to ``get_fdata`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_fdata`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_fdata``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_fdata`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      dtype : numpy dtype specifier
     |          A numpy dtype specifier specifying a floating point type.  Data is
     |          returned as this floating point type.  Default is ``np.float64``.
     |      
     |      Returns
     |      -------
     |      fdata : array
     |          Array of image data of data type `dtype`.
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_fdata`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_fdata``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_fdata(caching='unchanged')``; in this case ``get_fdata`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_fdata()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_fdata", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_fdata`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_fdata()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0.0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99.0
     |      
     |      The next time we call 'get_fdata', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_fdata()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99.0
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_fdata(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_fdata(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0.0
     |  
     |  uncache(self) -> 'None'
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_fdata()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_fdata()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_fdata()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_fdata()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_fdata() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_fdata()``, but when you uncache a proxy image, the result of
     |      ``img.get_fdata()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  load = from_filename(filename: 'FileSpec', *, mmap: "bool | ty.Literal['c', 'r']" = True, keep_file_open: 'bool | None' = None) -> 'ArrayImgT' from builtins.type
     |      Class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      keep_file_open : { None, True, False }, optional, keyword only
     |          `keep_file_open` controls whether a new file handle is created
     |          every time the image is accessed, or a single file handle is
     |          created and used for the lifetime of this ``ArrayProxy``. If
     |          ``True``, a single file handle is created and used. If ``False``,
     |          a new file handle is created every time the image is accessed.
     |          The default value (``None``) will result in the value of
     |          ``nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT`` being used.
     |      
     |      Returns
     |      -------
     |      img : DataobjImage instance
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.dataobj_images.DataobjImage:
     |  
     |  dataobj
     |  
     |  in_memory
     |      True when any array data is in memory cache
     |      
     |      There are separate caches for `get_data` reads and `get_fdata` reads.
     |      This property is True if either of those caches are set.
     |  
     |  ndim
     |  
     |  shape
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  get_filename(self) -> 'str | None'
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames associated with it (e.g.
     |         Analyze ``.img, .hdr`` pair) then we return the more characteristic
     |         filename (the ``.img`` filename in the case of Analyze')
     |  
     |  set_filename(self, filename: 'str') -> 'None'
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  to_filename(self, filename: 'FileSpec', **kwargs) -> 'None'
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      \*\*kwargs : keyword arguments
     |         Keyword arguments to format-specific save
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  filespec_to_file_map(filespec: 'FileSpec') -> 'FileMap' from builtins.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str or os.PathLike
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  instance_to_filename(img: 'FileBasedImage', filename: 'FileSpec') -> 'None' from builtins.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  make_file_map(mapping: 'ty.Mapping[str, str | io.IOBase] | None' = None) -> 'FileMap' from builtins.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  path_maybe_image(filename: 'FileSpec', sniff: 'FileSniff | None' = None, sniff_max: 'int' = 1024) -> 'tuple[bool, FileSniff | None]' from builtins.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str or os.PathLike
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  header
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class SpmAnalyzeHeader(nibabel.analyze.AnalyzeHeader)
     |  SpmAnalyzeHeader(binaryblock=None, endianness=None, check=True)
     |  
     |  Basic scaling Spm Analyze header
     |  
     |  Method resolution order:
     |      SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      nibabel.spatialimages.SpatialHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      nibabel.spatialimages.SpatialProtocol
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __subclasshook__ = _proto_hook(other)
     |      # Set (or override) the protocol subclass hook.
     |  
     |  get_slope_inter(self)
     |      Get scalefactor and intercept
     |      
     |      If scalefactor is 0.0 return None to indicate no scalefactor.
     |      Intercept is always None because SPM99 analyze cannot store intercepts.
     |  
     |  set_slope_inter(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      The SPM Analyze header can't save an intercept value, and we raise an
     |      error unless `inter` is None, NaN or 0
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope` of NaN.  NaN is a signal to the image
     |         writing routines to rescale on save.  0, Inf, -Inf are invalid and
     |         cause a HeaderDataError
     |      inter : None or float, optional
     |         intercept. Must be None, NaN or 0, because SPM99 cannot store
     |         intercepts.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from typing._ProtocolMeta
     |      Create empty header binary block with given endianness
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __parameters__ = ()
     |  
     |  has_data_intercept = False
     |  
     |  has_data_slope = True
     |  
     |  template_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...om...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize header from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into header.  By default, None, in
     |          which case we insert the default empty header block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of header in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> hdr1 = AnalyzeHeader() # an empty header
     |      >>> hdr1.endianness == native_code
     |      True
     |      >>> hdr1.get_data_shape()
     |      (0,)
     |      >>> hdr1.set_data_shape((1,2,3)) # now with some content
     |      >>> hdr1.get_data_shape()
     |      (1, 2, 3)
     |      
     |      We can set the binary block directly via this initialization.
     |      Here we get it from the header we have just made
     |      
     |      >>> binblock2 = hdr1.binaryblock
     |      >>> hdr2 = AnalyzeHeader(binblock2)
     |      >>> hdr2.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Empty headers are native endian by default
     |      
     |      >>> hdr2.endianness == native_code
     |      True
     |      
     |      You can pass valid opposite endian headers with the
     |      ``endianness`` parameter. Even empty headers can have
     |      endianness
     |      
     |      >>> hdr3 = AnalyzeHeader(endianness=swapped_code)
     |      >>> hdr3.endianness == swapped_code
     |      True
     |      
     |      If you do not pass an endianness, and you pass some data, we
     |      will try to guess from the passed data.
     |      
     |      >>> binblock3 = hdr3.binaryblock
     |      >>> hdr4 = AnalyzeHeader(binblock3)
     |      >>> hdr4.endianness == swapped_code
     |      True
     |  
     |  as_analyze_map(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  data_from_fileobj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  data_to_fileobj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tobytes('F') == str_io.getvalue()
     |      True
     |  
     |  get_base_affine(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  get_best_affine = get_base_affine(self)
     |  
     |  get_data_dtype(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  get_data_offset(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  get_data_shape(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |  
     |  get_zooms(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  raw_data_from_fileobj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  set_data_dtype(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  set_data_offset(self, offset)
     |      Set offset into data file to read data
     |  
     |  set_data_shape(self, shape)
     |      Set shape of data
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |  
     |  set_zooms(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  from_header(header=None, check=True) from typing._ProtocolMeta
     |      Class method to create header from another header
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  guessed_endian(hdr) from typing._ProtocolMeta
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  may_contain_header(binaryblock) from typing._ProtocolMeta
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  default_x_flip = True
     |  
     |  sizeof_hdr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from typing._ProtocolMeta
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from typing._ProtocolMeta
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.spatialimages.SpatialHeader:
     |  
     |  data_layout = 'F'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |  
     |  __init_subclass__(*args, **kwargs) from typing._ProtocolMeta
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __class_getitem__(params) from typing._ProtocolMeta

DATA
    data_history_dtd = [('descrip', 'S80'), ('aux_file', 'S24'), ('orient'...
    have_scipy = True
    header_dtype = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10...omin...
    header_key_dtd = [('sizeof_hdr', 'i4'), ('data_type', 'S10'), ('db_nam...
    image_dimension_dtd = [('dim', 'i2', (8,)), ('vox_units', 'S4'), ('cal...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/spm99analyze.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& squeeze_image &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function squeeze_image in module nibabel.funcs:

squeeze_image(img)
    Return image, remove axes length 1 at end of image shape
    
    For example, an image may have shape (10,20,30,1,1).  In this case
    squeeze will result in an image with shape (10,20,30).  See doctests
    for further description of behavior.
    
    Parameters
    ----------
    img : ``SpatialImage``
    
    Returns
    -------
    squeezed_img : ``SpatialImage``
       Copy of img, such that data, and data shape have been squeezed,
       for dimensions > 3rd, and at the end of the shape list
    
    Examples
    --------
    >>> import nibabel as nf
    >>> shape = (10,20,30,1,1)
    >>> data = np.arange(np.prod(shape), dtype='int32').reshape(shape)
    >>> affine = np.eye(4)
    >>> img = nf.Nifti1Image(data, affine)
    >>> img.shape == (10, 20, 30, 1, 1)
    True
    >>> img2 = squeeze_image(img)
    >>> img2.shape == (10, 20, 30)
    True
    
    If the data are 3D then last dimensions of 1 are ignored
    
    >>> shape = (10,1,1)
    >>> data = np.arange(np.prod(shape), dtype='int32').reshape(shape)
    >>> img = nf.ni1.Nifti1Image(data, affine)
    >>> img.shape == (10, 1, 1)
    True
    >>> img2 = squeeze_image(img)
    >>> img2.shape == (10, 1, 1)
    True
    
    Only *final* dimensions of 1 are squeezed
    
    >>> shape = (1, 1, 5, 1, 2, 1, 1)
    >>> data = data.reshape(shape)
    >>> img = nf.ni1.Nifti1Image(data, affine)
    >>> img.shape == (1, 1, 5, 1, 2, 1, 1)
    True
    >>> img2 = squeeze_image(img)
    >>> img2.shape == (1, 1, 5, 1, 2)
    True

None
&&&&&&&&&&&&&&&&&&&&&&&&& streamlines &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on package nibabel.streamlines in nibabel:

NAME
    nibabel.streamlines - Multiformat-capable streamline format read / write interface

PACKAGE CONTENTS
    array_sequence
    header
    tck
    tests (package)
    tractogram
    tractogram_file
    trk
    utils

FUNCTIONS
    detect_format(fileobj)
        Returns the StreamlinesFile object guessed from the file-like object.
        
        Parameters
        ----------
        fileobj : string or file-like object
            If string, a filename; otherwise an open file-like object pointing
            to a tractogram file (and ready to read from the beginning of the
            header)
        
        Returns
        -------
        tractogram_file : :class:`TractogramFile` class
            The class type guessed from the content of `fileobj`.
    
    is_supported(fileobj)
        Checks if the file-like object if supported by NiBabel.
        
        Parameters
        ----------
        fileobj : string or file-like object
            If string, a filename; otherwise an open file-like object pointing
            to a streamlines file (and ready to read from the beginning of the
            header)
        
        Returns
        -------
        is_supported : boolean
    
    load(fileobj, lazy_load=False)
        Loads streamlines in *RAS+* and *mm* space from a file-like object.
        
        Parameters
        ----------
        fileobj : string or file-like object
            If string, a filename; otherwise an open file-like object
            pointing to a streamlines file (and ready to read from the beginning
            of the streamlines file's header).
        lazy_load : {False, True}, optional
            If True, load streamlines in a lazy manner i.e. they will not be kept
            in memory and only be loaded when needed.
            Otherwise, load all streamlines in memory.
        
        Returns
        -------
        tractogram_file : :class:`TractogramFile` object
            Returns an instance of a :class:`TractogramFile` containing data and
            metadata of the tractogram loaded from `fileobj`.
        
        Notes
        -----
        The streamline coordinate (0,0,0) refers to the center of the voxel.
    
    save(tractogram, filename, **kwargs)
        Saves a tractogram to a file.
        
        Parameters
        ----------
        tractogram : :class:`Tractogram` object or :class:`TractogramFile` object
            If :class:`Tractogram` object, the file format will be guessed from
            `filename` and a :class:`TractogramFile` object will be created using
            provided keyword arguments.
            If :class:`TractogramFile` object, the file format is known and will
            be used to save its content to `filename`.
        filename : str
            Name of the file where the tractogram will be saved.
        \*\*kwargs : keyword arguments
            Keyword arguments passed to :class:`TractogramFile` constructor.
            Should not be specified if `tractogram` is already an instance of
            :class:`TractogramFile`.

DATA
    FORMATS = {'.tck': <class 'nibabel.streamlines.tck.TckFile'>, '.trk': ...

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/streamlines/__init__.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& test &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on function test in module nibabel:

test(label=None, verbose=1, extra_argv=None, doctests=False, coverage=False, raise_warnings=None, timer=False)
    Run tests for nibabel using pytest
    
    The protocol mimics the ``numpy.testing.NoseTester.test()``.
    Not all features are currently implemented.
    
    Parameters
    ----------
    label : None
        Unused.
    verbose: int, optional
        Verbosity value for test outputs. Positive values increase verbosity, and
        negative values decrease it. Default is 1.
    extra_argv : list, optional
        List with any extra arguments to pass to pytest.
    doctests: bool, optional
        If True, run doctests in module. Default is False.
    coverage: bool, optional
        If True, report coverage of NumPy code. Default is False.
        (This requires the
        `coverage module <https://nedbatchelder.com/code/modules/coveragehtml>`_).
    raise_warnings : None
        Unused.
    timer : False
        Unused.
    
    Returns
    -------
    code : ExitCode
        Returns the result of running the tests as a ``pytest.ExitCode`` enum

None
&&&&&&&&&&&&&&&&&&&&&&&&& tripwire &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.tripwire in nibabel:

NAME
    nibabel.tripwire - Class to raise error for missing modules or other misfortunes

CLASSES
    builtins.AttributeError(builtins.Exception)
        TripWireError
    builtins.object
        TripWire
    
    class TripWire(builtins.object)
     |  TripWire(msg: str) -> None
     |  
     |  Class raising error if used
     |  
     |  Standard use is to proxy modules that we could not import
     |  
     |  Examples
     |  --------
     |  >>> a_module = TripWire('We do not have a_module')
     |  >>> a_module.do_silly_thing('with silly string') #doctest: +IGNORE_EXCEPTION_DETAIL
     |  Traceback (most recent call last):
     |      ...
     |  TripWireError: We do not have a_module
     |  
     |  Methods defined here:
     |  
     |  __getattr__(self, attr_name: str) -> Any
     |      Raise informative error accessing attributes
     |  
     |  __init__(self, msg: str) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class TripWireError(builtins.AttributeError)
     |  Exception if trying to use TripWire object
     |  
     |  Method resolution order:
     |      TripWireError
     |      builtins.AttributeError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.AttributeError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.AttributeError:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    is_tripwire(obj: Any) -> bool
        Returns True if `obj` appears to be a TripWire object
        
        Examples
        --------
        >>> is_tripwire(object())
        False
        >>> is_tripwire(TripWire('some message'))
        True

DATA
    Any = typing.Any
        Special type indicating an unconstrained type.
        
        - Any is compatible with every type.
        - Any assumed to have all methods.
        - All values assumed to be instances of Any.
        
        Note that all the above statements are true from the point of view of
        static type checkers. At runtime, Any should not be used with instance
        or class checks.

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/tripwire.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& viewers &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.viewers in nibabel:

NAME
    nibabel.viewers - Utilities for viewing images

DESCRIPTION
    Includes version of OrthoSlicer3D code originally written by our own
    Paul Ivanov.

CLASSES
    builtins.object
        OrthoSlicer3D
    
    class OrthoSlicer3D(builtins.object)
     |  OrthoSlicer3D(data, affine=None, axes=None, title=None)
     |  
     |  Orthogonal-plane slice viewer
     |  
     |  OrthoSlicer3d expects 3- or 4-dimensional array data.  It treats
     |  4D data as a sequence of 3D spatial volumes, where a slice over the final
     |  array axis gives a single 3D spatial volume.
     |  
     |  For 3D data, the default behavior is to create a figure with 3 axes, one
     |  for each slice orientation of the spatial volume.
     |  
     |  Clicking and dragging the mouse in any one axis will select out the
     |  corresponding slices in the other two. Scrolling up and
     |  down moves the slice up and down in the current axis.
     |  
     |  For 4D data, the fourth figure axis can be used to control which
     |  3D volume is displayed.  Alternatively, the ``-`` key can be used to
     |  decrement the displayed volume and the ``+`` or ``=`` keys can be used to
     |  increment it.
     |  
     |  Examples
     |  --------
     |  >>> import numpy as np
     |  >>> a = np.sin(np.linspace(0, np.pi, 20))
     |  >>> b = np.sin(np.linspace(0, np.pi*5, 20))
     |  >>> data = np.outer(a, b)[..., np.newaxis] * a
     |  >>> OrthoSlicer3D(data).show()  # doctest: +SKIP
     |  
     |  Methods defined here:
     |  
     |  __init__(self, data, affine=None, axes=None, title=None)
     |      Parameters
     |      ----------
     |      data : array-like
     |          The data that will be displayed by the slicer. Should have 3+
     |          dimensions.
     |      affine : array-like or None, optional
     |          Affine transform for the data. This is used to determine
     |          how the data should be sliced for plotting into the sagittal,
     |          coronal, and axial view axes. If None, identity is assumed.
     |          The aspect ratio of the data are inferred from the affine
     |          transform.
     |      axes : tuple of mpl.Axes or None, optional
     |          3 or 4 axes instances for the 3 slices plus volumes,
     |          or None (default).
     |      title : str or None, optional
     |          The title to display. Can be None (default) to display no
     |          title.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  close(self)
     |      Close the viewer figures
     |  
     |  draw(self)
     |      Redraw the current image
     |  
     |  link_to(self, other)
     |      Link positional changes between two canvases
     |      
     |      Parameters
     |      ----------
     |      other : instance of OrthoSlicer3D
     |          Other viewer to use to link movements.
     |  
     |  set_position(self, x=None, y=None, z=None)
     |      Set current displayed slice indices
     |      
     |      Parameters
     |      ----------
     |      x : float | None
     |          X coordinate to use. If None, do not change.
     |      y : float | None
     |          Y coordinate to use. If None, do not change.
     |      z : float | None
     |          Z coordinate to use. If None, do not change.
     |  
     |  set_volume_idx(self, v)
     |      Set current displayed volume index
     |      
     |      Parameters
     |      ----------
     |      v : int
     |          Volume index.
     |  
     |  show(self)
     |      Show the slicer in blocking mode; convenience for ``plt.show()``
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  figs
     |      A tuple of the figure(s) containing the axes
     |  
     |  n_volumes
     |      Number of volumes in the data
     |  
     |  position
     |      The current coordinates
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clim
     |      The current color limits
     |  
     |  cmap
     |      The current colormap

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/viewers.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& volumeutils &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.volumeutils in nibabel:

NAME
    nibabel.volumeutils - Utility functions for analyze-like formats

CLASSES
    builtins.dict(builtins.object)
        DtypeMapper(builtins.dict, typing.Generic)
    builtins.object
        Recoder
    typing.Generic(builtins.object)
        DtypeMapper(builtins.dict, typing.Generic)
    
    class DtypeMapper(builtins.dict, typing.Generic)
     |  DtypeMapper() -> 'None'
     |  
     |  Specialized mapper for numpy dtypes
     |  
     |  We pass this mapper into the Recoder class to deal with numpy dtype
     |  hashing.
     |  
     |  The hashing problem is that dtypes that compare equal may not have the same
     |  hash.  This is true for numpys up to the current at time of writing
     |  (1.6.0).  For numpy 1.2.1 at least, even dtypes that look exactly the same
     |  in terms of fields don't always have the same hash.  This makes dtypes
     |  difficult to use as keys in a dictionary.
     |  
     |  This class wraps a dictionary in order to implement a __getitem__ to deal
     |  with dtype hashing. If the key doesn't appear to be in the mapping, and it
     |  is a dtype, we compare (using ==) all known dtype keys to the input key,
     |  and return any matching values for the matching key.
     |  
     |  Method resolution order:
     |      DtypeMapper
     |      builtins.dict
     |      typing.Generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, key: 'ty.Hashable') -> 'ty.Hashable'
     |      Get item from mapping, checking for dtype keys
     |      
     |      First do simple hash lookup, then check for a dtype key that has failed
     |      the hash lookup.  Look then for any known dtype keys that compare equal
     |      to `key`.
     |  
     |  __init__(self) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __setitem__(self, key: 'ty.Hashable', value: 'ty.Hashable') -> 'None'
     |      Set item into mapping, checking for dtype keys
     |      
     |      Cache dtype keys for comparison test in __getitem__
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __orig_bases__ = (typing.Dict[typing.Hashable, typing.Hashable],)
     |  
     |  __parameters__ = ()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.dict:
     |  
     |  __contains__(self, key, /)
     |      True if the dictionary has the specified key, else False.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __ior__(self, value, /)
     |      Return self|=value.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __or__(self, value, /)
     |      Return self|value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __reversed__(self, /)
     |      Return a reverse iterator over the dict keys.
     |  
     |  __ror__(self, value, /)
     |      Return value|self.
     |  
     |  __sizeof__(...)
     |      D.__sizeof__() -> size of D in memory, in bytes
     |  
     |  clear(...)
     |      D.clear() -> None.  Remove all items from D.
     |  
     |  copy(...)
     |      D.copy() -> a shallow copy of D
     |  
     |  get(self, key, default=None, /)
     |      Return the value for key if key is in the dictionary, else default.
     |  
     |  items(...)
     |      D.items() -> a set-like object providing a view on D's items
     |  
     |  keys(...)
     |      D.keys() -> a set-like object providing a view on D's keys
     |  
     |  pop(...)
     |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
     |      
     |      If key is not found, default is returned if given, otherwise KeyError is raised
     |  
     |  popitem(self, /)
     |      Remove and return a (key, value) pair as a 2-tuple.
     |      
     |      Pairs are returned in LIFO (last-in, first-out) order.
     |      Raises KeyError if the dict is empty.
     |  
     |  setdefault(self, key, default=None, /)
     |      Insert key with a value of default if key is not in the dictionary.
     |      
     |      Return the value for key if key is in the dictionary, else default.
     |  
     |  update(...)
     |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
     |      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
     |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
     |      In either case, this is followed by: for k in F:  D[k] = F[k]
     |  
     |  values(...)
     |      D.values() -> an object providing a view on D's values
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.dict:
     |  
     |  __class_getitem__(...) from builtins.type
     |      See PEP 585
     |  
     |  fromkeys(iterable, value=None, /) from builtins.type
     |      Create a new dictionary with keys from iterable and values set to value.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.dict:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from builtins.dict:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  __init_subclass__(*args, **kwargs) from builtins.type
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class Recoder(builtins.object)
     |  Recoder(codes: 'ty.Sequence[ty.Sequence[ty.Hashable]]', fields: 'ty.Sequence[str]' = ('code',), map_maker: 'type[ty.Mapping[ty.Hashable, ty.Hashable]]' = <class 'dict'>)
     |  
     |  class to return canonical code(s) from code or aliases
     |  
     |  The concept is a lot easier to read in the implementation and
     |  tests than it is to explain, so...
     |  
     |  >>> # If you have some codes, and several aliases, like this:
     |  >>> code1 = 1; aliases1=['one', 'first']
     |  >>> code2 = 2; aliases2=['two', 'second']
     |  >>> # You might want to do this:
     |  >>> codes = [[code1]+aliases1,[code2]+aliases2]
     |  >>> recodes = Recoder(codes)
     |  >>> recodes.code['one']
     |  1
     |  >>> recodes.code['second']
     |  2
     |  >>> recodes.code[2]
     |  2
     |  >>> # Or maybe you have a code, a label and some aliases
     |  >>> codes=((1,'label1','one', 'first'),(2,'label2','two'))
     |  >>> # you might want to get back the code or the label
     |  >>> recodes = Recoder(codes, fields=('code','label'))
     |  >>> recodes.code['first']
     |  1
     |  >>> recodes.code['label1']
     |  1
     |  >>> recodes.label[2]
     |  'label2'
     |  >>> # For convenience, you can get the first entered name by
     |  >>> # indexing the object directly
     |  >>> recodes[2]
     |  2
     |  
     |  Methods defined here:
     |  
     |  __contains__(self, key: 'ty.Hashable') -> 'bool'
     |      True if field1 in recoder contains `key`
     |  
     |  __getattr__(self, key: 'str') -> 'ty.Mapping[ty.Hashable, ty.Hashable]'
     |  
     |  __getitem__(self, key: 'ty.Hashable') -> 'ty.Hashable'
     |      Return value from field1 dictionary (first column of values)
     |      
     |      Returns same value as ``obj.field1[key]`` and, with the
     |      default initializing ``fields`` argument of fields=('code',),
     |      this will return the same as ``obj.code[key]``
     |      
     |      >>> codes = ((1, 'one'), (2, 'two'))
     |      >>> Recoder(codes)['two']
     |      2
     |  
     |  __init__(self, codes: 'ty.Sequence[ty.Sequence[ty.Hashable]]', fields: 'ty.Sequence[str]' = ('code',), map_maker: 'type[ty.Mapping[ty.Hashable, ty.Hashable]]' = <class 'dict'>)
     |      Create recoder object
     |      
     |      ``codes`` give a sequence of code, alias sequences
     |      ``fields`` are names by which the entries in these sequences can be
     |      accessed.
     |      
     |      By default ``fields`` gives the first column the name
     |      "code".  The first column is the vector of first entries
     |      in each of the sequences found in ``codes``.  Thence you can
     |      get the equivalent first column value with ob.code[value],
     |      where value can be a first column value, or a value in any of
     |      the other columns in that sequence.
     |      
     |      You can give other columns names too, and access them in the
     |      same way - see the examples in the class docstring.
     |      
     |      Parameters
     |      ----------
     |      codes : sequence of sequences
     |          Each sequence defines values (codes) that are equivalent
     |      fields : {('code',) string sequence}, optional
     |          names by which elements in sequences can be accessed
     |      map_maker: callable, optional
     |          constructor for dict-like objects used to store key value pairs.
     |          Default is ``dict``.  ``map_maker()`` generates an empty mapping.
     |          The mapping need only implement ``__getitem__, __setitem__, keys,
     |          values``.
     |  
     |  add_codes(self, code_syn_seqs: 'ty.Sequence[ty.Sequence[ty.Hashable]]') -> 'None'
     |      Add codes to object
     |      
     |      Parameters
     |      ----------
     |      code_syn_seqs : sequence
     |          sequence of sequences, where each sequence ``S = code_syn_seqs[n]``
     |          for n in 0..len(code_syn_seqs), is a sequence giving values in the
     |          same order as ``self.fields``.  Each S should be at least of the
     |          same length as ``self.fields``.  After this call, if ``self.fields
     |          == ['field1', 'field2'], then ``self.field1[S[n]] == S[0]`` for all
     |          n in 0..len(S) and ``self.field2[S[n]] == S[1]`` for all n in
     |          0..len(S).
     |      
     |      Examples
     |      --------
     |      >>> code_syn_seqs = ((2, 'two'), (1, 'one'))
     |      >>> rc = Recoder(code_syn_seqs)
     |      >>> rc.value_set() == set((1,2))
     |      True
     |      >>> rc.add_codes(((3, 'three'), (1, 'first')))
     |      >>> rc.value_set() == set((1,2,3))
     |      True
     |      >>> print(rc.value_set())  # set is actually ordered
     |      OrderedSet([2, 1, 3])
     |  
     |  keys(self)
     |      Return all available code and alias values
     |      
     |      Returns same value as ``obj.field1.keys()`` and, with the
     |      default initializing ``fields`` argument of fields=('code',),
     |      this will return the same as ``obj.code.keys()``
     |      
     |      >>> codes = ((1, 'one'), (2, 'two'), (1, 'repeat value'))
     |      >>> k = Recoder(codes).keys()
     |      >>> set(k) == set([1, 2, 'one', 'repeat value', 'two'])
     |      True
     |  
     |  value_set(self, name: 'str | None' = None) -> 'OrderedSet'
     |      Return OrderedSet of possible returned values for column
     |      
     |      By default, the column is the first column.
     |      
     |      Returns same values as ``set(obj.field1.values())`` and,
     |      with the default initializing``fields`` argument of
     |      fields=('code',), this will return the same as
     |      ``set(obj.code.values())``
     |      
     |      Parameters
     |      ----------
     |      name : {None, string}
     |          Where default of none gives result for first column
     |      
     |      >>> codes = ((1, 'one'), (2, 'two'), (1, 'repeat value'))
     |      >>> vs = Recoder(codes).value_set()
     |      >>> vs == set([1, 2]) # Sets are not ordered, hence this test
     |      True
     |      >>> rc = Recoder(codes, fields=('code', 'label'))
     |      >>> rc.value_set('label') == set(('one', 'two', 'repeat value'))
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'fields': 'tuple[str, ...]'}

FUNCTIONS
    apply_read_scaling(arr: 'np.ndarray', slope: 'Scalar | None' = None, inter: 'Scalar | None' = None) -> 'np.ndarray'
        Apply scaling in `slope` and `inter` to array `arr`
        
        This is for loading the array from a file (as opposed to the reverse
        scaling when saving an array to file)
        
        Return data will be ``arr * slope + inter``. The trick is that we have to
        find a good precision to use for applying the scaling.  The heuristic is
        that the data is always upcast to the higher of the types from `arr,
        `slope`, `inter` if `slope` and / or `inter` are not default values. If the
        dtype of `arr` is an integer, then we assume the data more or less fills
        the integer range, and upcast to a type such that the min, max of
        ``arr.dtype`` * scale + inter, will be finite.
        
        Parameters
        ----------
        arr : array-like
        slope : None or float, optional
            slope value to apply to `arr` (``arr * slope + inter``).  None
            corresponds to a value of 1.0
        inter : None or float, optional
            intercept value to apply to `arr` (``arr * slope + inter``).  None
            corresponds to a value of 0.0
        
        Returns
        -------
        ret : array
            array with scaling applied.  Maybe upcast in order to give room for the
            scaling. If scaling is default (1, 0), then `ret` may be `arr` ``ret is
            arr``.
    
    array_from_file(shape: 'tuple[int, ...]', in_dtype: 'np.dtype[DT]', infile: 'io.IOBase', offset: 'int' = 0, order: "ty.Literal['C', 'F']" = 'F', mmap: "bool | ty.Literal['c', 'r', 'r+']" = True) -> 'npt.NDArray[DT]'
        Get array from file with specified shape, dtype and file offset
        
        Parameters
        ----------
        shape : sequence
            sequence specifying output array shape
        in_dtype : numpy dtype
            fully specified numpy dtype, including correct endianness
        infile : file-like
            open file-like object implementing at least read() and seek()
        offset : int, optional
            offset in bytes into `infile` to start reading array data. Default is 0
        order : {'F', 'C'} string
            order in which to write data.  Default is 'F' (fortran order).
        mmap : {True, False, 'c', 'r', 'r+'}
            `mmap` controls the use of numpy memory mapping for reading data.  If
            False, do not try numpy ``memmap`` for data array.  If one of {'c',
            'r', 'r+'}, try numpy memmap with ``mode=mmap``.  A `mmap` value of
            True gives the same behavior as ``mmap='c'``.  If `infile` cannot be
            memory-mapped, ignore `mmap` value and read array from file.
        
        Returns
        -------
        arr : array-like
            array like object that can be sliced, containing data
        
        Examples
        --------
        >>> from io import BytesIO
        >>> bio = BytesIO()
        >>> arr = np.arange(6).reshape(1,2,3)
        >>> _ = bio.write(arr.tobytes('F'))  # outputs int
        >>> arr2 = array_from_file((1,2,3), arr.dtype, bio)
        >>> np.all(arr == arr2)
        True
        >>> bio = BytesIO()
        >>> _ = bio.write(b' ' * 10)
        >>> _ = bio.write(arr.tobytes('F'))
        >>> arr2 = array_from_file((1,2,3), arr.dtype, bio, 10)
        >>> np.all(arr == arr2)
        True
    
    array_to_file(data: 'npt.ArrayLike', fileobj: 'io.IOBase', out_dtype: 'np.dtype | None' = None, offset: 'int' = 0, intercept: 'Scalar' = 0.0, divslope: 'Scalar | None' = 1.0, mn: 'Scalar | None' = None, mx: 'Scalar | None' = None, order: "ty.Literal['C', 'F']" = 'F', nan2zero: 'bool' = True) -> 'None'
        Helper function for writing arrays to file objects
        
        Writes arrays as scaled by `intercept` and `divslope`, and clipped
        at (prescaling) `mn` minimum, and `mx` maximum.
        
        * Clip `data` array at min `mn`, max `max` where there are not None ->
          ``clipped`` (this is *pre scale clipping*)
        * Scale ``clipped`` with ``clipped_scaled = (clipped - intercept) /
          divslope``
        * Clip ``clipped_scaled`` to fit into range of `out_dtype` (*post scale
          clipping*) -> ``clipped_scaled_clipped``
        * If converting to integer `out_dtype` and `nan2zero` is True, set NaN
          values in ``clipped_scaled_clipped`` to 0
        * Write ``clipped_scaled_clipped_n2z`` to fileobj `fileobj` starting at
          offset `offset` in memory layout `order`
        
        Parameters
        ----------
        data : array-like
            array or array-like to write.
        fileobj : file-like
            file-like object implementing ``write`` method.
        out_dtype : None or dtype, optional
            dtype to write array as.  Data array will be coerced to this dtype
            before writing. If None (default) then use input data type.
        offset : None or int, optional
            offset into fileobj at which to start writing data. Default is 0. None
            means start at current file position
        intercept : scalar, optional
            scalar to subtract from data, before dividing by ``divslope``.  Default
            is 0.0
        divslope : None or scalar, optional
            scalefactor to *divide* data by before writing.  Default is 1.0. If
            None, there is no valid data, we write zeros.
        mn : scalar, optional
            minimum threshold in (unscaled) data, such that all data below this
            value are set to this value. Default is None (no threshold). The
            typical use is to set -np.inf in the data to have this value (which
            might be the minimum non-finite value in the data).
        mx : scalar, optional
            maximum threshold in (unscaled) data, such that all data above this
            value are set to this value. Default is None (no threshold). The
            typical use is to set np.inf in the data to have this value (which
            might be the maximum non-finite value in the data).
        order : {'F', 'C'}, optional
            memory order to write array.  Default is 'F'
        nan2zero : {True, False}, optional
            Whether to set NaN values to 0 when writing integer output.  Defaults
            to True.  If False, NaNs will be represented as numpy does when
            casting; this depends on the underlying C library and is undefined. In
            practice `nan2zero` == False might be a good choice when you completely
            sure there will be no NaNs in the data. This value ignored for float
            output types.  NaNs are treated as zero *before* applying `intercept`
            and `divslope` - so an array ``[np.nan]`` with an `intercept` of 10
            becomes ``[-10]`` after conversion to integer `out_dtype` with
            `nan2zero` set.  That is because you will likely apply `divslope` and
            `intercept` in reverse order when reading the data back, returning the
            zero you probably expected from the input NaN.
        
        Examples
        --------
        >>> from io import BytesIO
        >>> sio = BytesIO()
        >>> data = np.arange(10, dtype=np.float64)
        >>> array_to_file(data, sio, np.float64)
        >>> sio.getvalue() == data.tobytes('F')
        True
        >>> _ = sio.truncate(0); _ = sio.seek(0)  # outputs 0
        >>> array_to_file(data, sio, np.int16)
        >>> sio.getvalue() == data.astype(np.int16).tobytes()
        True
        >>> _ = sio.truncate(0); _ = sio.seek(0)
        >>> array_to_file(data.byteswap(), sio, np.float64)
        >>> sio.getvalue() == data.byteswap().tobytes('F')
        True
        >>> _ = sio.truncate(0); _ = sio.seek(0)
        >>> array_to_file(data, sio, np.float64, order='C')
        >>> sio.getvalue() == data.tobytes('C')
        True
    
    best_write_scale_ftype(arr: 'np.ndarray', slope: 'npt.ArrayLike' = 1.0, inter: 'npt.ArrayLike' = 0.0, default: 'type[np.number]' = <class 'numpy.float32'>) -> 'type[np.floating]'
        Smallest float type to contain range of ``arr`` after scaling
        
        Scaling that will be applied to ``arr`` is ``(arr - inter) / slope``.
        
        Note that ``slope`` and ``inter`` get promoted to 1D arrays for this
        purpose to avoid the numpy scalar casting rules, which prevent scalars
        upcasting the array.
        
        Parameters
        ----------
        arr : array-like
            array that will be scaled
        slope : array-like, optional
            scalar such that output array will be ``(arr - inter) / slope``.
        inter : array-like, optional
            scalar such that output array will be ``(arr - inter) / slope``
        default : numpy type, optional
            minimum float type to return
        
        Returns
        -------
        ftype : numpy type
            Best floating point type for scaling.  If no floating point type
            prevents overflow, return the top floating point type.  If the input
            array ``arr`` already contains inf values, return the greater of the
            input type and the default type.
        
        Examples
        --------
        >>> arr = np.array([0, 1, 2], dtype=np.int16)
        >>> best_write_scale_ftype(arr, 1, 0) is np.float32
        True
        
        Specify higher default return value
        
        >>> best_write_scale_ftype(arr, 1, 0, default=np.float64) is np.float64
        True
        
        Even large values that don't overflow don't change output
        
        >>> arr = np.array([0, np.finfo(np.float32).max], dtype=np.float32)
        >>> best_write_scale_ftype(arr, 1, 0) is np.float32
        True
        
        Scaling > 1 reduces output values, so no upcast needed
        
        >>> best_write_scale_ftype(arr, np.float32(2), 0) is np.float32
        True
        
        Scaling < 1 increases values, so upcast may be needed (and is here)
        
        >>> best_write_scale_ftype(arr, np.float32(0.5), 0) is np.float64
        True
    
    better_float_of(first: 'npt.DTypeLike', second: 'npt.DTypeLike', default: 'type[np.floating]' = <class 'numpy.float32'>) -> 'type[np.floating]'
        Return more capable float type of `first` and `second`
        
        Return `default` if neither of `first` or `second` is a float
        
        Parameters
        ----------
        first : numpy type specifier
            Any valid input to `np.dtype()``
        second : numpy type specifier
            Any valid input to `np.dtype()``
        default : numpy type specifier, optional
            Any valid input to `np.dtype()``
        
        Returns
        -------
        better_type : numpy type
            More capable of `first` or `second` if both are floats; if only one is
            a float return that, otherwise return `default`.
        
        Examples
        --------
        >>> better_float_of(np.float32, np.float64) is np.float64
        True
        >>> better_float_of(np.float32, 'i4') is np.float32
        True
        >>> better_float_of('i2', 'u4') is np.float32
        True
        >>> better_float_of('i2', 'u4', np.float64) is np.float64
        True
    
    finite_range(arr: 'npt.ArrayLike', check_nan: 'bool' = False) -> 'tuple[Scalar, Scalar, bool] | tuple[Scalar, Scalar]'
        Get range (min, max) or range and flag (min, max, has_nan) from `arr`
        
        Parameters
        ----------
        arr : array-like
        check_nan : {False, True}, optional
            Whether to return third output, a bool signaling whether there are NaN
            values in `arr`
        
        Returns
        -------
        mn : scalar
           minimum of values in (flattened) array
        mx : scalar
           maximum of values in (flattened) array
        has_nan : bool
           Returned if `check_nan` is True. `has_nan` is True if there are one or
           more NaN values in `arr`
        
        Examples
        --------
        >>> a = np.array([[-1, 0, 1],[np.inf, np.nan, -np.inf]])
        >>> finite_range(a)
        (-1.0, 1.0)
        >>> a = np.array([[-1, 0, 1],[np.inf, np.nan, -np.inf]])
        >>> finite_range(a, check_nan=True)
        (-1.0, 1.0, True)
        >>> a = np.array([[np.nan],[np.nan]])
        >>> finite_range(a) == (np.inf, -np.inf)
        True
        >>> a = np.array([[-3, 0, 1],[2,-1,4]], dtype=int)
        >>> finite_range(a)
        (-3, 4)
        >>> a = np.array([[1, 0, 1],[2,3,4]], dtype=np.uint)
        >>> finite_range(a)
        (0, 4)
        >>> a = a + 1j
        >>> finite_range(a)
        (1j, (4+1j))
        >>> a = np.zeros((2,), dtype=[('f1', 'i2')])
        >>> finite_range(a)
        Traceback (most recent call last):
           ...
        TypeError: Can only handle numeric types
    
    fname_ext_ul_case(fname: 'str') -> 'str'
        `fname` with ext changed to upper / lower case if file exists
        
        Check for existence of `fname`.  If it does exist, return unmodified.  If
        it doesn't, check for existence of `fname` with case changed from lower to
        upper, or upper to lower.  Return this modified `fname` if it exists.
        Otherwise return `fname` unmodified
        
        Parameters
        ----------
        fname : str
            filename.
        
        Returns
        -------
        mod_fname : str
            filename, maybe with extension of opposite case
    
    getitem(a, b, /)
        Same as a[b].
    
    int_scinter_ftype(ifmt: 'type[np.integer]', slope: 'npt.ArrayLike' = 1.0, inter: 'npt.ArrayLike' = 0.0, default: 'type[np.floating]' = <class 'numpy.float32'>) -> 'type[np.floating]'
        float type containing int type `ifmt` * `slope` + `inter`
        
        Return float type that can represent the max and the min of the `ifmt` type
        after multiplication with `slope` and addition of `inter` with something
        like ``np.array([imin, imax], dtype=ifmt) * slope + inter``.
        
        Note that ``slope`` and ``inter`` get promoted to 1D arrays for this
        purpose to avoid the numpy scalar casting rules, which prevent scalars
        upcasting the array.
        
        Parameters
        ----------
        ifmt : object
            numpy integer type (e.g. np.int32)
        slope : float, optional
            slope, default 1.0
        inter : float, optional
            intercept, default 0.0
        default_out : object, optional
            numpy floating point type, default is ``np.float32``
        
        Returns
        -------
        ftype : object
            numpy floating point type
        
        Examples
        --------
        >>> int_scinter_ftype(np.int8, 1.0, 0.0) == np.float32
        True
        >>> int_scinter_ftype(np.int8, 1e38, 0.0) == np.float64
        True
        
        Notes
        -----
        It is difficult to make floats overflow with just addition because the
        deltas are so large at the extremes of floating point.  For example::
        
            >>> arr = np.array([np.finfo(np.float32).max], dtype=np.float32)
            >>> res = arr + np.iinfo(np.int16).max
            >>> arr == res
            array([ True])
    
    make_dt_codes(codes_seqs: 'ty.Sequence[ty.Sequence]') -> 'Recoder'
        Create full dt codes Recoder instance from datatype codes
        
        Include created numpy dtype (from numpy type) and opposite endian
        numpy dtype
        
        Parameters
        ----------
        codes_seqs : sequence of sequences
           contained sequences make be length 3 or 4, but must all be the same
           length. Elements are data type code, data type name, and numpy
           type (such as ``np.float32``).  The fourth element is the nifti string
           representation of the code (e.g. "NIFTI_TYPE_FLOAT32")
        
        Returns
        -------
        rec : ``Recoder`` instance
           Recoder that, by default, returns ``code`` when indexed with any
           of the corresponding code, name, type, dtype, or swapped dtype.
           You can also index with ``niistring`` values if codes_seqs had sequences
           of length 4 instead of 3.
    
    mul(a, b, /)
        Same as a * b.
    
    pretty_mapping(mapping: 'ty.Mapping[K, V]', getterfunc: 'ty.Callable[[ty.Mapping[K, V], K], V] | None' = None) -> 'str'
        Make pretty string from mapping
        
        Adjusts text column to print values on basis of longest key.
        Probably only sensible if keys are mainly strings.
        
        You can pass in a callable that does clever things to get the values
        out of the mapping, given the names.  By default, we just use
        ``__getitem__``
        
        Parameters
        ----------
        mapping : mapping
           implementing iterator returning keys and .items()
        getterfunc : None or callable
           callable taking two arguments, ``obj`` and ``key`` where ``obj``
           is the passed mapping.  If None, just use ``lambda obj, key:
           obj[key]``
        
        Returns
        -------
        str : string
        
        Examples
        --------
        >>> d = {'a key': 'a value'}
        >>> print(pretty_mapping(d))
        a key  : a value
        >>> class C: # to control ordering, show get_ method
        ...     def __iter__(self):
        ...         return iter(('short_field','longer_field'))
        ...     def __getitem__(self, key):
        ...         if key == 'short_field':
        ...             return 0
        ...         if key == 'longer_field':
        ...             return 'str'
        ...     def get_longer_field(self):
        ...         return 'method string'
        >>> def getter(obj, key):
        ...     # Look for any 'get_<name>' methods
        ...     try:
        ...         return obj.__getattribute__('get_' + key)()
        ...     except AttributeError:
        ...         return obj[key]
        >>> print(pretty_mapping(C(), getter))
        short_field   : 0
        longer_field  : method string
    
    rec2dict(rec: 'np.ndarray') -> 'dict[str, np.generic | np.ndarray]'
        Convert recarray to dictionary
        
        Also converts scalar values to scalars
        
        Parameters
        ----------
        rec : ndarray
           structured ndarray
        
        Returns
        -------
        dct : dict
           dict with key, value pairs as for `rec`
        
        Examples
        --------
        >>> r = np.zeros((), dtype = [('x', 'i4'), ('s', 'S10')])
        >>> d = rec2dict(r)
        >>> d == {'x': 0, 's': b''}
        True
    
    reduce(...)
        reduce(function, sequence[, initial]) -> value
        
        Apply a function of two arguments cumulatively to the items of a sequence,
        from left to right, so as to reduce the sequence to a single value.
        For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
        ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
        of the sequence in the calculation, and serves as a default when the
        sequence is empty.
    
    seek_tell(fileobj: 'io.IOBase', offset: 'int', write0: 'bool' = False) -> 'None'
        Seek in `fileobj` or check we're in the right place already
        
        Parameters
        ----------
        fileobj : file-like
            object implementing ``seek`` and (if seek raises an OSError) ``tell``
        offset : int
            position in file to which to seek
        write0 : {False, True}, optional
            If True, and standard seek fails, try to write zeros to the file to
            reach `offset`.  This can be useful when writing bz2 files, that cannot
            do write seeks.
    
    shape_zoom_affine(shape: 'ty.Sequence[int] | np.ndarray', zooms: 'ty.Sequence[float] | np.ndarray', x_flip: 'bool' = True) -> 'np.ndarray'
        Get affine implied by given shape and zooms
        
        We get the translations from the center of the image (implied by
        `shape`).
        
        Parameters
        ----------
        shape : (N,) array-like
           shape of image data. ``N`` is the number of dimensions
        zooms : (N,) array-like
           zooms (voxel sizes) of the image
        x_flip : {True, False}
           whether to flip the X row of the affine.  Corresponds to
           radiological storage on disk.
        
        Returns
        -------
        aff : (4,4) array
           affine giving correspondence of voxel coordinates to mm
           coordinates, taking the center of the image as origin
        
        Examples
        --------
        >>> shape = (3, 5, 7)
        >>> zooms = (3, 2, 1)
        >>> shape_zoom_affine((3, 5, 7), (3, 2, 1))
        array([[-3.,  0.,  0.,  3.],
               [ 0.,  2.,  0., -4.],
               [ 0.,  0.,  1., -3.],
               [ 0.,  0.,  0.,  1.]])
        >>> shape_zoom_affine((3, 5, 7), (3, 2, 1), False)
        array([[ 3.,  0.,  0., -3.],
               [ 0.,  2.,  0., -4.],
               [ 0.,  0.,  1., -3.],
               [ 0.,  0.,  0.,  1.]])
    
    working_type(in_type: 'npt.DTypeLike', slope: 'npt.ArrayLike' = 1.0, inter: 'npt.ArrayLike' = 0.0) -> 'type[np.number]'
        Return array type from applying `slope`, `inter` to array of `in_type`
        
        Numpy type that results from an array of type `in_type` being combined with
        `slope` and `inter`. It returns something like the dtype type of
        ``((np.zeros((2,), dtype=in_type) - inter) / slope)``, but ignoring the
        actual values of `slope` and `inter`.
        
        Note that you would not necessarily get the same type by applying slope and
        inter the other way round.  Also, you'll see that the order in which slope
        and inter are applied is the opposite of the order in which they are
        passed.
        
        Parameters
        ----------
        in_type : numpy type specifier
            Numpy type of input array.  Any valid input for ``np.dtype()``
        slope : scalar, optional
            slope to apply to array.  If 1.0 (default), ignore this value and its
            type.
        inter : scalar, optional
            intercept to apply to array.  If 0.0 (default), ignore this value and
            its type.
        
        Returns
        -------
        wtype: numpy type
            Numpy type resulting from applying `inter` and `slope` to array of type
            `in_type`.
    
    write_zeros(fileobj: 'io.IOBase', count: 'int', block_size: 'int' = 8194) -> 'None'
        Write `count` zero bytes to `fileobj`
        
        Parameters
        ----------
        fileobj : file-like object
            with ``write`` method
        count : int
            number of bytes to write
        block_size : int, optional
            largest continuous block to write.

DATA
    COMPRESSED_FILE_LIKES = (<class 'bz2.BZ2File'>, <class 'gzip.GzipFile'...
    OK_FLOATS = [<class 'numpy.float16'>, <class 'numpy.float32'>, <class ...
    __annotations__ = {'_CSIZE2FLOAT': 'dict[int, type[np.floating]]'}
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    default_compresslevel = 1
    endian_codes = <nibabel.volumeutils.Recoder object>
    native_code = '<'
    swapped_code = '>'
    sys_is_le = True

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/volumeutils.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& wrapstruct &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.wrapstruct in nibabel:

NAME
    nibabel.wrapstruct - Class to wrap numpy structured array

DESCRIPTION
    ============
     wrapstruct
    ============
    
    The :class:`WrapStruct` class is a wrapper around a numpy structured array
    type.
    
    It implements:
    
    * Mappingness from the underlying structured array fields
    * ``from_fileobj``, ``write_to`` methods to read and write data to fileobj
    * A mechanism for setting checks and fixes to the data on object creation
    * Endianness guessing, and on-the-fly swapping
    
    The :class:`LabeledWrapStruct` subclass adds:
    
    * A pretty printing mechanism whereby field values can be displayed as
      corresponding strings (see :meth:`LabeledWrapStruct.get_value_label` and
      :meth:`LabeledWrapStruct.__str_`)
    
    Mappingness
    -----------
    
    You can access and set fields of the contained structarr using standard
    __getitem__ / __setitem__ syntax:
    
        wrapped['field'] = 10
    
    Wrapped structures also implement general mappingness:
    
        wrapped.keys()
        wrapped.items()
        wrapped.values()
    
    Properties::
    
        .endianness (read only)
        .binaryblock (read only)
        .structarr (read only)
    
    Methods::
    
        .as_byteswapped(endianness)
        .check_fix()
        .__str__
        .__eq__
        .__ne__
        .get_value_label(name)
    
    Class methods::
    
        .diagnose_binaryblock
        .as_byteswapped(endianness)
        .write_to(fileobj)
        .from_fileobj(fileobj)
        .default_structarr() - return default structured array
        .guessed_endian(structarr) - return guessed endian code from this structarr
    
    Class variables:
        template_dtype - native endian version of dtype for contained structarr
    
    Consistency checks
    ------------------
    
    We have a file, and we would like information as to whether there are any
    problems with the binary data in this file, and whether they are fixable.
    ``WrapStruct`` can hold checks for internal consistency of the contained data::
    
       wrapped = WrapStruct.from_fileobj(open('myfile.bin'), check=False)
       dx_result = WrapStruct.diagnose_binaryblock(wrapped.binaryblock)
    
    This will run all known checks, with no fixes, returning a string with
    diagnostic output. See below for the ``check=False`` flag.
    
    In creating a ``WrapStruct`` object, we often want to check the consistency of
    the contained data.  The checks can test for problems of various levels of
    severity.  If the problem is severe enough, it should raise an Error.  So, with
    data that is consistent - no error::
    
       wrapped = WrapStruct.from_fileobj(good_fileobj)
    
    whereas::
    
       wrapped = WrapStruct.from_fileobj(bad_fileobj)
    
    would raise some error, with output to logging (see below).
    
    If we want the created object, come what may::
    
       hdr = WrapStruct.from_fileobj(bad_fileobj, check=False)
    
    We set the error level (the level of problem that the ``check=True``
    versions will accept as OK) from global defaults::
    
       import nibabel as nib
       nib.imageglobals.error_level = 30
    
    The same for logging::
    
       nib.imageglobals.logger = logger

CLASSES
    builtins.Exception(builtins.BaseException)
        WrapStructError
    builtins.object
        WrapStruct
            LabeledWrapStruct
    
    class LabeledWrapStruct(WrapStruct)
     |  LabeledWrapStruct(binaryblock=None, endianness=None, check=True)
     |  
     |  A WrapStruct with some fields having value labels for printing etc
     |  
     |  Method resolution order:
     |      LabeledWrapStruct
     |      WrapStruct
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  get_value_label(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'_field_recoders': 'dict[str, Recoder]'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from WrapStruct:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize WrapStruct from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into object.  By default, None, in
     |          which case we insert the default empty block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of binary data in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # a default structure
     |      >>> wstr1.endianness == native_code
     |      True
     |      >>> wstr1['integer']
     |      array(0, dtype=int16)
     |      >>> wstr1['integer'] = 1
     |      >>> wstr1['integer']
     |      array(1, dtype=int16)
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from WrapStruct:
     |  
     |  default_structarr(endianness=None) from builtins.type
     |      Return structured array for default structure with given endianness
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from builtins.type
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from builtins.type
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  guessed_endian(mapping) from builtins.type
     |      Guess intended endianness from mapping-like ``mapping``
     |      
     |      Parameters
     |      ----------
     |      wstr : mapping-like
     |          Something implementing a mapping.  We will guess the endianness
     |          from looking at the field values
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of binary data in ``wstr``
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from WrapStruct:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from WrapStruct:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from WrapStruct:
     |  
     |  __hash__ = None
     |  
     |  template_dtype = dtype([('integer', '<i2')])
    
    class WrapStruct(builtins.object)
     |  WrapStruct(binaryblock=None, endianness=None, check=True)
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  __getitem__(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  __init__(self, binaryblock=None, endianness=None, check=True)
     |      Initialize WrapStruct from binary data block
     |      
     |      Parameters
     |      ----------
     |      binaryblock : {None, string} optional
     |          binary block to set into object.  By default, None, in
     |          which case we insert the default empty block
     |      endianness : {None, '<','>', other endian code} string, optional
     |          endianness of the binaryblock.  If None, guess endianness
     |          from the data.
     |      check : bool, optional
     |          Whether to check content of binary data in initialization.
     |          Default is True.
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # a default structure
     |      >>> wstr1.endianness == native_code
     |      True
     |      >>> wstr1['integer']
     |      array(0, dtype=int16)
     |      >>> wstr1['integer'] = 1
     |      >>> wstr1['integer']
     |      array(1, dtype=int16)
     |  
     |  __iter__(self)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __setitem__(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  __str__(self)
     |      Return string representation for printing
     |  
     |  as_byteswapped(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  check_fix(self, logger=None, error_level=None)
     |      Check structured data with checks
     |      
     |      Parameters
     |      ----------
     |      logger : None or logging.Logger
     |      error_level : None or int
     |          Level of error severity at which to raise error.  Any error of
     |          severity >= `error_level` will cause an exception.
     |  
     |  copy(self)
     |      Return copy of structure
     |      
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr2 = wstr.copy()
     |      >>> wstr2 is wstr
     |      False
     |      >>> wstr2['integer']
     |      array(3, dtype=int16)
     |  
     |  get(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  items(self)
     |      Return items from structured data
     |  
     |  keys(self)
     |      Return keys from structured data
     |  
     |  values(self)
     |      Return values from structured data
     |  
     |  write_to(self, fileobj)
     |      Write structure to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> wstr.write_to(str_io)
     |      >>> wstr.binaryblock == str_io.getvalue()
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  default_structarr(endianness=None) from builtins.type
     |      Return structured array for default structure with given endianness
     |  
     |  diagnose_binaryblock(binaryblock, endianness=None) from builtins.type
     |      Run checks over binary data, return string
     |  
     |  from_fileobj(fileobj, endianness=None, check=True) from builtins.type
     |      Return read structure with given or guessed endiancode
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Needs to implement ``read`` method
     |      endianness : None or endian code, optional
     |         Code specifying endianness of read data
     |      
     |      Returns
     |      -------
     |      wstr : WrapStruct object
     |         WrapStruct object initialized from data in fileobj
     |  
     |  guessed_endian(mapping) from builtins.type
     |      Guess intended endianness from mapping-like ``mapping``
     |      
     |      Parameters
     |      ----------
     |      wstr : mapping-like
     |          Something implementing a mapping.  We will guess the endianness
     |          from looking at the field values
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of binary data in ``wstr``
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  binaryblock
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  endianness
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  structarr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: ...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
     |  
     |  template_dtype = dtype([('integer', '<i2')])
    
    class WrapStructError(builtins.Exception)
     |  Method resolution order:
     |      WrapStructError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

DATA
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    endian_codes = <nibabel.volumeutils.Recoder object>
    native_code = '<'
    swapped_code = '>'

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/wrapstruct.py


None
&&&&&&&&&&&&&&&&&&&&&&&&& xmlutils &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Help on module nibabel.xmlutils in nibabel:

NAME
    nibabel.xmlutils - Thin layer around xml.etree.ElementTree, to abstract nibabel xml support

CLASSES
    builtins.object
        XmlParser
        XmlSerializable
            XmlBasedHeader(nibabel.filebasedimages.FileBasedHeader, XmlSerializable)
    nibabel.filebasedimages.FileBasedHeader(builtins.object)
        XmlBasedHeader(nibabel.filebasedimages.FileBasedHeader, XmlSerializable)
    
    class XmlBasedHeader(nibabel.filebasedimages.FileBasedHeader, XmlSerializable)
     |  Basic wrapper around FileBasedHeader and XmlSerializable.
     |  
     |  Method resolution order:
     |      XmlBasedHeader
     |      nibabel.filebasedimages.FileBasedHeader
     |      XmlSerializable
     |      builtins.object
     |  
     |  Methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |  
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |  
     |  copy(self: 'HdrT') -> 'HdrT'
     |      Copy object to independent representation
     |      
     |      The copy should not be affected by any changes to the original
     |      object.
     |  
     |  write_to(self, fileobj: 'io.IOBase') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  from_fileobj(fileobj: 'io.IOBase') -> 'HdrT' from builtins.type
     |  
     |  from_header(header: 'FileBasedHeader | ty.Mapping | None' = None) -> 'HdrT' from builtins.type
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.filebasedimages.FileBasedHeader:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from XmlSerializable:
     |  
     |  to_xml(self, enc='utf-8', **kwargs) -> bytes
     |      Generate an XML bytestring with a given encoding.
     |      
     |      Parameters
     |      ----------
     |      enc : :class:`string`
     |          Encoding to use for the generated bytestring. Default: 'utf-8'
     |      \*\*kwargs : :class:`dict`
     |          Additional keyword arguments to :func:`xml.etree.ElementTree.tostring`.
    
    class XmlParser(builtins.object)
     |  XmlParser(encoding='utf-8', buffer_size=35000000, verbose=0)
     |  
     |  Base class for defining how to parse xml-based image snippets.
     |  
     |  Image-specific parsers should define:
     |      StartElementHandler
     |      EndElementHandler
     |      CharacterDataHandler
     |  
     |  Methods defined here:
     |  
     |  CharacterDataHandler(self, data)
     |  
     |  EndElementHandler(self, name)
     |  
     |  StartElementHandler(self, name, attrs)
     |  
     |  __init__(self, encoding='utf-8', buffer_size=35000000, verbose=0)
     |      Parameters
     |      ----------
     |      encoding : str
     |          string containing xml document
     |      
     |      buffer_size: None or int, optional
     |          size of read buffer. None uses default buffer_size
     |          from xml.parsers.expat.
     |      
     |      verbose : int, optional
     |          amount of output during parsing (0=silent, by default).
     |  
     |  parse(self, string=None, fname=None, fptr=None)
     |      Parameters
     |      ----------
     |      string : bytes
     |          string (as a bytes object) containing xml document
     |      
     |      fname : str
     |          file name of an xml document.
     |      
     |      fptr : file pointer
     |          open file pointer to an xml documents
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  HANDLER_NAMES = ['StartElementHandler', 'EndElementHandler', 'Characte...
    
    class XmlSerializable(builtins.object)
     |  Basic interface for serializing an object to XML
     |  
     |  Methods defined here:
     |  
     |  to_xml(self, enc='utf-8', **kwargs) -> bytes
     |      Generate an XML bytestring with a given encoding.
     |      
     |      Parameters
     |      ----------
     |      enc : :class:`string`
     |          Encoding to use for the generated bytestring. Default: 'utf-8'
     |      \*\*kwargs : :class:`dict`
     |          Additional keyword arguments to :func:`xml.etree.ElementTree.tostring`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    ParserCreate(...)
        Return a new XML parser object.
    
    SubElement(...)

FILE
    /Users/santosg/miniconda3/lib/python3.9/site-packages/nibabel/xmlutils.py


None
